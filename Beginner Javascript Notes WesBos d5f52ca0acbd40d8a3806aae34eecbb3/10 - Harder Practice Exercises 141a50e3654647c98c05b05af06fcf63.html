<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>10 - Harder Practice Exercises</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	padding-inline-start: 0;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.page-description {
    margin-bottom: 2em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-interactiveBlue { background-color: rgba(35, 131, 226, .07); }
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-translucentGray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }
.select-value-color-pageGlass { background-color: undefined; }
.select-value-color-washGlass { background-color: undefined; }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="141a50e3-6546-47c9-8c05-b05af06fcf63" class="page sans"><header><h1 class="page-title"><em><strong>10 - Harder Practice Exercises</strong></em></h1><p class="page-description"></p></header><div class="page-body"><ul id="6a51d76f-5275-45a7-a4e4-3f439626dbbd" class="toggle"><li><details open=""><summary>55 - Face Detection and Censorship</summary><p id="1b74d7b0-e613-4eae-8f0a-bd1e5a2407f3" class=""><a href="https://wesbos.com/javascript/10-harder-practice-exercises/55-face-detection-and-censorship">https://wesbos.com/javascript/10-harder-practice-exercises/55-face-detection-and-censorship</a></p><p id="dd5d90f2-faed-408b-8813-a12b496e4af5" class="">
</p><figure id="271525b1-c4cf-4b68-abc7-656fb704755a" class="image"><a href="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/bjs.png"><img style="width:700px" src="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/bjs.png"/></a></figure><p id="53f8e52e-203a-426e-9655-9c71d4bd1143" class="">Enjoy these notes? Want to Slam Dunk JavaScript?</p><p id="4bf9f295-53d6-49eb-9703-47cb7fd9d7eb" class="">These are notes based on my <a href="https://beginnerjavascript.com/">Beginner JavaScript</a> Video Course. It&#x27;s a fun, exercise heavy approach to learning Modern JavaScript from scratch.</p><p id="1af0f51c-5204-4497-86e8-4ad39271f8d2" class="">Use the code <strong>BEGINNERJS</strong> for an extra $10 off.</p><p id="81e87c36-4c82-4d87-9704-e2f1080cbd78" class=""><a href="https://beginnerjavascript.com/">BeginnerJavaScript.com</a></p><p id="edb74260-24eb-4f79-b6fe-ecb60eaa7380" class="">JavaScript, Face DetectionEdit Post</p><p id="75ac2a44-ad3d-46fc-81c7-fa7437bd6ada" class="">This exercise is going to be a bit more fun then our previous lessons.</p><p id="bc06609d-4763-4720-8586-2f23ff8c4c44" class="">We are going to build a face detection that will detect and blur your face from a video element into a canvas element.</p><p id="1068e3d7-062b-4417-8096-80bfdff8de57" class="">This exercise is stepping a little bit ahead because there are a couple of things we need to learn a more about like promises and async/await, and bundling tools, specifically one called Parcel.</p><figure id="d6ae1fc8-c44f-4d35-93d0-7e205bcd3710" class="image"><a href="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/731.png"><img style="width:700px" src="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/731.png"/></a></figure><p id="3250727a-035e-4489-a815-05e4a8d7bffa" class="">The first thing we need to check is that we are on a browser that supports face detection.</p><p id="0438f90a-ed26-4423-a4bd-97893e490afa" class="">At the time of this recording, there is a proposal for an API, meaning it&#x27;s not finished yet and might change.</p><p id="d5c40c6c-10c6-48e6-817c-e523ed1459d6" class="">Ideally it will get into all of the browsers but currently it is only in Chrome and Android.</p><p id="3fcf53aa-4341-418b-af8d-3c0305cb8cd9" class="">The way you can tell if your browser supports it is you can go to the console on any page and type <code>FaceDetector</code>, or <code>typeof FaceDetector</code>.</p><figure id="c47bbd90-0437-4e8d-bcb9-6a53dee01c96" class="image"><a href="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/732.png"><img style="width:573px" src="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/732.png"/></a></figure><p id="a4826a78-a55c-48c1-8948-c98649038533" class="">If you get <code>undefined</code> or an error returned, that means your browser does not support it. If you are on Chrome, you likely have to go to the flags page in Chrome and turn it on.</p><p id="90c1b81c-8af7-40ce-8699-4c0075e51f34" class="">Often new features in the browser are not given to the masses because they are not ready yet. In order for us to play with those features, we need to enable them.</p><p id="04db4cca-6c4a-402d-9bd3-793c307b79bf" class="">The way you turn flags on in Chrome is you navigate to <code>chrome://flags</code>.</p><figure id="3efda8ae-9222-48d9-b3fd-023baf9e6e85" class="image"><a href="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/733.png"><img style="width:700px" src="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/733.png"/></a></figure><p id="b18edc91-c89e-4bb4-8a0c-ae81db364ad0" class="">This page contains all kinds of features that are still experimental in Chrome. You want to search for &quot;Experimental Web Platform features&quot; and enable it.</p><p id="6c2ff7ba-501e-4b37-89cd-3f1df444ba94" class="">You will probably have to restart your browser, so go ahead quit it, and restart it, and then you should see <code>typeof FaceDetector</code> work.</p><p id="5f212ae1-c6b1-4370-af4e-3ee534ae9b50" class="">If you do all that and still cannot get <code>typeof FaceDetector</code> to return &quot;function&quot; it&#x27;s possible that your computer does not support it.</p><p id="0fbd86dd-33af-4aef-bf2c-db4400cd9628" class="">But from everyone Wes has tested with, it works well.</p><p id="291826b7-8a51-49f2-87f4-2a84b586c3c9" class="">The second thing is we need to use a server in order to run this. That is because accessing a user&#x27;s webcam is a security issue <em>(you don&#x27;t want to give everybody access to your webcam)</em>, so in order to do it you must first you have to ask the user first for access to their webcam.</p><p id="f06d4ca6-6eba-473e-9d79-7f6b39620155" class="">You&#x27;ve probably been to a million websites where they ask for permission to send notifications or they request to know your location. Those are permission-based APIs in the browser, and accessing someone&#x27;s webcam is no different than that.</p><p id="9986ae26-5e4a-45f6-aa22-85448dfb8cbf" class="">That sort of preference and permission, it allowed or not, is tied to the origin.</p><p id="9a0fd758-0d9a-4dec-a9c4-b3e1c4440c07" class="">An <strong>origin</strong> in JavaScript is just a fancy way of saying a <strong>domain name</strong>.</p><p id="5785b0aa-5929-43cb-aead-a1e7af354b3e" class="">So in Wes&#x27; case, he is currently allowing the camera on localhost, but you might allow the camera on New York Times or Facebook or all these different websites.</p><figure id="0027b952-3e71-4398-9639-e94eb1e3c3ee" class="image"><a href="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/734.png"><img style="width:700px" src="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/734.png"/></a></figure><p id="7f44e2ff-12bb-472e-8c71-b19c7c394e15" class="">Everytime you visit a new origin, a new domain name, you&#x27;re going to have to ask the user for access to their webcam and it will pop up.</p><p id="ba367308-4ddf-4053-bf65-d0730146d663" class="">So in order for us to do that, we cannot just open up <code>face.html</code> (from the <code>/53 - Face Detection Censorship</code> folder) in the browser like we have been doing up until now.</p><p id="9661f70c-57ba-403f-a6ad-29ffad5e077c" class="">The reason for that is the file path that you see in the url browser above is not an origin. If security stuff is tied to an origin, it won&#x27;t be able to do it from a local file.</p><p id="398d5455-18e8-44a2-8c42-b56b493e91ea" class="">You might notice the X next to the camera. If you take a look, you will see that the camera is blocked.</p><p id="b2383e9d-4331-4e05-80d9-1bc7e10ac329" class="">If you try to allow it by clicking &quot;always allow&quot;, it still won&#x27;t work.</p><p id="a78485ee-deb8-4928-a995-b9bd469c3872" class="">So you cannot open the HTML file directly in your browser, it must run through a server. So how do we run a server?</p><p id="79fbeb43-2acc-4d04-ae12-cd204b382670" class="">One server that Wes likes is a <strong>bundler</strong>, called Parcel, which we will learn more about when we get to the modules section.</p><p id="a94ebf69-000d-4958-9c08-8e2cec4ea3fe" class=""><strong>Parcel</strong> will give us a little development server where when we change something on the page, it will automatically refresh the page for us. If we change any of our CSS, it will automatically re-load the CSS on the page without actually having to do a full page refresh.</p><p id="9b34b1f4-45b2-41ae-8550-023515c5b07c" class="">To get that running, we need to open up a terminal. If you need a refresher, go back to video 2 where Wes goes over the different types of terminals.</p><p id="1dec5c12-0308-4372-9fea-de8e0a7d0118" class="">Once you have the terminal open, go into the folder that contains the <code>face.html</code> file.</p><p id="672a3fc3-456d-4cd5-8814-071011aab213" class="">To do that, you need to use the command <code>cd</code> to go into the correct directory.</p><p id="d052e10c-28f7-4f51-b9be-1cc7148ce26b" class="">If you don&#x27;t know where you are starting in the terminal, you can type <code>pwd</code> and it will tell you where you are on your computer.</p><p id="b4bbf460-1b8c-4ebc-87e0-b9cc9b03fe16" class="">What is probably easier than that is if you are using VS Code, you can just right click the folder and select &quot;Open in Terminal&quot;.</p><p id="dc92b7a4-de8f-4ea6-9b3e-9d375630decb" class="">That opens the terminal up in the built in terminal in VS Code.</p><p id="96563bbb-86d8-4222-9f3c-d7172b932bd4" class="">In the second video, Wes had us install <strong>Node.js</strong> and <strong>NPM</strong>. You can check if you have both installed by typing <code>node -v</code> and <code>npm -v</code> in the terminal. That will return to you the version you have installed, as shown below 👇</p><p id="103841e6-3db1-42c9-baad-f9b3d17feffb" class="">If you need to check what the latest Node.js version is, you can go to <code>nodejs.org</code> and find the LTS version which stands for long term support -- that is the most stable version.</p><p id="ccd23503-f84d-4812-aa42-8b42ee4e089c" class="">Once you have confirmed you have both of those and you are in the right directory, go ahead and type <code>npm install</code>.</p><p id="1b675630-1c70-4d94-8b14-a3b559b9b30e" class="">Wes will cover this all more in the future, but what that does is it will take all our dependencies and install them for us.</p><p id="68c8193f-4061-497e-86fc-c4a01ddf177d" class="">In our case we are installing Parcel.</p><p id="1f9a8f0b-2d01-40b8-a12d-a23d11d494f7" class="">You should completely ignore the versions in this file, because that will likely change in the future and Wes will be keeping the files up to date.</p><p id="62e298f1-507e-429f-8128-294527e59b61" class="">While we wait for that to finish installing, let&#x27;s take a look at the <code>face.html</code> structure to see what we are working with.</p><pre id="cef752b7-66a7-4578-808b-21cb367f5a3d" class="code code-wrap"><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;title&gt;Censorship&lt;/title&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;../../base.css&quot;&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;div class=&quot;wrap&quot;&gt;
&lt;video class=&quot;webcam&quot;&gt;&lt;/video&gt;
&lt;canvas class=&quot;video&quot;&gt;&lt;/canvas&gt;
&lt;canvas class=&quot;face&quot;&gt;&lt;/canvas&gt;
&lt;/div&gt;
  &lt;script src=&quot;./pixelated-face.js&quot;&gt;&lt;/script&gt;

  &lt;style&gt;
    * {
box-sizing: border-box;
}

    body {
margin: 0;
}

.wrap {
position: relative;
min-height: 100vh;
display: grid;
justify-content: center;
align-items: center;
}

.wrap &gt; * {
grid-column: 1;
grid-row: 1;
}

.face {
position: absolute;
}
&lt;/style&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><p id="8d474b92-761f-4a30-8799-fdb736fb86e5" class="">We have our base CSS which is just the blue background.</p><p id="19892f2d-edcb-42b9-8394-5e3fff9c1595" class="">Then we have our wrapper, which has a video element, a canvas element, and another canvas element.</p><p id="19c1beab-503c-46a2-9bff-8ab554c23bf6" class="">One canvas is for the video and one is for our face.</p><p id="12c4107d-9c96-4bcc-9ae8-0cfe41ffc67a" class="">Then we are linking up the <code>pixelated-face.js</code>.</p><p id="5f572d7c-810f-4c09-a532-ee884de6c485" class=""><em>(Note: Wes is using a different file than you in the video so he can demonstrate how the finished result works)</em>.</p><p id="189408a9-bf6d-42a5-be63-f424f7de697f" class="">After that we have a few styles that just center things on the page, nothing too interesting.</p><p id="6171d3e0-00b7-455b-a0e5-4e8c329df19c" class="">If you look at the terminal, the package should be done installing.</p><p id="000b985a-a962-41ab-96b3-97f103ed1478" class="">You may notice in the terminal something like &quot;found 39 high severity vulnerabilities&quot;. That will pop up when you <code>npm install</code> things. What happens there is that some dependencies have security vulnerabilities that need to be fixed and what happens is the people who create Parcel will fix that eventually. So if you see that, don&#x27;t freak out. It&#x27;s totally fine, hopefully NPM will hopefully find a better way to deal with those warnings.</p><p id="ebe1fde9-b709-406c-8c08-39c25091117e" class="">Create a new file <code>pixelated-face.js</code> and inside of it log &quot;it works!&quot;.</p><p id="6f3410c2-182a-456b-9a50-d5674c30f5be" class="">Go back to the terminal and in the same directory type <code>npm start</code>.</p><p id="6604ff52-f3af-46ed-bf54-fc35586205ca" class="">That will run Parcel against the <code>face.html</code> file and it will run the server at some URL.</p><p id="b94b4df0-d24f-49ab-8f5f-3a5aa7736228" class="">If you go to that URL in the browser and open the console, you should see &quot;it works!&quot;.</p><p id="fdfa1bbe-f5f4-4685-9fee-fa97b9651539" class="">Sometimes you will see weird warnings like the yellow one above, and that is related to a Chrome extension that you have installed, and that is annoying because it gets in the way of writing our actual code.</p><p id="70ebc6da-e1db-479c-b3c3-2ee2a9dc8c35" class="">That can be annoying because there is no way to get rid of them.</p><p id="bb2ac67e-88f4-4316-a97d-0fb21ec4d0e2" class="">One trick Wes has found it typing into the Filter <code>-DevTools</code> as shown below 👇</p><p id="14512cd7-2b7e-4234-b458-3ad60aba659c" class="">Now that we have everything up and running, let&#x27;s dig into some code.</p><p id="24cfadb2-fd18-4481-a1d8-73b5f1274c66" class="">The first thing we want to do is select all the elements that are on our page. We have our video, our canvas, and then another canvas.</p><p id="273e27b1-e3da-4cfb-975f-f14fe6e067b6" class="">We are going to access the user&#x27;s webcam, dump it into the canvas element with the class of video.</p><p id="3a907165-cda2-467e-ac54-7367fedb1513" class="">Then we are going to take the frames of that video, put a square around the person&#x27;s face.</p><p id="7f41e091-5e3e-492d-bafb-9625647f9bae" class="">In the canvas element with class of face, we will pixelate the person&#x27;s face.</p><p id="e6b21125-9849-4a7c-85c5-4456040d70a8" class="">The canvas element work could be done on one canvas, but Wes prefers to keep them separate in case he ever wants to only pull one of those images out.</p><p id="5887d18e-169e-4236-a0e0-c83382747971" class="">Go ahead and grab those three classes, <code>webcam</code>, <code>video</code>, and <code>face</code>.</p><p id="80e43e93-e1a8-4a64-afd6-ea1256fb4f48" class="">Let&#x27;s page them into our <code>pixelate-face.js</code> file.</p><p id="5fa3d409-ee1a-4c6f-b63f-5b7727add6b0" class=""><em>Note: in the video, at this section, Wes is able to paste all three classes like this on the page 👇</em></p><pre id="dfeaf3b6-04ef-4261-8ffd-32e3065550e4" class="code code-wrap"><code>webcam
video
face</code></pre><p id="4b0d29ab-a8c4-437c-834f-c94b546cac7c" class=""><em>In VS Code, he is able to press the shortcuts </em><code><em>CMD + A</em></code><em> and then </em><code><em>CMD + Shift + L</em></code><em>, and that gives him a cursor on every single line.</em></p><p id="cc820ec6-9c7d-48d1-9f7c-9d9648aa9575" class="">Add the following code 👇</p><pre id="9ed1d554-daf6-4952-8052-1dafeab16cf9" class="code code-wrap"><code>const video = document.querySelector(&quot;.webcam&quot;);
const canvas = document.querySelector(&quot;.video&quot;);
const faceCanvas = document.querySelector(&quot;.face&quot;);</code></pre><p id="9c703ad6-d93b-41d7-994e-f29942acc0b9" class="">We need to pull the context out of each canvas element now.</p><p id="85041058-60b4-4338-aabb-a5a6d9044b6d" class="">We talked about that in our Etch-a-Sketch exercise but that is where we do the drawing.</p><p id="653cdfcc-6bd2-4d3e-83ee-430bab6365bb" class="">Modify the code as shown below 👇</p><pre id="8c5b53cf-5f0d-4112-81f3-62c7c1d5ff12" class="code code-wrap"><code>const video = document.querySelector(&quot;.webcam&quot;);

const canvas = document.querySelector(&quot;.video&quot;);
const ctx = canvas.getContext(&quot;2d&quot;);

const faceCanvas = document.querySelector(&quot;.face&quot;);
const faceCtx = canvas.getContext(&quot;2d&quot;);</code></pre><p id="0f998c5b-9b80-4aa5-8961-c40da4391e2e" class="">Now make a new face detector, and then let&#x27;s log everything we have so far.</p><pre id="03be034e-8c5c-443c-b86f-24e6001918ca" class="code code-wrap"><code>const faceDetector = new FaceDetector();
console.log(video, canvas, faceCanvas, faceDetector);</code></pre><p id="47d2477d-bb24-4dd8-8e2e-c2e67bfb01f1" class=""><em>Note: you might notice in VS Code that it says &quot;FaceDetector is not defined&quot; if you hover over </em><code><em>new FaceDetector()</em></code><em>.</em></p><p id="3df6df5e-d5c6-4d5f-99a8-61a737814b6e" class=""><em>That is because it is looking for a function called </em><code><em>FaceDetector</em></code><em>. The way we can solve that is to say </em><code><em>const faceDetector = new window.FaceDetector()</em></code><em>. That is fine to do (Wes told us not to do it in looping) here because this FaceDetector API does not exist in Node.js land.</em></p><p id="3f9db275-e5be-47c3-8fa1-3f10230fc441" class="">The next thing we need to do is write a function that populates the user&#x27;s video.</p><p id="6095dc32-bf42-4106-a326-4c85fb11ee73" class="">To do that, grab the stream from the user&#x27;s webcam.</p><pre id="ccdf8ff5-a213-4b6d-928d-5ded23263bda" class="code code-wrap"><code>function populateVideo() {
const stream = navigator.mediaDevices.getUserMedia();
}</code></pre><p id="9fe2d538-71bb-4e57-ae40-5ef6ab16031a" class="">You need to pass <code>getUserMedia()</code> some options, specifying if you want video or audio (we just want video). You can just pass <code>video:true</code> or you can ask for a specific size from it.</p><p id="66a05871-bb48-4e72-b736-201cdb62261f" class="">Modify the code as shown below and get rid of the log we added earlier.</p><pre id="830ff3c6-e67e-43ad-95f3-13b2251821d7" class="code code-wrap"><code>function populateVideo() {
const stream = navigator.mediaDevices.getUserMedia({
    video: { width: 1280, height: 720 },
});

console.log(stream);
}</code></pre><p id="a7f9ba47-ea92-4cdd-a468-4521fe8a3d5e" class="">If you refresh the HTML page and try to run <code>populateVideo()</code>, you will see an error as shown below.</p><p id="f84da1e0-9fdb-4b01-9c68-c1e54bb8fab3" class="">Now that we are running things through a bundler, we no longer have the ability to access our functions globally via the console.</p><p id="d00c3939-fb8e-4849-947d-1ddc81fe9c3d" class="">If you ever do want to do that, you can do <code>window.populateVideo = populateVideo;</code>.</p><p id="2f6dec51-f6e7-462f-9337-66c349235ad1" class="">That will surface it for you, but that is not a great way to do it.</p><p id="790d08ea-bb43-43db-94dc-9e075fd537b3" class="">The best way to do it would just be to add a log in your JavaScript file and you can see it.</p><p id="a2ecca42-a552-4562-b1ce-2ac2975eccb5" class="">If you do ever need to access it from the chrome dev tools, you can right click it, and click store as global variable.</p><p id="38e7dde7-d9cd-401e-8bab-c622fd848fda" class="">That will store it in a global variable called <code>temp1</code>.</p><p id="ea5733c9-07d9-43b8-a149-2566b09c4b88" class="">If you try calling <code>temp1()</code>, you will see something returned to us called a <strong>promise</strong>.</p><p id="7052a89f-357c-4f5e-baf5-a048fb4e3129" class="">There are a couple things going on here. First, it might show you a little recording icon on the chrome tab (it might not, we will go over that in a sec.).</p><p id="667aa460-a6d2-446d-bd2b-c30931199367" class="">As mentioned, we are returned a promise when we call <code>temp1()</code> in the console (which is our <code>populateVideo()</code> function stored as a global variabe).</p><p id="f48c3fcf-f94f-4f85-b990-efb115a28d4e" class="">What that means is we have not been returned the actual stream of video, instead it&#x27;s just something called a promise that it will get the stream of the webcam eventually.</p><p id="288b3b68-61e8-4d0e-9c36-fd4e3bf7cf41" class="">We will get more into promises in future videos, but for now just know that <code>navigator.mediaDevices.getUserMedia()</code> is a special kind of function that returns this thing called a promise.</p><p id="b61fba00-a7ec-4651-a987-3ad9324f45e2" class="">In order to wait for the stream to come back from the webcam, because that takes some time, we need to first mark the function as <code>async</code> by typing the word <code>async</code> in front of it, and add the keyword <code>await</code> before we call <code>navigator.mediaDevices.getUserMedia()</code>.</p><p id="7671335d-c470-404d-9db1-e3169d45c3c3" class="">Add a call to <code>populateVideo()</code> where we used to log it.</p><pre id="27b7f7a3-39dd-441e-91c1-e1bb86106a88" class="code code-wrap"><code>async function populateVideo() {
const stream = await navigator.mediaDevices.getUserMedia({
    video: { width: 1280, height: 720 },
});

console.log(stream);
}

populateVideo();</code></pre><p id="d7fa3093-bd36-4b87-8998-ac199b3f391e" class="">If you refresh the page and look at the console, you may see the following 👇</p><p id="ab6734a3-9913-4c47-9e03-54c9351b965f" class="">If you do not, you may see a little red X on your video camera icon in the browser tab.</p><p id="f502d95f-d7c9-49b2-857c-9f3dcef8e7b7" class="">To fix that, you need to click on it and select &quot;continue&quot; or &quot;always allow access&quot;.</p><p id="63ad3190-f707-4f75-bf5b-4b83d4f84e81" class="">Click done, then reload the page, and then you should see a media stream in the console.</p><p id="37acf132-872b-4517-8cfa-0fe8d7bc7de3" class="">How is what is returned to us via the <code>MediaStream</code> useful?</p><p id="22c4ded5-ba55-44f8-aabc-489fecb4c8d8" class="">We can now put the stream into our video which we have already selected.</p><p id="c2e00b85-2d88-4782-ac05-ba25d336efc3" class="">You would normally pass the video something like <code>video.srcObject = &quot;dog.mp4&quot;;</code> but instead you will be passing the video the stream then calling <code>play()</code> on it.</p><p id="1d9a1bd9-1c69-4510-a0b0-2b4b42c159d9" class="">Put an <code>await</code> in front of where you call <code>video.play()</code> because sometimes it takes a few seconds to start playing and that will wait for it.</p><pre id="17ba1536-fd19-4a8e-93b7-c76b1efa3f8e" class="code code-wrap"><code>video.srcObject = stream;
await video.play();</code></pre><p id="23d090d7-add7-437c-b4e3-80a8fdaa29b3" class="">If you refresh the page, you should see it worked.</p><p id="8fc991ad-4070-491a-b4aa-eaac5fe02805" class="">So what did we do there?</p><p id="b29d7c59-f199-41d4-a452-c8097325ec16" class="">We made a function called <code>populateVideo()</code>, where we grabbed the feed off the user&#x27;s webcam, and then we set the object to be the stream, and then played it.</p><p id="f63229c4-483a-4189-b25a-3caf0b11d6f3" class="">Another thing we need to do is size the canvases to be the same size as the video.</p><p id="6e4940c5-05dd-4df3-b530-9a8654c8d9e7" class="">If you were to log <code>video.videoWidth, video.videoHeight</code> you should get 1280 x 720.</p><p id="6ae912bf-6430-4488-8a62-413e48c7e007" class="">If you change one line of code from <code>navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } });</code> to <code>navigator.mediaDevices.getUserMedia({ video: true });</code>, and refreshed the page, you should see the sixes 640 x 480. After you test that, switch it back.</p><p id="5536efa2-27f6-495a-9bfb-5e16da3bddc0" class=""><em>Note: these sizes might not be the same on your computer, depending on your webcam.</em></p><p id="ab4d5371-c627-4f56-a3b2-41319861f6ad" class="">So you need to size the canvases to match the video, which you can do like so:</p><pre id="7e54efb9-5a80-4240-ab2e-3a24c0d051f4" class="code code-wrap"><code>canvas.width = video.videoWidth;
canvas.height = video.videoHeight;

faceCanvas.width = video.videoWidth;
faceCanvas.height = video.videoHeight;</code></pre><p id="70c0b829-4f8d-4ad0-b356-a63c55047884" class="">Now we have two canvases that are the same size as the video feed.</p><p id="15afb3f2-c13a-4d7d-8929-14813a71ee19" class="">The next thing we need to do is work with the FaceDetection API.</p><p id="9cc406b9-9aac-4441-bb6b-0f5fd76331cc" class="">We will call it <code>detect</code> and it also needs the <code>async</code> keyword in front of it (we will cover why in future video).</p><p id="919d7df7-e538-4753-88c0-cb78f0bbbbbb" class="">We want to detect faces that are in the shot.</p><p id="0f6a6a21-daa2-4693-8dc7-8e6094b4f8e0" class="">Then we will use the <code>faceDetector</code> variable we created earlier and call <code>.detect()</code> on it.</p><p id="d2e325e4-3a7b-4e2b-a6b5-9f623f420b56" class="">You pass <code>detect()</code> reference to three things:</p><ul id="708070e8-91d6-497d-bfd1-c527f0d9c24e" class="bulleted-list"><li style="list-style-type:disc">an image</li></ul><ul id="cd104f63-114b-44dd-8e13-e9199bc58481" class="bulleted-list"><li style="list-style-type:disc">a video</li></ul><ul id="ae829ec3-1d33-4149-a935-2dc8a90e5166" class="bulleted-list"><li style="list-style-type:disc">or a canvas</li></ul><p id="0d6edc74-e5ad-4c0e-adaf-f7a81ba4f7dd" class="">In our case, pass it access to the video.</p><pre id="edffc21f-601c-4a1d-9715-91c25f2b48d8" class="code code-wrap"><code>async function detect() {
const faces = await faceDetector.detect(video);
console.log(faces);
}</code></pre><p id="dcee8701-e705-42f0-8d2f-f6a8ee93d07b" class="">We need to run the <code>detect()</code> function once, but after the video has been populated. If you run <code>detect()</code> when there is no video, it will not find any faces.</p><p id="e1f7bec6-cb44-4b9c-b5b1-c285c4da3bcb" class="">The way you can do that is by tagging a <code>.then()</code> onto <code>populateVideo</code> like so 👇</p><pre id="2906eb16-896b-4d6a-8d92-68b2311a453a" class="code code-wrap"><code>populateVideo().then(detect);</code></pre><p id="553c6cc2-f159-4563-94dc-a7270f8f60f5" class="">This is promise-based, which we will cover in more detail in future videos.</p><p id="bd397992-9bd0-4322-b612-4dbdceeda7ff" class="">If you refresh the page and open the console now, you should see a face detected. It will tell you exactly where the eyes, the nose, and the mouth are.</p><p id="dc9f9ec7-06fd-4ec0-a9af-3d14f99f12d0" class="">It also gives us the <code>boundingBox</code> which is the square around the user&#x27;s head.</p><p id="497bc619-460a-488d-b192-c8593fe04d07" class="">The way we are calling <code>detect()</code> right now, it will only run once after <code>populateVideo()</code> is done playing. So we need to call <code>detect()</code> over and over again.</p><p id="e405a466-8221-4940-9d77-4ed325623ff3" class="">You might be thinking we can use an interval for this. That is the way we used to do this stuff, but there is a better way, that allows you to do things as fast as possible, which is to use something called <strong>request animation frame</strong>.</p><p id="d6fe3358-2f7a-4889-80dd-9da9bb303812" class=""><strong>Request animation frame</strong> allows the browser to tell us when we should repaint or redo something.</p><p id="2f8e46c7-c932-4567-a4d5-6c15b0688ef9" class="">Instead of us trying to do something every 60 milliseconds, because computers vary in speed, request animation frame will repaint or rerun the stuff on the screen a lot less frequently on a computer that isn&#x27;t as fast.</p><p id="6631460a-9dc1-4381-bd8f-8b2076a8b684" class="">Ask the browser when the next animation frame is, and then tell it to run <code>detect</code>, like so 👇</p><pre id="77881a4d-635a-4ae2-a032-ab6804246942" class="code code-wrap"><code>async function detect() {
const faces = await faceDetector.detect(video);
console.log(faces);
// ask the browser when the next animation frame is and tell it to run detect for us
requestAnimationFrame(detect);
}

populateVideo().then(detect);</code></pre><p id="af3b4eb6-0abe-4252-a420-abe7113c2b52" class="">If you refresh the page, you should see lots of <code>DetectedFaces</code> logged in the console.</p><p id="49261928-218e-41f3-8428-fd8ec7641369" class="">What we did there is instead of calling <code>requestAnimationFrame(detect)</code>, we could have just called <code>detect()</code> and that works pretty well, but because of performance reasons, it&#x27;s better to call <code>requestAnimationFrame()</code>.</p><p id="a14d9858-1aab-47e3-b826-344003deb9d2" class="">What we have just done there is a concept called <strong>recursion</strong>.</p><p id="78d09200-b488-49f0-ba13-b52ad6b8cf55" class=""><strong>Recursion</strong> is when a function calls itself. It will run forever, and ever, until something stops it, such as an exit condition. Recursion is when a function calls itself, inside of itself.</p><p id="d17593e5-87fe-4710-99be-4b1dd9a1fb41" class=""><code>detect</code> is being called from <code>detect</code> which allows us to run it infinitely.</p><p id="062d1319-0c1b-4a30-a0ef-7a9cca30ba22" class="">Let&#x27;s take a look at the <code>DetectedFace</code>.</p><p id="39759b0b-301a-4741-a0cf-c28b9e709c95" class="">As you can see, it gives us an array with one item. Log <code>faces.length</code>.</p><p id="2d7ba095-482c-4f61-81c3-92062222daf0" class="">As you can see, it only logs one face until Wes holds up the queens face on a dollar bill to the webcam.</p><p id="853bcd29-3833-48ab-b284-6f525930943f" class="">When Wes holds up a picture, Face Detection detects all four faces.</p><p id="db1e9e3a-aaa5-42d9-8780-107ab9f4efe0" class="">Next up, we need to do 2 things:</p><ul id="3416437c-f1a0-4f52-b1a2-94837d8d9d32" class="bulleted-list"><li style="list-style-type:disc">draw triangles around the faces that are found</li></ul><ul id="c6cdd1f4-b6bc-4775-98d6-700ab2e9db2f" class="bulleted-list"><li style="list-style-type:disc">censor the face by pixelating the area that is around their face</li></ul><p id="b777d5cb-845a-428b-9291-8a5cc3839f78" class="">Make a function <code>drawFace</code> which will take in the user&#x27;s face. The function will need to know how wide and high is the user&#x27;s face, because the further away the subjects are from the camera will affect that.</p><p id="2e36b43d-61ee-4541-86ab-14d7520f7f99" class="">We also need the X and Y coordinate from the top. For example over 400 pixels and down 300 pixels is where the head starts.</p><p id="b4ff08ba-770d-4d8d-b764-d952a2488b81" class="">Start by just logging the faces and calling <code>drawFace()</code>. Loop over all the faces in a <code>.forEach</code> and call <code>drawFace</code> for each.</p><pre id="4c4eeac8-09e5-4f3d-81b6-d2782b533c99" class="code code-wrap"><code>async function detect() {
const faces = await faceDetector.detect(video);
console.log(faces);
// ask the browser when the next animation frame is and tell it to run detect for us
faces.forEach(drawFace);
requestAnimationFrame(detect);
}

function drawFace(face) {
console.log(face);
}

populateVideo().then(detect);</code></pre><p id="e6e85eeb-ebc7-4e28-88c5-f048258de800" class="">When you refresh the page and look at the console, you should see many faces logged.</p><p id="bed2b554-fab7-4c01-9790-01d2478e76b5" class="">Let&#x27;s get the bounding box from one of those. We need the <code>top</code> and <code>left</code>, <code>width</code>, and the <code>height</code>.</p><pre id="0128c2c0-54d6-4f5c-9689-50cf47c15be9" class="code code-wrap"><code>function drawFace(face) {
const { width, height, top, left } = face.boundingBox;
console.log(width, height, top, left);
}</code></pre><p id="03df9aa6-4255-45f4-8695-7563d227d150" class="">If you refresh the page, you should see lots of logs like the following 👇</p><p id="9e250c00-41de-4566-9d74-f0419fdbc2f8" class="">One trick you can do is if within the log, you just wrap the items in curly brackets as shown below, it will log the property names and values.</p><pre id="c3516c32-0aae-400d-a5c5-bf54de9992ba" class="code code-wrap"><code>console.log({ width, height, top, left });</code></pre><p id="d2b72896-6200-4456-8c0f-ae6c61b9e921" class="">The reason that works is because you are essentially making an object.</p><p id="611043c6-0f63-40b7-a7bb-9affeeb52edc" class="">Now we want to draw a box onto our canvas element that is down in the part of the page that is highlighted in the image below.</p><p id="5982d734-2e65-4338-ad47-097c0d7834c7" class="">We are going to overlay it with the video in order to do that.</p><p id="da685d33-e036-49b5-a775-7c5ef0154a0d" class="">Let&#x27;s set a couple of defaults at the top of the page.</p><pre id="bab67adc-807c-45db-8247-b15f394884ac" class="code code-wrap"><code>const ctx = canvas.getContext(&quot;2d&quot;);
ctx.strokeStyle = &quot;#ffc600&quot;;
ctx.lineWidth = 2;</code></pre><p id="95e8f9bc-a790-484e-aef7-e53aacbae748" class="">Within <code>drawFace</code> function and call <code>ctx.strokeRect()</code>, which is the API for drawing a rectangle.</p><pre id="e3d94d4b-c38e-412d-9e80-7fe3afea53b8" class="code code-wrap"><code>function drawFace(face) {
const { width, height, top, left } = face.boundingBox;
ctx.strokeRect(left, top, width, height);
}</code></pre><p id="3fa8c5dc-f1cd-4fb4-9ed5-eadfabea75b0" class="">As you can see, it does work. if you move your face around, the boxes should move around as well.</p><p id="9a20deec-2b3d-4bae-ab23-4614746e895f" class="">We need to fix a few things though. One of those things is that our rectangles are not overlaid on top.</p><p id="d7641d97-2dca-46ec-930f-63705892a66b" class=""><em>Note: if the rectangles are overlaid for you, you can ignore these instructions.</em></p><p id="363be4ab-7702-4390-90b9-0422c1de9fff" class="">Let&#x27;s take a look at <code>face.html</code>. It seems like it&#x27;s ignoring the style tag. Try moving the styles to the head, as shown below.</p><pre id="74b5aaf9-33ab-40b5-9434-679d0107ad2b" class="code code-wrap"><code>  &lt;style&gt;
    * {
box-sizing: border-box;
}

    body {
margin: 0;
}

.wrap {
position: relative;
min-height: 100vh;
display: grid;
justify-content: center;
align-items: center;
}

.wrap &gt; * {
grid-column: 1;
grid-row: 1;
}

.face {
position: absolute;
}
&lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;</code></pre><p id="b796bf14-9d64-4d5d-ab83-f53f1f619d6e" class="">If you refresh the page now, it should work. This likely happened because we are using a beta version of Parcel.</p><p id="ae7cde37-3524-4b29-a98f-769032f99f04" class="">The next thing to fix is that the stroke that the rectangle is created in is not yellow. Try moving where you set <code>strokeStyle</code> and <code>lineWidth</code> into the function right before you draw the rectangle like so 👇</p><pre id="22ad73b6-59bc-4686-a4a3-3fbf71edd257" class="code code-wrap"><code>function drawFace(face) {
const { width, height, top, left } = face.boundingBox;
ctx.strokeStyle = &quot;#ffc600&quot;;
ctx.lineWidth = 2;
ctx.strokeRect(left, top, width, height);
}</code></pre><p id="0b9b34dc-9c52-4a87-beea-295156d16160" class="">The next thing to fix is that they are not clearing. Fix that by calling <code>ctx.clearRect</code> before we draw the rect.</p><pre id="da696c31-34c7-4871-b742-b82d6e91041f" class="code code-wrap"><code>ctx.clearRect(0, 0, canvas.width, canvas.height)</code></pre><p id="94b5a825-e4a9-4900-a999-184742c3f6ed" class="">That clears the amount, the width and the height, based on starting at the top left hand corner, every time it runs, it clears the canvas for us.</p><p id="66077f40-399e-4f85-93f9-64b5485469b4" class="">It is working pretty well. It is a bit jumpy right now, it used to be a lot better, they&#x27;re still working on it. The eyes, nose, and mouth values were working very well for Wes for a while, but currently they&#x27;re really weird.</p><p id="23c9b9ae-6cec-41d5-950e-affeaed868e1" class="">The next thing we want to do is pixelate the user&#x27;s face on top of it. Lets go ahead and do that.</p><p id="8c87e2e9-b692-4f8b-aead-643aaa3db0ee" class="">Create a function called <code>censor</code> which will take in a <code>face</code>. In our case, we don&#x27;t care about anything but the bounding box, so instead of doing something like below 👇</p><pre id="2da8b86e-0f6b-46de-b9f5-6b9d08427a05" class="code code-wrap"><code>function censor(face) {
const faceDetails = face.boundingBox;
}</code></pre><p id="46cd9e20-8525-4444-96d7-e9ee5fd89549" class="">Destructure the bounding box properties directly like so 👇</p><pre id="bd423765-c93a-4999-a0cb-1595d2477e14" class="code code-wrap"><code>function censor({ boundingBox }) {

}</code></pre><p id="c776dc07-bef1-4ee2-9146-63ee47a28f5a" class="">Now we just have a variable called <code>boundingBox</code>, which we could have rename to a variable called <code>face</code> like so 👇</p><pre id="7659497b-5612-493e-9fc3-5a7769e5f661" class="code code-wrap"><code>function censor({ boundingBox: face }) {
console.log(face);
}</code></pre><p id="a7788add-b225-4fba-af88-3bee46ae79ce" class="">As you can see, we have bounding box.</p><p id="bef9ad8e-16c2-422b-8ade-2de3482ceed9" class="">Now the question is how do you censor something?</p><p id="146c645b-ab3b-4f50-a0e4-730959e3c319" class="">There are a couple of different ways you can do it.</p><p id="8ffa7b62-54eb-4fc3-b169-9c4f36ed6ed2" class="">The best way Wes has found is to take a snapshot of the user&#x27;s face, scale it down very very small, and then paint it to the canvas. And then immediately after that, pull it off the canvas, stretch it back up and put it back in.</p><p id="d9daacea-ea92-4881-9f9a-69e4ca6cf347" class="">So essentially you make it really small and then save it and lose all the pixel quality, and then you take it out, stretch it back up again, and that&#x27;s how you get the pixelation look.</p><p id="23972219-27eb-43d8-bd18-3b50d77d9e1d" class="">Let&#x27;s first write out comments for what we plan to do.</p><pre id="0c2ef865-9c0b-4f22-a595-f3e6cfc45c1b" class="code code-wrap"><code>function censor({ boundingBox: face }) {
// draw the small face
// take that face back out and draw it back normal size
}</code></pre><p id="9100da41-44b5-42c2-ac4e-9df0cb025214" class="">Now the way we are going to do this is we are going to take our second canvas context, <code>faceCtx</code> and call <code>drawImage()</code> on it.</p><p id="b99e8ab8-3e8c-464d-bfdf-092024886acf" class=""><code>drawImage</code> takes in a lot of arguments, let&#x27;s look it up on MDN.</p><p id="1b2db0e6-277a-46f3-9ff1-b24df58c70a1" class="">(t takes a few set of options. You can either pass in 3 (<code>image</code>, <code>dx</code>, <code>dy</code>), 5(<code>image</code>, <code>dx</code>, <code>dy</code>, <code>dWidth</code>, <code>dHeight</code>), or it takes 9 (<code>image</code>, <code>sx</code>, <code>sy</code>, <code>sWidth</code>, <code>sHeight</code>, <code>dx</code>, <code>dy</code>, <code>dWidth</code>, <code>dHeight</code>).</p><p id="7dc66793-bab4-4ddd-b60b-6df3bd5c6252" class="">We will be using all 9, and Wes will do his best to explain what each parameter is.</p><p id="a6a194df-a79b-4346-809b-271d367dabd6" class="">Let&#x27;s get started.</p><p id="2c7bd184-2a22-4452-9622-cbea21221079" class="">The first argument <code>drawImage</code> takes is the image you want to draw to it, so we will pass in our <code>video</code>, <code>faceCtx.drawImage(video);</code></p><p id="ae29e322-2b65-4ff6-8a3d-51a36d5e9e87" class="">Then it wants the <code>x</code> and the <code>y</code> coordinates of where it should start drawing the image so we will pass <code>0,0</code>, like so <code>faceCtx.drawImage(video, 0, 0);</code>. Save the file.</p><p id="e8a88f1e-ff50-486a-ac7b-bf66613cea38" class="">If you just look at the HTML page, it might look like nothing has changed but if you inspect it, you will see that what we are actually seeing is the canvas, not the video.</p><p id="d4462de6-7714-47f4-aed0-7f0c90482e3c" class="">If we add a <code>display:none</code> CSS style to the video, you will notice that you can still see yourself. The video is being painted onto the canvas.</p><p id="5194fef5-4768-4d2e-b5f7-df2ce52e4362" class="">Now this isn&#x27;t exactly what we want to do. We want to take the square that is painting on Wes&#x27; face and throw it on there.</p><p id="0d4cd8af-3e29-495f-9282-5d6ac51a224c" class="">Comment out the <code>faceCtx.drawImage()</code> line of code for a second to make sure you have the square painting. If you do, that is good.</p><p id="e4b1cb63-cb1d-4f05-82b3-b72e0296145a" class="">Now let&#x27;s go through every single of the 9 arguments, one by one.</p><p id="5c97b7ba-3d6d-4969-8d81-3facd44edc26" class="">5 are source args, which means they are about how we pull data out of this video, and then 4 arguments about how we want to paint it into.</p><p id="e0bd9622-3fde-4aee-affa-37141fb2a7ad" class="">We only want the inside of the square to be painted onto it.</p><p id="1c6bc86f-f24c-4e68-b818-9eb3371b509b" class="">The first argument is where does the source come from, which in this case is our video tag.</p><p id="700fb78c-389a-4f39-a739-7561827f7781" class="">The next two are <code>face.x</code> and <code>face.y</code>, which are where do we start the source pull from? We are trying to pull the square out so we want to start at the top left corner of the square.</p><p id="8361a0a1-0e13-49de-a6b6-8744a2f91374" class="">If we have where we start from, we need to know how wide and how high it needs to go, so we pass <code>face.width</code> and <code>face.height</code>. That is all the pulling out arguments.</p><pre id="42549391-ad49-4ee3-9042-431edbc472c0" class="code code-wrap"><code>function censor({ boundingBox: face }) {
// draw the small face
faceCtx.drawImage(
// 5 source args
video, // where does the source come from?
face.x, // where do we start the source pull from?
face.y,
face.width,
face.height,
// 4 draw args
)
}</code></pre><p id="abf5c5d2-5cc6-4a76-b1c8-3eb2f16063ff" class="">Now the next four arguments are related to drawing it into the face canvas that we have. We have to ask &quot;where do we start drawing it at?&quot; The answer is <code>face.x</code> and <code>face.y</code>.</p><p id="76c8f6f7-46fa-4b04-8b89-5e5c9d0ada4b" class="">The next arguments are how wide and how high should I paint it to? You might think, okay we can just use <code>face.width</code> and <code>face.height</code>. However if you try that, you will see a really weird effect where your face is almost delayed.</p><p id="dd663ad8-8e74-407d-a68a-cadfa7d07f57" class="">What is actually happening there is that it&#x27;s just painting Wes&#x27; face to the square, and then everything you see outside of the square is the video element, and then everything inside the square is the canvas.</p><p id="eec4e790-9e60-41cd-8371-a056f0bdac1e" class="">There is a bit of a delay there.</p><p id="85c3e417-c6b3-4089-8946-a83c318b1d0d" class="">So the way it will work is we are going to take 10 pixels by 10 pixels and then peel it back up once we have done it. Instead of passing <code>face.width</code> and <code>face.height</code>, we will pass <code>10,10</code>.</p><pre id="aded66dc-65e2-4da1-8df7-7f3718724ec5" class="code code-wrap"><code>// 4 draw args
face.x, // where should we start drawing the x and y?
face.y,
10,
10</code></pre><p id="be2915c0-eb8e-4aa6-8759-1a1b006a3655" class="">You can see in the very top corner there is a tiny little Wes.</p><p id="2e0e1c03-1629-4351-b6a3-dd2ffac18691" class="">Make a variable <code>size</code> instead of hard coding the values 10,10, so we can quickly reference that whenever we need it.</p><p id="eb6493e5-4a79-427b-bea7-c04f82f2bd66" class="">Add the following towards the top of the file: <code>const SIZE = 10;</code>.</p><p id="bf828359-e915-4634-b076-36278e540959" class="">Why did we do it in all caps? it&#x27;s a common practice in the graphics canvas world, any variables that are constant throughout the application, they do them in all caps.</p><pre id="30ba49f7-e553-45b8-8849-0f7308577778" class="code code-wrap"><code>faceCtx.drawImage(
// 5 source args
video, // where does the source come from?
face.x, // where do we start the source pull from?
face.y,
face.width,
face.height,
// 4 draw args
face.x, // where should we start drawing the x and y?
face.y,
SIZE,
SIZE
);</code></pre><p id="c8de9fd8-586c-4cc4-af91-5e664f854cbd" class="">Now we need to draw the small image back on but scaled up. Remember -- the whole reason we draw it small was so we can pull it back out, stretch it back up, and then paint it overtop. Saving it small lets us get that pixelated look that we are going for here.</p><p id="dee36ba5-b970-41ed-a690-e51efdb14ce4" class="">To do that we will use <code>drawImage</code>.</p><p id="2cac5c6c-7108-4ffc-bc63-ba3fe4278f92" class="">The source is the <code>faceCanvas</code> itself, and we want to start from the top left corner so we pass <code>face.x</code> and <code>face.y</code>.</p><p id="0937a1f8-1ddf-43a5-8997-8f235a6437ef" class="">For how wide and how high we want to go, it&#x27;s no longer the width of the face, it&#x27;s the width of the tiny one, so we can pass <code>SIZE</code> for both width and height.</p><p id="8736cd0d-a58b-43f8-a731-690bf63f9926" class="">Next we have our drawing arguments.</p><p id="53ec2343-4a23-4477-9dd8-1ee9ae7df276" class="">Where should we start drawing the x and the y? <code>face.x</code> and <code>face.y</code>.</p><p id="d348d94e-1d2d-498c-90ab-72c714124594" class="">And then for how wide and high should we do it, we want <code>face.width</code> and <code>face.height</code>.</p><pre id="f6ad2439-7e29-467e-9e4e-d84e1c028b4a" class="code code-wrap"><code>// draw the small face back on, but scaled up
faceCtx.drawImage(
faceCanvas, // source
face.x, // where do we start the source pull from?
face.y,
SIZE,
SIZE,
//drawing args
face.x,
face.y,
face.width,
face.height
);</code></pre><p id="92f334b6-1125-4b21-bf3c-0a37060dd38e" class="">If you refresh the page, you might notice it&#x27;s not working.</p><p id="76cd8c38-cc60-4e53-8a4d-aecc76b78b51" class="">Wes spent 20 minutes debugging this to figure out why is it not painting his face once it is scaled up? Wes&#x27; debugging mindset went through and said it looks like it&#x27;s not actually drawing anything there because if you comment that entire small face <code>drawImage</code>, it works the exact same.</p><p id="f75032b5-6e79-4ffd-a0f2-8b54e406fb1a" class="">If you give it a separate <code>src</code>, like the <code>video</code> to pull from instead of <code>faceCanvas</code>, you will see it works.</p><pre id="de52086c-5e07-4ab0-b356-28611a547a68" class="code code-wrap"><code>// draw the small face back on, but scaled up
faceCtx.drawImage(
video, // source
face.x, // where do we start the source pull from?
face.y,
SIZE,
SIZE,
// drawing args
face.x,
face.y,
face.width,
face.height
);</code></pre><p id="91600dab-fdcb-4bc6-a1b9-7bf8e24c2e90" class="">So why is it not painting to the <code>faceCanvas</code>?</p><p id="76793f05-06b2-4179-8693-255ab5b36b5c" class="">Wes switched the source back and then went to the element and set <code>display:none</code> on the canvas element with class of <code>face</code>, and nothing changed.</p><p id="b8b5c95b-d3c0-42c5-bf8b-fe87f993ae8f" class="">So that&#x27;s when Wes thought maybe we are drawing to the wrong canvas. But then he thought we have two canvases. The first canvas is the regular canvas with <code>ctx</code>. The second canvas is the canvas with the <code>faceCtx</code>.</p><p id="ebad8bac-fe2a-4a87-9d08-d8c3fc1bbecd" class="">So what is wrong with the variables?!</p><p id="6968ee2e-cde1-4d8a-9148-60560c1db610" class="">It was right here...</p><pre id="ec17f68f-fca9-4042-aa9e-6372dcc7dd61" class="code code-wrap"><code>const faceCanvas = document.querySelector(&quot;.face&quot;);
const faceCtx = canvas.getContext(&quot;2d&quot;);</code></pre><p id="9837d33a-db7b-4123-bcfc-304ce2749059" class="">We grabbed the <code>faceCanvas</code> element correctly, but then we assigned <code>faceCtx</code> the wrong canvas! We used <code>canvas</code> instead of <code>faceCanvas</code>.</p><pre id="5740d929-fc0a-45c8-a67a-aa236fe2dc2b" class="code code-wrap"><code>const canvas = document.querySelector(&quot;.video&quot;);
const ctx = canvas.getContext(&quot;2d&quot;);
const faceCanvas = document.querySelector(&quot;.face&quot;);
const faceCtx = canvas.getContext(&quot;2d&quot;);</code></pre><p id="85e2ff43-7682-4b1e-b9cf-4dfa27484eb9" class="">Modify the code above as shown below 👇</p><pre id="cfc4e3dd-a4d0-4273-83bb-ad2b42419e50" class="code code-wrap"><code>const canvas = document.querySelector(&quot;.video&quot;);
const ctx = canvas.getContext(&quot;2d&quot;);
const faceCanvas = document.querySelector(&quot;.face&quot;);
const faceCtx = faceCanvas.getContext(&quot;2d&quot;);</code></pre><p id="77d3dd33-595b-440b-9e93-86481a820e63" class="">Now it is finally working! It is taking our faces and spreading it all over. There are few things we can do to fix some of that stuff.</p><p id="afb95947-cc1f-455a-8867-9d7a4e58bcde" class="">Go into the <code>censor</code> function. In the first line of the function add <code>faceCtx.imageSmoothingEnabled = false</code>.</p><p id="d957ff19-9c07-495f-b0ff-8feb858129c2" class="">If you don&#x27;t have that, the image is just kind of blurry so what the browser does is it says &quot;oh this is pixelated!, let me try to smooth it out&quot;. But if you turn that off, you get the real pixelated values.</p><p id="02b27aa9-2d0a-4991-828a-80103b8e49b9" class="">We also want to clear the canvas before we do any of this so add <code>faceCtx.clearRect(0, 0, faceCanvas.width, faceCanvas.height)</code>.</p><p id="0846aa85-4495-4fcd-9d72-e9a926b4dea0" class="">Now the canvas should clear when we move.</p><p id="6c88bda5-6878-4ade-8af6-e46f450ac4f9" class="">One other thing is it doesn&#x27;t do a great job at getting Wes&#x27; whole face. What Wes will do is go to the top of the file and create a scale variable like so <code>const SCALE = 1.5;</code></p><p id="34555639-72bb-4815-81b5-f2dec5296d29" class="">Go to our second draw and make a few variables that are scaled up.</p><p id="09459e6e-7355-4386-a64f-4d788f57fec4" class="">First we will make a width and height:</p><pre id="4a25cf03-40bb-45c4-8b34-7557d50f1adc" class="code code-wrap"><code>const width = face.width * SCALE;
const height = face.height * SCALE;</code></pre><p id="7f0eef1e-4d67-427a-bf0e-e86aa353d722" class="">Then we will go down to the <code>drawImage</code> function and replace the last two values with the <code>width</code> and <code>height</code> variables like so 👇</p><pre id="078aea99-9d98-4001-b30b-216211a07fb8" class="code code-wrap"><code>// draw the small face back on, but scaled up
const width = face.width * SCALE;
const height = face.height * SCALE;

faceCtx.drawImage(
faceCanvas, // source
face.x, // where do we start the source pull from?
face.y,
SIZE,
SIZE,
// drawing args
face.x,
face.y,
width,
height
);</code></pre><p id="33947957-9873-45fe-b2f9-9880296c9fa9" class="">That makes a bigger scaled up face. Now we need to move the canvas over a bit based on the scale. For that we need a bit of math.</p><p id="b77be81c-94e6-4dc7-9c9d-3e252ea334bf" class="">We will take our drawing args from <code>faceCtx.drawImage()</code> and do the following 👇</p><pre id="525995c0-b0a3-4d8a-ba5d-1409f1bad4d0" class="code code-wrap"><code>// Drawing args
face.x - (width - face.width) / 2,
face.y - (height - face.height) / 2,</code></pre><p id="5fb9e1fc-dcc0-450d-ba1e-a358937db93e" class="">Now you can play around with the size and scale variables. If you change the size to <code>const SIZE = 100;</code>, you will see something like</p><p id="a702c419-4540-4311-9f36-f60cd113a350" class="">You can feel free to stop the video here, but if you want to continue, we will create some sliders that will change these <code>SIZE</code> and <code>SCALE</code> values.</p><p id="22c8aad1-43c0-48fe-9a72-876e5e91e1f2" class="">Make an <code>options</code> variable that is an object with properties of <code>SIZE</code> and <code>SCALE</code> like so 👇</p><pre id="8500112b-6135-42bc-98e9-87dbad97b6b2" class="code code-wrap"><code>const options = {
  SIZE: 10,
  SCALE: 1.35
}</code></pre><p id="baad6ce6-4886-45cd-baa5-20b99914a7d2" class="">Then everywhere in the code we are calling those variables, modify the code so instead of passing just <code>SIZE</code> we pass <code>options.SIZE</code>.</p><pre id="0f9b160d-b6e0-41f8-b4e4-582b5e17828a" class="code code-wrap"><code>// draw the small face back on, but scaled up
const width = face.width * options.SCALE;
const height = face.height * options.SCALE;</code></pre><p id="ec377de0-81fe-4ec3-89fe-a0e035199387" class="">Go back to the <code>face.html</code> and make some controls.</p><p id="e7ad9df9-aab3-44ca-a5a7-8049f2c08a72" class="">Give ourselves an input of type &quot;range&quot;, with a minimum value of 0.3 and a max of 3 and the step will be 0.1. Then we need to add a label.</p><pre id="03240909-43fc-4f00-a70a-3875e4fa7ef1" class="code code-wrap"><code>&lt;div class=&quot;controls&quot;&gt;
&lt;label for=&quot;SCALE&quot;&gt;
    SCALE:
&lt;input type=&quot;range&quot; name=&quot;SCALE&quot; min=&quot;0.3&quot; max=&quot;3&quot; step=&quot;0.1&quot; /&gt;
&lt;/label&gt;
&lt;/div&gt;</code></pre><p id="628aef1b-66c1-4fb6-b792-669029f4cd4a" class="">Let&#x27;s make the defaults line up with what we set. Add <code>value=&quot;1.35&quot;</code> to the input range.</p><p id="a7b9c0f7-e88e-495e-b2a0-39051a11f3a6" class="">As you can see now the default value is set on the scale slider.</p><p id="b79bd65f-2df3-4f2e-81bf-22f8940b4372" class="">Duplicate that code and let&#x27;s do the same for size. Size will start at 10 and go from 1 all the way to 100, and the step will go up by 1.</p><pre id="5d7a3c54-27fb-4221-a14a-976628baca81" class="code code-wrap"><code>&lt;label for=&quot;SIZE&quot;&gt;
  SIZE:
&lt;input type=&quot;range&quot; name=&quot;SIZE&quot; min=&quot;1&quot; max=&quot;100&quot; step=&quot;1&quot; value=&quot;10&quot; /&gt;
&lt;/label&gt;</code></pre><p id="f2c37c71-d027-4b11-bf0d-3783bb8bc457" class="">Now we need to add some event listeners.</p><p id="e5676998-3028-45fc-9616-1223a483e576" class="">Select the inputs first by selecting every input within the <code>controls</code> class with a type of &quot;range&quot; 👇</p><pre id="7d0de55a-854b-4586-8d96-11ce174d54d6" class="code code-wrap"><code>const optionsInputs = document.querySelector(&#x27;.controls inputs[type=&quot;range&quot;]&#x27;);
console.log(optionsInputs);</code></pre><p id="2b2659f8-5ff8-40d1-97ed-e53fa5eebbea" class="">If you refresh the page and inspect the console, there is nothing! We did make a mistake, we should have used <code>querySelectorAll</code>. If you modify the code to that, you will see that it still doesn&#x27;t give us anything.</p><p id="9bcf7b5c-094f-4c32-a8f5-9535f162ca6d" class="">Oh we have a typo! It should be <code>.controls input[type=&quot;range&quot;]</code> not <code>inputs</code> plural. Modify the code accordingly.</p><p id="4face2c3-e957-47e6-b852-0f624a7823b3" class="">Make an event listener for each of those. Add the event listener on the <code>input</code> so it will run whenever the input changes and then call <code>handleOption</code>.</p><pre id="17eae235-74b0-44e2-892e-f935b43431a1" class="code code-wrap"><code>optionsInputs.forEach(input =&gt; input.addEventListener(&#x27;input&#x27;,  handleOption));</code></pre><p id="c3fd681b-f9b0-4772-89f7-da19d7dd53fd" class="">Above that, add the <code>handleOption</code> function.</p><pre id="c006396b-df56-4ac5-8aef-4afb09c30202" class="code code-wrap"><code>function handleOption(event) {
console.log(event.currentTarget.value);
}</code></pre><p id="dac278fd-b9b6-40a6-93a8-52c9104b7ea8" class="">Now when you move the slider, you should see the values changing in the console.</p><p id="62f32a12-939a-44d2-960b-51f7800c6442" class="">Next we need to pull out the value and name of the input. Log <code>event.currentTarget.name</code> as well.</p><p id="668e9e17-0cf4-426a-8667-01db57e416b1" class="">Destructure the <code>value</code> and <code>name</code> variables.</p><pre id="7d4cad50-9541-4e55-a42c-4277ae4fcac3" class="code code-wrap"><code>function handleOption(event) {
const { value, name } = event.currentTarget;
options[name] = value;
}</code></pre><p id="4f686edc-7f76-4753-a539-7849ffa53e46" class="">Inputs always come in as strings so tiy need to convert that back to numbers like so 👇</p><pre id="172f13f1-a7a3-4952-9063-ca53bbf9eb79" class="code code-wrap"><code>options[name] = parseFloat(value);</code></pre><p id="0575f168-89ae-4056-acad-7b314e6814ea" class="">Now you can play with the inputs and scale and resize up and down!</p><p id="8b694fb0-7b6e-495f-a279-d09e915a787c" class="">That was a long video, but hopefully it was fun for you.</p><p id="c693d0e4-2b2f-4dfd-9230-c314cc8fafda" class="">Find an issue with this post? Think you could clarify, update or add something?</p><p id="d7d47fc8-0c6c-426b-ba39-4f75bc25e70b" class="">All my posts are available to edit on Github. Any fix, little or small, is appreciated!</p><p id="7f779f1a-2cef-45b7-805a-7c24593e24d2" class="">Edit on Github</p><p id="3570f8cb-159b-4857-a7b2-0e12d57dc05d" class=""><a href="https://wesbos.com/javascript/09-gettin-loopy/54-looping-and-iterating-for-for-in-for-off-and-while-loops"><strong>← Prev</strong></a></p><p id="6aaa608a-e12e-4565-aa84-8ef3858cd231" class=""><a href="https://wesbos.com/javascript/09-gettin-loopy/54-looping-and-iterating-for-for-in-for-off-and-while-loops">Looping and Iterating - for, for in, for of, and while Loops</a></p><p id="03e049a3-49ab-40b9-90fe-c0904b37bf1b" class=""><a href="https://wesbos.com/javascript/10-harder-practice-exercises/56-sarcastic-text-generator"><strong>Next →</strong></a><a href="https://wesbos.com/javascript/10-harder-practice-exercises/56-sarcastic-text-generator">
</a><a href="https://wesbos.com/javascript/10-harder-practice-exercises/56-sarcastic-text-generator">Sarcastic Text Generator</a></p></details></li></ul><ul id="43e83962-6a4f-42a7-a109-976acc18452b" class="toggle"><li><details open=""><summary>56 - Sarcastic Text Generator</summary><p id="2b439bbc-ce1d-40ed-8d83-b959386f6dca" class=""><a href="https://wesbos.com/javascript/10-harder-practice-exercises/56-sarcastic-text-generator">https://wesbos.com/javascript/10-harder-practice-exercises/56-sarcastic-text-generator</a></p><p id="c84ae684-5c14-4cac-849a-8dc9e8bcc520" class="">
</p><figure id="f1207d39-5b83-43f7-8557-235d2f8c6caf" class="image"><a href="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/bjs%201.png"><img style="width:700px" src="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/bjs%201.png"/></a></figure><p id="575b4c4e-5eed-46f1-9675-e8641bf50c7b" class="">Enjoy these notes? Want to Slam Dunk JavaScript?</p><p id="b90be228-cb28-4254-8bbd-eb2c4bc73d7f" class="">These are notes based on my <a href="https://beginnerjavascript.com/">Beginner JavaScript</a> Video Course. It&#x27;s a fun, exercise heavy approach to learning Modern JavaScript from scratch.</p><p id="c9eccdef-03c5-4c2c-be90-6180e3396233" class="">Use the code <strong>BEGINNERJS</strong> for an extra $10 off.</p><p id="f862887c-a859-4f83-b2f8-ae35867a3db5" class=""><a href="https://beginnerjavascript.com/">BeginnerJavaScript.com</a></p><p id="2a06256e-dfbe-4690-a9a3-70eb03c79df9" class="">JavaScript, Sarcastic Text GeneratorEdit Post</p><p id="e9ac0da5-0153-4553-9def-edc78c5b10ca" class="">This is a quick and fun exercise. You can try this yourself to see how you would structure it.</p><p id="adb6548d-928e-4724-bd9b-bd8884e99448" class="">What we will be doing is building a sarcastic text generator where you can enter some text and then select one of 3 options:</p><ul id="25be1aeb-155c-4983-9aa3-c4f853e304a3" class="bulleted-list"><li style="list-style-type:disc">sarcastic,</li></ul><ul id="ad500198-d928-45cb-9b64-805b9d71162a" class="bulleted-list"><li style="list-style-type:disc">funky, or</li></ul><ul id="ddf46ee6-9803-466f-8d97-cf1f2e53d2c7" class="bulleted-list"><li style="list-style-type:disc">unable to structure a sentence</li></ul><p id="92d6bc83-7d22-4f02-9a83-d461c898bd5f" class="">Based on your selection, the text you entered will be modified to match the style option you selected.</p><p id="d1d41fc8-6463-470b-aa05-2c257fb7f759" class="">The sarcastic option gives us &quot;sponge bob case&quot; as it&#x27;s often called, which is depicted in the image below.</p><figure id="f8a436f7-27c2-44fa-b032-9ed92d86d332" class="image"><a href="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/783.png"><img style="width:700px" src="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/783.png"/></a></figure><figure id="a4f1a236-e325-429a-ba7c-325429273180" class="image"><a href="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/782.png"><img style="width:700px" src="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/782.png"/></a></figure><figure id="8f6514ea-d60b-4c1a-8e9c-66583ba3a728" class="image"><a href="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/784.png"><img style="width:700px" src="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/784.png"/></a></figure><p id="a767a633-583f-4073-af3e-8e24ee6a72e7" class=""><em>Note: the funky option gives us those weird characters but you should never use these characters in a real world situation because they are inaccessible to someone with a screen reader.</em></p><p id="d5042726-b2ef-48a6-9b26-74ab7dbfbbe0" class="">We will be working out of the <code>56 - Sarcastic Text</code> folder. Open up <code>index.html</code>.</p><p id="cd41909d-5d5c-472a-bba2-3e286f52ef9d" class="">The page already contains some base styles so we can center it on the page, then we have a div with a bunch of inputs.</p><pre id="5cb4fa45-269c-42d3-a2a0-bb1cd618d065" class="code code-wrap"><code>&lt;body&gt;

&lt;div class=&quot;typer&quot;&gt;
&lt;label for=&quot;sarcastic&quot;&gt;
&lt;input type=&quot;radio&quot; value=&quot;sarcastic&quot; id=&quot;sarcastic&quot; name=&quot;filter&quot; checked&gt;
      Sarcastic
&lt;/label&gt;
&lt;label for=&quot;funky&quot;&gt;
&lt;input type=&quot;radio&quot; value=&quot;funky&quot; id=&quot;funky&quot; name=&quot;filter&quot;&gt;
      Funky
&lt;/label&gt;
&lt;label for=&quot;unable&quot;&gt;
&lt;input type=&quot;radio&quot; value=&quot;unable&quot; id=&quot;unable&quot; name=&quot;filter&quot;&gt;
      Unable to Structure a Sentence
&lt;/label&gt;
&lt;textarea name=&quot;text&quot;&gt;so I was thinking about going to the store.&lt;/textarea&gt;
&lt;p class=&quot;result&quot;&gt;&lt;/p&gt;
&lt;/div&gt;

  &lt;script src=&quot;./text.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;</code></pre><p id="53ce4fd1-1186-42ab-a40e-d31eefc9b946" class="">The only thing we need to know about the inputs is they all have the same <code>name</code> attribute value. That allows us to only select one of the radio buttons at a time. We are going to be using their values (sarcastic, funky, or unable) to pull the specific filters.</p><p id="d4edd5f1-e7ce-4c98-a87d-7f0c864cb6a1" class="">First thing you want to to do is select a few things.</p><p id="2f84d90e-6a39-46a9-ae16-0a156d7b1a9d" class="">We need the text area that the person will input their text into, the paragraph where we display the result and then all the inputs.</p><p id="8e278c77-8808-41d2-90ba-b2251b4d8f7b" class="">Grab the text area. Use an attribute selector to specify the textarea in case in the future you add more than one to the page.</p><pre id="96305632-eca8-45bf-950b-d8dc1fb89476" class="code code-wrap"><code>const textarea = document.querySelector(&#x27;[name=&quot;text&quot;]&#x27;);</code></pre><p id="31ebeef5-f796-4582-bd11-3c342c05e143" class="">Then you need the result.</p><pre id="4375bf88-a4f4-4c14-a4c1-bdaa74435d08" class="code code-wrap"><code>const result = document.querySelector(&#x27;.result&#x27;);</code></pre><p id="1c4461b2-4d70-4f0e-b235-71af927b8e5d" class="">Then tiy need the inputs. Use <code>querySelectorAll</code> to select all the inputs with a name of &quot;filter&quot; on them.</p><pre id="d1ae4325-17bf-4045-9bb3-fea021bffeae" class="code code-wrap"><code>const filterInputs = document.querySelectorAll(&#x27;[name=&quot;filter&quot;]&#x27;);</code></pre><p id="c087b3bb-ca11-4130-ab36-65cd37e71e46" class="">Log them all the make sure they are working.</p><p id="3795970a-7095-43b3-8b5a-14772c1e7293" class="">Next we need a handler that will output the text.</p><p id="13533f8d-905b-4680-8b25-abf15cbf7f24" class="">Make a new function called <code>transformText</code>. It will take in some text and then output the result.</p><p id="3a0eea6b-f9ff-4d73-894c-8243593473ae" class="">Add an event listener on the input event and call <code>transformText</code> every time the event fires.</p><p id="03cb1814-6638-4b72-a283-44315ae9cf98" class="">To get the text out of the text area to pass to the function, use <code>e.target.value</code>.</p><pre id="ccaefe0a-24be-4a42-9836-4b3076b4ef60" class="code code-wrap"><code>function transformText(text) {
result.textContent = &#x27;Transformed Text&#x27;;
}

textarea.addEventListener(&#x27;input&#x27;, e =&gt; transformText(e.target.value));</code></pre><p id="b9468ab8-ed3f-4959-84a1-b9a0ec293821" class="">Check that it is working by simply logging the text within the <code>transformText</code> function. When you refresh the html page, open the console and type into the text area, you should see the text you are typing being logged.</p><p id="03ee50f6-8854-4ac5-9a53-d74afaa2abda" class="">Now we need to write some filters.</p><p id="bc5b7826-5cff-4c19-9e9b-224a2dba8fa5" class="">We have 3 filters, and we will start by writing the sarcastic filter.</p><p id="686afad7-7161-48d6-9039-9b4a4f0b4cac" class="">One thing Wes likes to do when we have a few related things like these filters is to stick them in an object instead of having them all as their own function.</p><p id="8e5ba387-d76c-48d8-b26b-949130f71341" class="">Name the object <code>filters</code> and each property will be the filter name like so 👇</p><pre id="830c86c5-7678-4192-be00-79cab23bf9f0" class="code code-wrap"><code>const filters = {
sarcastic: function() {

},
funky: function() {

},
unable: function() {

},
}</code></pre><p id="1a134ee3-8945-489c-958b-707ef9df0e96" class="">You will notice when you save the file that it refactors the object as shown below, which is just a shortcut. It&#x27;s not the same thing as an arrow function, it&#x27;s just a shorter way to write functions in objects.</p><pre id="1113fbec-9cc8-4848-a94c-f3b4be3cf220" class="code code-wrap"><code>const filters = {
sarcastic() {},
funky() {},
unable() {},
};</code></pre><p id="756c1044-d359-4d49-abe9-af2dafcd93da" class="">Now you need to take the text and loop over every letter, because for &quot;sarcastic text&quot;, every other letter is a different case.</p><pre id="d451ba49-a692-4346-a5fc-e049bc768f00" class="code code-wrap"><code>const transformText(text) {
// take the text, and loop over each letter
const mod = Array.from(text);
console.log(mod);
result.textContent = text;
}</code></pre><p id="041e0560-e41c-4275-9b94-35280e773f07" class="">Now every time you type in the textarea, you should get an array of every single letter that the person has in there.</p><p id="eff18f55-eced-4c64-a36a-08688043a488" class="">We want to loop over that array and uppercase and lowercase every other letter.</p><p id="8a3db088-cc53-4e53-b14d-b46082785b9e" class="">To do that, we will use <code>map</code> and pass it our <code>filters.sarcastic</code> function.</p><p id="c360aac7-0f08-4319-b9a3-94588159fd48" class="">Since this is just a map function, our sarcastic method on the filters can take in all the arguments that a regular map can do.</p><p id="539f5e83-41b7-42a4-b108-e63ad806868c" class="">Let&#x27;s use the parameters <code>letter</code> and<code> index</code> and log those to make sure it&#x27;s working correctly like so 👇</p><pre id="75585b5f-4675-4d78-9a4a-63b5a286554f" class="code code-wrap"><code>const filters = {
sarcastic(letter, index) {
console.log(letter, index);
return letter;
},
funky() {},
unable() {},
};

function transformText(text) {
// take the text, and loop over each letter
const mod = Array.from(text).map(filters.sarcastic);
console.log(mod);
result.textContent = text;
}

textarea.addEventListener(&quot;input&quot;, (e) =&gt; transformText(e.target.value));</code></pre><p id="c0e2b76a-02db-425e-b02f-fb9347395744" class="">Now when you type, as you can see, we are logging the letter and the index. What we can do is say if it&#x27;s an even number, lowercase it, and if it&#x27;s an odd number, uppercase it.</p><p id="dc109529-6a7c-42f9-84c7-129b51abdb5b" class="">How do you know if a number is even or odd?</p><h2 id="7bb6c39e-a87a-4a52-8e97-7e1863563f54" class="">The modulo operator</h2><p id="d239c0ed-fa43-499d-9364-cf87386eb06d" class="">There is a neat way of doing that with the <strong>modulo</strong> operator. Let&#x27;s do a little aside to go over how the modulo operator works.</p><p id="32755e81-5436-41e8-be13-2654b6ff2a28" class="">Let&#x27;s say Wes he has a pack of 10 smarties (which are a candy in Canada) and three kids.</p><p id="4d32ded2-89a8-44e7-a377-1654989cdc8f" class="">If you try to divide 10 by 3 you get <code>10 / 3 = 3.33333333335</code>. Well you can&#x27;t really split a smartie into thirds. You might think we can use <code>Math.floor(10/3)</code> which does return 3.</p><p id="8f294309-6322-43ad-8263-c77bac5842ce" class="">So each kid gets 3 smarties.</p><p id="f93e4784-85b7-4180-bced-f91ae5faa19c" class="">If we have a pack of 10, each kid gets 3, if we had a pack of 20, each kid will get six.</p><p id="b2122ed3-e42d-440e-8254-49bcf4ad93d9" class="">Now the question is, how many are leftover that Wes gets?</p><p id="5fc7e632-92df-48e2-87b5-5b0a7f78b407" class="">You could try to figure it out using math but it&#x27;s not the best way.  8:50</p><p id="4971e080-56d5-48b3-866b-3cf68f197b9a" class="">What you can do is you can use the modulo operator. Let&#x27;s say you have 10 smarties, and 2 kids. The modulo operator will tell us after they are evenly divided, how many are left.</p><pre id="88872784-99c8-4e94-b279-ac4829151ac6" class="code code-wrap"><code>10 % 3 = 1</code></pre><p id="8f93396a-ee2f-4520-a5ee-9ad6489130d1" class="">So if we have 10 smarties that we divide by 3, there will be <code>one</code> leftover. If we have 6 smarties, there will be 0 leftover.</p><p id="9a24834b-ca20-4ded-8b6a-1cc8dc24524e" class="">The modulo operator is great for knowing how much is left after you have evenly divided.</p><p id="4a622eb3-8d0f-4b03-af2d-becee1cfdb35" class="">We can use this operator to check if something is even or not.</p><p id="24931ae3-321c-441e-8fe6-21f9c79179bf" class=""><code>10 % 2</code> will be 0, because 10 is even. If you do <code>11 % 2</code> you will get 1 returned.</p><p id="1784ffdc-c2b6-454d-9aa1-adf6c2088f6a" class="">So anytime that 1 is returned with the modulo operator you know it&#x27;s odd and if 0 is returned, then it&#x27;s even.</p><p id="c6b4ab6e-4586-4afd-833c-bb90f0b4901d" class="">We can use this to upper/lowercase every other letter in our sarcastic filter.</p><pre id="97aa2249-b29b-410a-819a-7958339412b1" class="code code-wrap"><code>const filters = {
sarcastic(letter, index) {
// if it is od, it will return 1 which is truthy.
if (index % 2) {
return letter.toUpperCase();
}

// if it is even, it will return 0 and we will lowercase it.
return letter.toLowerCase();
},</code></pre><p id="7f0dab6e-0333-4b30-871e-909304d01f95" class="">If you refresh the page and start typing, you will see that every other letter is uppercase.</p><p id="bff0297c-0c62-49a1-ae39-e7d026da902a" class="">Set the result to be <code>mod.join(&#x27; &#x27;)</code>.</p><pre id="77f3ceeb-e704-40b0-a48f-3b400a036e71" class="code code-wrap"><code>function transformText(text) {
// take the text, and loop over each letter
const mod = Array.from(text).map(filters.sarcastic);
console.log(mod);
result.textContent = mod.join(&quot;&quot;);
}</code></pre><p id="587d1e73-8e5b-46a5-baa3-5019dd141e82" class="">Now if you type in the textarea and select the sarcastic filter, you should see something like this 👇</p><p id="8b36caa8-a29c-40b8-8c79-408a0cd2281d" class="">So that is our first filter, and we are just hard coding it in our <code>transformText</code> function right now. But it would be great if we can use it based on the radio selection that we have.</p><p id="0e6fe28d-8d8e-4531-9785-107edcae0132" class="">How could we do that?</p><p id="af3c0d08-0d07-4751-bc92-8606f688f613" class="">We can modify the first line of <code>transformText</code> to grab the filter by finding the input with name of filter that is also checked, and then grabbing it&#x27;s value.</p><pre id="d1e86f62-4863-469b-b662-6685431a357f" class="code code-wrap"><code>const filter = document.querySelector(&#x27;[name=&quot;filter&quot;]:checked&#x27;).value;
console.log(filter);</code></pre><p id="b217c697-5383-402e-82b1-c2fb38b7a458" class="">Now when we type in it, we get the selected filter type logged in the console.</p><p id="59172277-24fe-460c-a1f0-c5c5ce7d8414" class="">Another way we could have done the filter is because we already have the inputs, we could use the find method to find the input that is checked like so 👇</p><pre id="e83b54ce-e2c4-4e5d-b6fe-449bbf64e3f4" class="code code-wrap"><code>filterInputs.find(input =&gt; input.checked);</code></pre><p id="bab45609-186e-4105-bc80-e3a7c08bf0e6" class="">If you try that, you should notice an error in the console that says</p><blockquote id="827b89b3-f793-421e-94aa-115d81a118f6" class=""><p id="35a78e25-01be-4fc8-ae57-93f2072d5336" class="">filterInputs.find is not a function.</p></blockquote><p id="b1e0c770-2b35-464c-ba83-67ef976a655e" class="">That is because <code>filterInputs</code> is a NodeList, not an array. We could wrap it in <code>Array.from</code> and then call <code>find</code> like so 👇</p><pre id="5c5103a6-812c-416d-92b8-8341f8409919" class="code code-wrap"><code>Array.from(filterInputs).find(input =&gt; input.checked);</code></pre><p id="1e15be11-770b-4def-8d0c-c1e8378bc2ad" class="">This is actually a better approach because why rerun the query selector if we have already selected all of the inputs!</p><p id="b6eda731-1d02-4819-9ad9-7826dddfc518" class="">Change the code to use that instead.</p><pre id="bfb311d8-3b92-4672-99d0-a4e143ffe924" class="code code-wrap"><code>function transformText(text) {
const filter = Array.from(filterInputs).find((input) =&gt; input.checked).value;
}</code></pre><p id="5c275565-4443-46af-9412-9e484ca85fbd" class="">With the way the code is written now, we will be transforming our <code>filterInputs</code> into an array every time the person types. That is not ideal.</p><p id="8a33b954-60c3-47c5-b9fd-eed25d9a6b4f" class="">Let&#x27;s instead turn it into an array once on page load because it is unnecessary to have to keep doing that.</p><p id="cafeaca8-661c-4dcb-b544-e75f9e9a8559" class="">Modify the code like so 👇</p><pre id="483a13bd-6cc0-4462-97b2-d64b1c17a4d3" class="code code-wrap"><code>const filterInputs = Array.from(document.querySelectorAll(&#x27;[name=&quot;filter&quot;]&#x27;));</code></pre><p id="78baa533-50af-43ab-942f-eb41b9f37b19" class="">Let&#x27;s do some cleanup and get rid of the logs within the <code>transformText</code> function.</p><p id="46fa2804-301b-4b87-b0dd-2713c0976e4b" class="">Take the <code>filter</code> variable and use it as a property lookup instead of hard coding the value.</p><pre id="54bf32d5-ee94-4fa0-bc98-8d1a1161049b" class="code code-wrap"><code>const mod = Array.from(text).map(filters.sarcastic);</code></pre><p id="e1940ba2-1b9c-4b3a-b286-c0d133ccf123" class="">Replace the line of code above 👆 with the code below 👇</p><pre id="39f5af45-8e3c-4736-9435-852fc70cb8eb" class="code code-wrap"><code>const mod = Array.from(text).map(filters[filter]);</code></pre><p id="874f3774-f1fc-4941-86a8-aa217fea6b38" class="">Because filter is stored in a variable, we need to use square brackets to look up the property.</p><p id="c26fe85d-84f0-446e-975e-2c6352cf0099" class="">If you refresh the page, the sarcastic option should still work but nothing should happen when you select the other 2 options because we haven&#x27;t hooked them up yet.</p><p id="e0ea5358-89c3-4a56-8e38-d7115f4c5961" class="">Let&#x27;s do funky now. Add the parameter <code>letter</code> to the function, like so 👇</p><pre id="d0c55654-9fd1-41a5-9272-40419f1d90d6" class="code code-wrap"><code>funky(letter) {},
unable() {},
};</code></pre><p id="4c3800cc-b902-4765-9cd2-961c0e2c871a" class="">We need some sort of dictionary or lookup of funky letters. If you open the <code>text-DEMO</code> or <code>text-FINISHED</code> file, you will see an object of funky letters.</p><p id="b2e35470-8df0-4a2f-9c1b-78d9f26ec857" class="">Copy that variable along with the <code>/* eslint-disable */</code> and <code>/* eslint-enable */</code> comments into our text.js file.</p><p id="1301ef1d-2ff2-4b23-9d14-f66e0df68209" class="">Paste it towards the top of the file, after our <code>filterInputs</code> declaration.</p><p id="632d47f5-492b-4d37-9a9a-2a1b17318415" class="">This object is just a lookup of letters that match to funky letters.</p><p id="1bdafb60-c1eb-4fc3-8f54-830467586a74" class="">We kept the ESLint disable comments because otherwise when you save the JavaScript file, it formats the object so each property is on it&#x27;s own line, which makes it hard to work within the file because it becomes so long.</p><p id="7f4defc4-f59e-466f-8d25-daea2dd3b4c1" class="">Back to our funky function logic, we need to do the following:</p><ul id="2d84d029-2f77-4265-ab59-6ad046afb14f" class="bulleted-list"><li style="list-style-type:disc">Check if there is a funky letter for this case</li></ul><ul id="c7d9f641-7673-4cbe-8ff3-52b15870a25d" class="bulleted-list"><li style="list-style-type:disc">If there is no funky letter for this case, check if there is a lowercase version.</li></ul><ul id="f65d6457-4140-48aa-a369-e1b55be16095" class="bulleted-list"><li style="list-style-type:disc">If there is nothing, return the regular letter</li></ul><p id="42ffa099-c549-4647-8ea4-2f9a2a09a0f0" class="">You have the <code>letter</code> argument, which you can use to look up inside of <code>funkyLetters</code>. For example if someone types <code>T</code>, we know there is a t for us to use.</p><p id="ded3b6b8-3c0c-4300-bd83-9985210a87cf" class="">Add the following code 👇</p><pre id="4373246d-8ab1-4bde-8e62-7cbfaca4d515" class="code code-wrap"><code>let funkyLetter = funkyLetters[letter];</code></pre><p id="b8c5310d-456b-4005-950a-dc1a9d2f9d79" class="">What we are doing there is we are looking up the letter in our <code>funkyLetter</code> object and assigning the value to our <code>funkyLetter</code> variable.</p><p id="a720ff43-0944-4d88-86c1-f8dcdaa9d1da" class="">If there is a funkyLetter, we will return it. If there is not, we will return the original letter.</p><pre id="1c7cf651-18fd-48e3-852b-2e38d6823e4a" class="code code-wrap"><code>funky(letter) {
// first check if there is a funky letter for this case
const funkyLetter = funkyLetters[letter];
if (funkyLetter) return funkyLetter;
// if there is not, check if there is a lowercase version
// if there is nothing, return the regular letter
return letter;
},</code></pre><p id="b5aae44c-9cf3-496a-8b16-53ac2c292c91" class="">If you refresh the page and try typing something while selecting the funky radio button, you should see it start working.</p><p id="abe354b3-391c-4f0c-a691-753ecb08b3d6" class="">If no <code>funkyLetter</code> is returned, we want to check for the lowercase version of it because some letters have a funky version for both lower and uppercase, like <code>f</code>.</p><p id="8c05140e-7949-4149-8777-95da0551b165" class="">To do that, we will modify <code>funkyLetter</code> to be a <code>let</code> instead of a <code>const</code>, and then after the comment where we check if there is a lowercase version, we will try to grab the lowercase version by lowercasing the letter and looking it up in the <code>funkyLetters</code> object and then assigning the value to <code>funkyLetter</code>.</p><p id="e321c4da-2366-4274-8444-a9db56292383" class="">If a value is found, we will return it, otherwise we will just return the letter as is.</p><pre id="b46f1067-4ed1-4445-a7ec-00fa1cf8c974" class="code code-wrap"><code>funky(letter) {
// first check if there is a funky letter for this case
let funkyLetter = funkyLetters[letter];
if (funkyLetter) return funkyLetter;
// if there is not, check if there is a lowercase version
funkyLetter = funkyLetters[letter.toLowerCase()];
if (funkyLetter) return funkyLetter;
// if there is nothing, return the regular letter
return letter;
},</code></pre><p id="6ab9a34e-7968-4e20-a440-c84a6d2fb862" class="">The last one is <code>unable</code>. It will take in a letter, and what we will do is one-in-three spaces, we will use the dot dot dot.</p><p id="61daa5e2-39db-4d32-be70-a2076d09ee56" class="">So we need a random number between 0 and 2, such as 1, 2, or 3 or 0, 1, 2.</p><p id="8548bc44-8629-462a-9aff-b7a3d434e8db" class="">The way that we can do that is using <code>Math.random() * 3</code>. That returns a number with decimals so we need to wrap it in a <code>Math.floor()</code>.</p><p id="bb6848b8-ef08-481c-8ab6-f8c67998fce6" class="">Now we will get 0, 1, or 2 returned. Grab that random number within the <code>unable</code> function.</p><pre id="034509dd-222c-44fd-a359-ce67bf3807e6" class="code code-wrap"><code>const random = Math.floor(Math.random() * 3);</code></pre><p id="b728c95c-bc65-462a-9137-8e86e3d66aa5" class="">Next you are going to check whether the letter is equal to an empty space, and that the random is equal to 2 (so 1 in 3), then return <code>&quot;...&quot;</code>. Otherwise, we just return the letter.</p><pre id="5293d39c-32d0-487d-8200-9078c13edf18" class="code code-wrap"><code>unable(letter) {
const random = Math.floor(Math.random() * 3);

if (letter === &quot; &quot; &amp;&amp; random === 2) {
return &quot;....&quot;;
}

return letter;
},</code></pre><p id="fbd2daf0-e607-4d5d-b97f-0b0ed67bb6b2" class="">Now if you refresh the page, select the unable option and try typing into the textarea, there is a one in three chance that the space will be turned into a <code>...</code></p><p id="33cf62d3-57de-4336-8180-a3541ef47c86" class="">The last thing we want to do is when you click on the radio button options, it should trigger that filter and show you the result.</p><p id="18d5f764-4704-40d8-966e-76d277b77ecd" class="">To do this, take <code>filterInputs</code> and loop over each one of them.</p><p id="83c73fa3-a325-4faa-a099-6b4dc8afa3fd" class="">Add an event listener that listens for the input event, and then when there is an input event, we will call another function which calls <code>transformText</code> and passes the text from the textarea.</p><pre id="05f9a923-05ae-43ff-bc23-950004283e66" class="code code-wrap"><code>filterInputs.forEach((input) =&gt;
input.addEventListener(&quot;input&quot;, () =&gt; {
transformText(textarea.value);
})
);</code></pre><p id="f9b46f9b-f6ad-4056-be25-f2f307dd6446" class="">Now each of our filter inputs have an event listener that listens to the input event, and when that fires, it triggers the <code>transformText</code> event and passes the value of the text.</p><p id="b24b0487-1204-42a3-a7b3-d2a3b6f41c42" class="">If you refresh the page, you should be able to select the different radio buttons and the text formatting will change based on the filter you select.</p><p id="20273943-e721-455e-9b5a-c24e68a4b5f8" class="">The main thing Wes wanted to get across in this lesson is that you can store methods inside of an object, to keep them together, as well as look them up on that object with a variable that is populated from some external input.</p><p id="fcce63d0-6a28-4bff-875c-c8f25f83b473" class="">Find an issue with this post? Think you could clarify, update or add something?</p><p id="b7c3a376-6834-4f6b-9a78-876c776862a6" class="">All my posts are available to edit on Github. Any fix, little or small, is appreciated!</p><p id="e50f4d51-3946-49fa-ab99-be26c042c5fb" class="">Edit on Github</p></details></li></ul><ul id="3bbe958f-3152-4db6-9a0b-d84594227d8f" class="toggle"><li><details open=""><summary>57 - Shopping Form with Custom Events, Delegation and Localstorage</summary><p id="eceb0372-59ac-444d-9596-0266d3fbaa11" class=""><a href="https://wesbos.com/javascript/10-harder-practice-exercises/57-shopping-form-with-custom-events-delegation-and-localstorage">https://wesbos.com/javascript/10-harder-practice-exercises/57-shopping-form-with-custom-events-delegation-and-localstorage</a></p><p id="bf60d44d-1100-4c65-9acd-6c9edb7e3a02" class="">
</p><figure id="03e08666-b2a4-48ba-92de-0c33d541ccdb" class="image"><a href="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/bjs%202.png"><img style="width:700px" src="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/bjs%202.png"/></a></figure><p id="671bc21e-34ee-4061-80e2-97cfdec0c88d" class="">Enjoy these notes? Want to Slam Dunk JavaScript?</p><p id="9392a474-ef15-4359-9974-a032be02aad2" class="">These are notes based on my <a href="https://beginnerjavascript.com/">Beginner JavaScript</a> Video Course. It&#x27;s a fun, exercise heavy approach to learning Modern JavaScript from scratch.</p><p id="1cd47e09-326c-490d-a085-7b246748541e" class="">Use the code <strong>BEGINNERJS</strong> for an extra $10 off.</p><p id="28bc1267-5f04-4493-a50a-8d584c16880f" class=""><a href="https://beginnerjavascript.com/">BeginnerJavaScript.com</a></p><p id="301ef126-7e7e-4fd0-a459-75a0e787eb7e" class="">JavaScript, Shopping Form, Custom EventsEdit Post</p><p id="f910db03-61be-4102-842b-7272bae899f0" class="">In this lesson we will build a shopping list, where you can add items, check them off, and delete them.</p><figure id="23c6d36a-0766-4e83-8804-c004b7ff2516" class="image"><a href="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/806.png"><img style="width:700px" src="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/806.png"/></a></figure><p id="d2cd7771-065c-4b14-9bce-54b2d984130c" class="">Although you may have written something like this before, Wes has baked a lot of things that we need to learn about JavaScript into this simple example.</p><p id="a6903734-2095-46a7-9e2a-7d811a18c24b" class="">We will be learning about emitting <strong>custom events</strong>, such as the one highlighted in the image below (if you don&#x27;t know what a custom event is, don&#x27;t worry, we will be learning about it).</p><figure id="80dc17bf-1572-4d71-86fb-c14570d8eba1" class="image"><a href="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/807.png"><img style="width:700px" src="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/807.png"/></a></figure><p id="fc56ac2a-482b-4a5c-963d-ea3631f4b6ea" class="">We will also be learning about <strong>event delegation</strong>, how do you listen for clicks on things that happen in the future, as well as <strong>DOM events</strong>, and <strong>localstorage</strong>.</p><p id="585ef35b-d94a-418f-928e-fbcd099821d2" class="">If you open up the <code>index.html</code> file in the <code>exercises/57 - Shopping List</code> directory, let&#x27;s go over the code that we are starting with.</p><p id="691d3661-0a15-48db-ab57-219c1dee601f" class="">We have a div with a class of <code>shopping-list</code> which contains a form element and an empty <code>ul</code>. Within that ul, we will be outputting the shopping list items.</p><p id="19469fde-66aa-46f8-80c0-b48b58421f69" class="">The form has input and submit buttons.</p><pre id="e65ec525-80e6-428a-9589-8bdf5de0f8fc" class="code code-wrap"><code>&lt;body&gt;
&lt;div class=&quot;shopping-list&quot;&gt;
&lt;form class=&quot;shopping&quot;&gt;
&lt;input type=&quot;text&quot; name=&quot;item&quot; id=&quot;item&quot;&gt;
&lt;button type=&quot;submit&quot;&gt;+ Add Item&lt;/button&gt;
&lt;/form&gt;

&lt;ul class=&quot;list&quot;&gt;&lt;/ul&gt;
&lt;/div&gt;

  &lt;script src=&quot;./shopping.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;</code></pre><p id="26abbbba-54d2-4810-b210-0bb6097d2e3f" class="">With this exercise, you can right-click and open the file in the browser and everything should still work. However if you do want the live reloading, and instant CSS changes, we can use Parcel, which will give us a server, live reloading and module bundling (which we have yet to learn about).</p><p id="41779923-5c42-42e0-897e-2e87f0bb212f" class="">There are 2 ways to install Parcel on your machine. You can:</p><ol type="1" id="1548ce02-3a79-4273-990d-5ae3082b9dba" class="numbered-list" start="1"><li>install it once, to each project, which is what we did in the last exercise, or</li></ol><ol type="1" id="64e2123c-ea85-4fef-97b3-6dd4713e36b6" class="numbered-list" start="2"><li>install it globally on your machine so that anytime you need it you can get a little server up and running.</li></ol><p id="4f0f4584-40f0-4a74-9026-d1f22f9b9c56" class="">To install Parcel globally on your machine, open the terminal and type <code>npm install -g parcel-bundler</code>. That will globally install Parcel for you, so that anytime you are in a terminal, Parcel will be available to you.</p><figure id="812ef911-99be-4566-ab09-7cd39943ce34" class="image"><a href="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/810.png"><img style="width:700px" src="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/810.png"/></a></figure><p id="8537286d-c590-4eca-bc00-1ac312973f47" class="">If you are on a Mac and you have trouble installing global modules on your command line, type <code>sudo</code> in front of the command like so <code>sudo npm install -g parcel-bundler</code>. That will ask you for a password first.</p><p id="deaf5e5b-f42b-4ab2-945d-b126f5bd21b6" class="">To check if it worked, you can type <code>parcel --version</code> into the terminal and it will tell you what version you have.</p><p id="9d1490eb-d9a3-4233-ab9a-1d38f4f62ea2" class="">Now in the terminal, cd into the Shopping List directory and then type <code>parcel index.html</code> in the terminal and hit enter.</p><p id="7bbdc22d-9ccc-4a9a-b319-06a605b9f57d" class="">There will be a message in the terminal telling on which server it is running (usually localhost:1234).</p><figure id="986560b2-680e-4103-a43e-9411c8d15d8d" class="image"><a href="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/812.png"><img style="width:700px" src="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/812.png"/></a></figure><p id="39bb6e97-24c3-458f-9895-73647e46b096" class="">Let&#x27;s get started. Open the <code>shopping.js</code> file, which should contain nothing.</p><p id="31f3d572-6d9a-401c-bfbc-50a51700366c" class="">There are a couple of things that need to happen. We need to:</p><ul id="7dd3212f-b0e4-464b-8b85-5fa645d2d1fa" class="bulleted-list"><li style="list-style-type:disc">listen for when someone types into the input and hits the submit button</li></ul><ul id="b1884ce1-8db1-4dea-9dd9-2d9bcc912a9c" class="bulleted-list"><li style="list-style-type:disc">keep track of all of the shopping list items and whether or not they are complete</li></ul><ul id="97c6bd1a-6220-4a2b-acd1-e6dfc2bf769c" class="bulleted-list"><li style="list-style-type:disc">render out a list of all of the shopping items</li></ul><p id="0cfd634c-25cc-4a8d-9f3f-4eca60c82a9a" class=""><em>Note: you may notice when you focus into the input to enter a shopping list, all these values of everything you have ever typed show up, like in the picture below. To fix that, you can go to the HTML, you can set autocomplete to false on either the input or the whole form. There is also an </em><code><em>autocapitialize</em></code><em> attribute which you can switch on or off.</em></p><figure id="176284a3-3385-4857-9802-ea6795f30d01" class="image"><a href="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/813.png"><img style="width:700px" src="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/813.png"/></a></figure><pre id="a67bb93d-8454-4e04-97f1-8183e72a22ea" class="code code-wrap"><code>&lt;form class=&quot;shopping&quot; autocomplete=&quot;off&quot;&gt;</code></pre><p id="1c9617ac-85d9-4c50-876e-b76ba252cc53" class="">Back to our JavaScript, let&#x27;s start by grabbing the shopping form and the list elements.</p><pre id="24d9a944-ee32-4b04-a7b2-da1526b95ff1" class="code code-wrap"><code>const shoppingForm = document.querySelector(&quot;.shopping&quot;);
const list = document.querySelector(&quot;.list&quot;);</code></pre><p id="32255053-ff1b-4719-9164-79980cc19fc1" class="">Next we need an array to hold our <strong>state</strong>.</p><pre id="248c5816-1114-4b59-8c92-01e82fe20771" class="code code-wrap"><code>//We need an array to hold our state
const items = [];</code></pre><p id="5b00824e-b9de-4d71-91d0-99cba1a91b7d" class="">What does <strong>state</strong> mean?</p><p id="58dec30b-e721-488e-ba7e-47f121a32e7c" class="">The definition changes from framework to framework, but generally what people are saying is that state is a bunch of data that reflects the state of your application.</p><p id="1b39d350-5cb1-4cfa-9630-bfd112e60680" class="">But what does that mean? Let&#x27;s use this finished shopping list screenshot below as an example.</p><figure id="27b44c31-9d26-4300-9178-d9b8b9e4b2fe" class="image"><a href="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/814.png"><img style="width:700px" src="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/814.png"/></a></figure><p id="a3f29bd6-49bd-4598-8c19-c9a2532ba410" class="">In this example, state is going to contain a list of all of your items, a list of those item ids, and whether they have been completed.</p><p id="41edd02d-bc3c-4968-83eb-5f05a70d7d52" class="">If it was a shopping cart, state would be a list of all the items in the card, how many of each item was in the shopping cart, how expensive is each item, etc.</p><p id="4d27958a-4488-4829-a755-13214d313113" class="">You should always be able to recreate the visual part of your application given just the data.</p><p id="8ed894d1-42ae-4fd2-8cc0-8b7152aa4be0" class="">All of the current state of your application, meaning how it currently is, should always be reflected in some sort of object or array of data and that is what we refer to as <strong>state</strong>.</p><p id="afdddc88-ca0a-4dcc-bdc4-ce22d398d8de" class="">Next we need to listen for a submit event on the form.</p><p id="ace36830-c4c3-4477-af15-b9d612eb8445" class="">If you refresh the page and try to type an item in the input and hit submit, you will notice that the form submits, it puts <code>?item=Egg</code> in the URL bar.</p><p id="976963b6-63e4-4530-95ae-085a985741ae" class="">However that is not what we want.</p><p id="a138df21-f46a-45e6-b46e-ea2757dd4b26" class="">Let&#x27;s make a submit handler for that.</p><p id="6200ac6d-3841-4d60-ac84-5df848de5290" class="">The first thing the handler needs to do is prevent the form from submitting so add <code>e.preventDefault()</code>.</p><pre id="803bcdc6-663b-4bb2-b329-a4ca578b5c63" class="code code-wrap"><code>function handleSubmit(e) {
e.preventDefault();
}</code></pre><p id="4e6440dd-aef8-4132-b055-57662fcd11ca" class="">Grab the <code>shoppingForm</code>, add an event listener on the submit event and pass it the <code>handleSubmit</code> callback.</p><p id="e48d8d6f-31d0-4ff6-a962-6b290037089d" class="">Remember, for forms, we don&#x27;t use click or enter events because it&#x27;s much easier to just listen to the submit event. That way, if you submit by clicking, you submit by hitting enter, something else triggers a submit of the form, all of those use cases are covered by a single event called <code>submit</code>.</p><pre id="1feda9a6-4cf9-4006-bf0d-3201836da8dd" class="code code-wrap"><code>shoppingForm.addEventListener(&#x27;submit&#x27;, handleSubmit);</code></pre><p id="aab8631a-b646-4de1-aa91-2722c7e52cea" class="">If you refresh the page, type in eggs and hit enter, nothing should happen, which is good.</p><p id="f2fa5756-98be-4081-9382-787504a23409" class="">Log &quot;submitted&quot; in the <code>handleSubmit</code> function.</p><p id="41493d72-0b4c-4d76-97e8-f6e9291cba5d" class="">Next we need to pull the data out of the input. How can we get that?</p><p id="eca92e56-7d25-4a0b-bc56-3c0049049b39" class="">Within the <code>handleSubmit</code> function, add the following code after we log &quot;submitted&quot;.</p><pre id="e9ae5a5e-2469-459b-be1e-8131a7a2fd38" class="code code-wrap"><code>function handleSubmit(e) {
e.preventDefault();
console.log(&quot;Submitted!!!!&quot;);
const name = e.currentTarget.value;
console.log(name);
}</code></pre><p id="f80a3fa2-ebc6-43f6-99a5-1bbd0ac4fe8a" class="">If you refresh the page now, type in eggs and hit enter, you should get something like below in the console.</p><figure id="4e6aa672-53b2-470b-aedb-42c13e03a62c" class="image"><a href="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/817.png"><img style="width:700px" src="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/817.png"/></a></figure><p id="9e33cf17-b210-4c14-86d7-4a09a7595f17" class="">Why are we getting <code>undefined</code>?</p><p id="a677be87-14d7-47e9-8c57-42d773e47259" class="">Let&#x27;s do a bit of debugging.</p><p id="96ebfc69-f3db-4478-b92d-07b25cd6a9a5" class="">Log of <code>e.currentTarget</code> in our handler, and then refresh the page. You should see the form element logged.</p><p id="f4dd48d8-4cca-445f-92ea-5af632d0b91f" class="">The reason we are getting <code>undefined</code> is because the <code>currentTarget</code> is the form, not the input and we want to get the text out of the input. There are a couple ways we could do this.</p><p id="d38747bf-699a-42c5-97a3-efc1542bff4a" class="">We could write another query selector to grab it. However, because the input has a name, it&#x27;s actually accessible via the form dot the name of the input.</p><pre id="8701a78b-7f3f-44bc-9f38-0381f2ff1643" class="code code-wrap"><code>&lt;input type=&quot;text&quot; name=&quot;item&quot; id=&quot;item&gt;</code></pre><figure id="6ac4700f-a845-4646-b182-b2a14151de15" class="image"><a href="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/819.png"><img style="width:700px" src="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/819.png"/></a></figure><p id="85484809-630b-4bbb-8943-734a827f76d1" class="">Take the form and store it as a global variable, called <code>temp1</code>, then add <code>console.dir(temp1)</code> to get every property inside of it.</p><figure id="fa74df5a-eaab-47da-a672-410a4a742762" class="image"><a href="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/820.png"><img style="width:700px" src="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/820.png"/></a></figure><p id="8361f077-5c10-4876-a359-43f207b1072c" class="">Somewhere inside of all those properties is <code>item</code>.</p><p id="0b94fb17-85b8-4d45-a10c-07b9e52dedca" class="">Wes is having trouble finding it but we will demonstrate it with code.</p><p id="74c76a15-e6ff-4318-8144-2dd5906f4f2e" class="">Modify the log of <code>console.log(e.currentTarget)</code> to <code>console.log(e.currentTarget.item)</code>.</p><p id="6331ff22-f0ee-47b6-964f-c1503ddb2c29" class="">As you can see, we now get the item, not the entire form itself.</p><p id="ae406a00-00d7-491b-9a68-c5b7937d6164" class="">Modify the name declaration to <code>e.currentTarget.item.value</code> like so 👇</p><pre id="9ad12197-8099-4c8c-a6b5-6c362e399100" class="code code-wrap"><code>function handleSubmit(e) {
e.preventDefault();
console.log(&quot;Submitted!!!!&quot;);
const name = e.currentTarget.item.value;
console.log(name);
}</code></pre><p id="4bc8346f-cda6-4420-a82b-798443dc7079" class="">As you can see, now we can capture the value of eggs.</p><figure id="4f14a39e-0c29-4008-a328-042c75be35ae" class="image"><a href="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/822.png"><img style="width:344px" src="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/822.png"/></a></figure><p id="0a4e6ef9-998d-46d6-a15c-adabd9aa8a88" class="">Next step is to store the data about the shopping item in the <code>items</code> array, but we cannot just store the straight up string, because we need to be able to store a bit more info about that item.</p><p id="c343d398-620c-49c0-b9ce-d72b6cb77316" class="">The other two things we need to know are:</p><ul id="26c936fd-4e64-4250-9900-cd53ebf38bb1" class="bulleted-list"><li style="list-style-type:disc">is it completed (have you bought it or not?)</li></ul><ul id="91d10657-03ff-4d0e-9467-c027dd6e3597" class="bulleted-list"><li style="list-style-type:disc">what is the ID of the item?</li></ul><p id="196e535a-c184-459d-9ec1-b98484514e84" class="">Any time you have a list of items, it&#x27;s best to give every single one a unique identifier, so you can easily find it from within the list.</p><p id="b7a201ac-4e77-4298-a234-a791b0da0ab3" class="">That is what we are going to do now.</p><p id="775639da-3caf-4a40-bdbe-dad8491f19e1" class="">The name of the item is going to be our name variable.</p><p id="bbf6c6dc-6ded-4495-b7e2-639f93e46874" class="">The id of the item just needs to be something unique. One trick that Wes likes to use is to use <code>Date.now()</code> as an ID, which works if you aren&#x27;t creating more than one item per millisecond, which works for our case.</p><p id="e269feb1-8a93-47cf-a1e2-36af7222712e" class="">The third property will be <code>complete</code> which we will set to false when the item is added to the list.</p><pre id="9ef6f8cb-a688-40fc-9901-e548aee0cf14" class="code code-wrap"><code>function handleSubmit(e) {
e.preventDefault();
console.log(&quot;Submitted!!!!&quot;);
const name = e.currentTarget.item.value;
const item = {
    name: name,
    id: Date.now(),
    complete: false
}
}</code></pre><p id="8750cc92-b9e2-4503-bf6f-6e22972482be" class=""><em>Note: when you save the code above, it might refactor it due to prettier to look more like what you see below, which is fine.</em></p><pre id="2b3e1301-5c89-4802-8145-0da9c6ff86ab" class="code code-wrap"><code>const item = {
name,
  id: Date.now(),
  complete: false,
};</code></pre><p id="13ddce61-496a-41be-b508-4d846e1c9c48" class="">Next we need to push these items to our state, which we will do by adding the following code to the <code>handleSubmit</code> function.</p><pre id="9f5cb926-d871-43fe-bf97-f4710846c5f7" class="code code-wrap"><code>items.push(item);
console.log(`There are now ${items.length} in your state`);</code></pre><p id="3a05f0da-3cbd-43a9-b42e-86c7aa220ac1" class="">If you refresh the page and try adding a few items, you should see the count in our log increasing.</p><p id="d5783f01-cd6d-4595-9925-03ed7a17ca1c" class="">Next we need to clear the form. There are a few ways we can do this.</p><p id="de51a781-0c5c-4c44-8fc9-8c329b644391" class="">One way is to set the item&#x27;s value to nothing like so 👇</p><pre id="daebee8e-6fbd-457a-9208-e7ec06a2ec99" class="code code-wrap"><code>event.currentTarget.item.value = &#x27;&#x27;;</code></pre><p id="afccf761-7385-4dc3-aac6-9c31ab35e851" class="">Another way you can do it, and this works if there are multiple inputs, is to call <code>e.target.reset()</code>.</p><p id="ae5c642d-4355-4a62-ac76-adae9c3ddf4d" class="">That will clear all of the inputs in a particular form.</p><p id="7f70a7f8-4212-4741-9476-c011c2a1efa6" class="">Notice that we used <code>e.target</code> not <code>e.currentTarget</code>. If we used <code>e.currentTarget</code> it would still work the same in this scenario.</p><pre id="fabcde45-eb92-4daa-9cea-a72346372a7d" class="code code-wrap"><code>function handleSubmit(e) {
e.preventDefault();
console.log(&quot;Submitted!!!!&quot;);
const name = e.currentTarget.item.value;
const item = {
name,
    id: Date.now(),
    complete: false,
};
// push the items into our state
items.push(item);
console.log(`There are now ${items.length} in your state`);
// clear the form
e.target.reset();
}</code></pre><p id="3782c309-c5c6-45cd-8795-87e44e4d3d3f" class="">When we have a form event, it will only actually ever fire on the form, it doesn&#x27;t bubble like our clicks and hovers do.</p><p id="1cb4b136-f7a9-4d96-8b18-f30023c27a9b" class="">In this case, there is no upside or downside to using <code>target</code> vs <code>currentTarget</code> to reset the form using the <code>.reset()</code> method.</p><p id="48c8c17e-ecaf-477c-9511-25c776d21550" class="">So far we have written code to enter an item and push that item up to state.</p><p id="19890c43-4340-4a00-8331-b7d47af93ec8" class="">Next, we need to display the items that are in our state. Create a function called <code>displayItems</code> which will loop over each item in the array and return a list item for each.</p><p id="e18c3742-74bc-4142-be93-8e5ec202e797" class="">What is the best method to loop over an array and return some HTML for each one? Map!</p><p id="c1ede5b8-89bf-4afc-8b04-62f3cfff7091" class="">Why?</p><p id="a1152b47-de76-4543-8556-0a082ae7a5dd" class="">Let&#x27;s go over a little demonstration in the console. Let&#x27;s say you have an array of names like <code>const names = [&#x27;wes&#x27;,&#x27;kait&#x27;];</code>.</p><p id="8276d444-651c-45b4-85aa-e9666fa68029" class="">You can call <code>map</code> on the <code>names</code> array which will go over each of them and then you can just wrap each one in a list item tag as a string using interpolation and then you can call <code>.join(&#x27;&#x27;)</code> on the returned array to join all the list item strings like in the image below.</p><p id="0dfe3267-d9be-4098-bf76-e17f0692971b" class="">That is what we will be doing with the <code>items</code> array.</p><pre id="4c81edc6-f3e5-4036-8d28-2b9a74f3821e" class="code code-wrap"><code>function displayItems() {
console.log(items);
const html = items.map((item) =&gt; `&lt;li&gt;${item.name}&lt;/li&gt;`);
console.log(html);
}</code></pre><p id="3dd90cca-f8f1-49be-8e47-918b31b4ba73" class="">Now how do we run <code>displayItems</code>? You might be thinking that we need to display them after we submit, right?</p><p id="cb3001e9-b618-488f-854f-abf63583d3a0" class="">We could just add <code>displayItems()</code> right after the <code>e.target.reset()</code> call within the <code>handleSubmit</code> function. That is okay for now, but Wes will show us a better way to do it, and why, with custom events. For now, just add it to our <code>handleSubmit()</code> function.</p><p id="cbc58a8a-cbe7-4108-90ce-5501a0362440" class="">Refresh the page and test that out by adding a few items: egg, milk and then beer, and you should see something like what is displayed below in the console.</p><p id="5f4d669c-33eb-4c70-a24e-c53ab4d0a8f5" class="">We pushed the item into state, and then once that is finished <code>displayItems</code> run and that loops over each item and returns a list item with each of them.</p><figure id="e19fa441-108e-40be-8af5-ab236bbdf590" class="image"><a href="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/826.png"><img style="width:700px" src="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/826.png"/></a></figure><p id="31b655b0-f955-451b-85f8-296ff452d404" class="">A couple of problems there...</p><p id="02ad2dd2-9c9b-4453-bf25-ee2e87f98af7" class="">First, the list items returned to us are in an array, not in an HTML string.</p><p id="13eab640-98f8-4a60-b106-f4b19a5142a4" class="">To fix that, add a <code>.join(&#x27;&#x27;);</code> on the <code>html</code> variable declaration like so:</p><pre id="5f65eaa0-76ed-48cb-b7b1-f894d5920ce2" class="code code-wrap"><code>const html = items.map(item=&gt;`&lt;li&gt;${item.name}&lt;/li&gt;`).join(&#x27;&#x27;);
console.log(html);</code></pre><p id="56bb3e00-8891-4519-b778-117b816ac69d" class="">Now as you can see, we are returned one string.</p><figure id="dd6faa58-039f-4056-9a23-95fc51cfdd7a" class="image"><a href="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/827.png"><img style="width:700px" src="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/827.png"/></a></figure><p id="be79f2cd-da04-4b4c-938c-2e0db48ec8fa" class="">Take the list and set the innerHTML of it, within the <code>displayItems</code> function.</p><pre id="b1fd24b6-d543-420c-8483-e496a54c3f22" class="code code-wrap"><code>function displayItems() {
console.log(items);
const html = items.map((item) =&gt; `&lt;li&gt;${item.name}&lt;/li&gt;`);
list.innerHTML = html;
}</code></pre><p id="5575680a-589e-435c-bf15-ce85ff6fe23c" class="">Now when you type in an item and enter submit, you will see it displayed.</p><p id="33396b31-8a70-475e-a92e-a62d4448ce10" class="">We need to add a bit more to our HTML like a delete button and a complete checkbox. Let&#x27;s scaffold the HTML out a bit more for each item.</p><p id="fe535a4c-e231-4e6e-b5b2-4b6d56e2d23b" class="">Add a class of <code>shopping-item</code> to each list item.</p><p id="db94f8ef-3e4e-47fb-8702-75c402c9fe79" class="">We also need to add a checkbox as well as a button with <code>&amp;times;</code> which should give us an x.</p><pre id="0a210dd7-7197-4993-ba5e-d459ed52cf2d" class="code code-wrap"><code>function displayItems() {
console.log(items);

const html = items
.map(
(item) =&gt; `&lt;li class=&quot;shopping-item&quot;&gt;
      &lt;input type=&quot;checkbox&quot;&gt;
      &lt;span class=&quot;itemName&quot;&gt;${item.name}&lt;/span&gt;
      &lt;button&gt;&amp;times;&lt;/button&gt;
      &lt;/li&gt;`
)
.join(&quot;&quot;);

list.innerHTML = html;
}</code></pre><p id="c35c5902-8090-4c9d-bd66-c2d1aa3437e7" class="">If you refresh the page and try entering items, you should see something like the following 👇</p><p id="b6dae499-a972-4aa5-9556-a44f9e1d9295" class="">We need to fix a few things here.</p><p id="ec3f9c61-352d-474a-afef-ad6ca176004e" class="">The button that we added is currently not accessible to people who are using screen readers. If the screen reader were to read to the user what is currently on the page, it would read the item&#x27;s name and then the multiplication sign, which makes no sense.</p><p id="79bbf248-acd6-4023-8236-24e349ae1e93" class="">What we can do to fix that is to add an <code>aria-label</code> attribute to it.</p><p id="f13f79ed-2d74-4bca-8faa-4aad3ce28930" class="">For sighted users, nothing changes, but for people using a screen reader, when they tab over to it, it will tell them &quot;remove bananas&quot; instead.</p><pre id="9a40451c-2683-4385-886c-9868708b0815" class="code code-wrap"><code>&lt;button aria-label=&quot;Remove ${item.name}&quot;&gt;&amp;times;&lt;/button&gt;</code></pre><p id="fffa25c5-a729-4b5a-989e-13147d810d9e" class="">Another thing we need to do is when you check one of the items, we need to add the item to our state and update the checked property.</p><p id="3b90fd91-defa-42cf-a358-ed8b88998049" class="">First, let&#x27;s fix the problem happening now where if you don&#x27;t type anything into the input and hit enter, you will see we are able to submit a lot of blanks.</p><p id="006a1b5c-0a3d-4647-9efb-f57d04e5e878" class="">One way to fix that would be to add the required attribute to the input, as shown below.</p><pre id="2b0f2e7e-7671-4480-9b45-a1da2e3a64c0" class="code code-wrap"><code>&lt;input type=&quot;text&quot; name=&quot;item&quot; id=&quot;item&quot; required&gt;</code></pre><p id="a9ad83c3-fba1-495c-8f70-528dfb7caf53" class="">That is an example of <strong>client-side validation</strong>.</p><p id="f07e6575-2a8d-4542-9731-12de82e52669" class="">Another thing we can do is say if there is no name, return within our <code>handleSubmit</code> function like so 👇</p><pre id="f4f3a72f-7445-4efc-8e93-7c72b28e0be4" class="code code-wrap"><code>function handleSubmit(e) {
e.preventDefault();
console.log(&quot;Submitted!!!!&quot;);
const name = e.currentTarget.item.value;

// if it&#x27;s empty, then don&#x27;t submit it.
if (!name) return;

const item = {
name,
    id: Date.now(),
    complete: false,
};
}</code></pre><p id="d903f2d5-1f44-4935-9b61-24a4834a016c" class="">Now if you try to submit a blank input, you will see that no item is added because we just return from the function.</p><p id="8da7fcb0-c2f1-426f-94b9-11686a8fe336" class="">If you try entering any of the following: <code>0, null, undefined, false</code> in the input, it will still get added to the list instead of being returned, even though they are falsy.</p><p id="a10423fd-a3c8-4b11-83cb-6d1ad1da38f9" class="">Why is that? Because they are all strings, and not types.</p><p id="94121692-a389-4d16-8b28-b28ca8f76e02" class="">Let&#x27;s go back to how we are calling <code>displayItems</code> each time the <code>handleSubmit</code> function is called. The reason Wes doesn&#x27;t love that approach is because it tightly couples the <code>handleSubmit</code> with the displaying of the items.</p><p id="36ac2e3d-ddea-4d5d-acc4-52a0cb119b1e" class="">What will happen is that we will also need to display the items when they are restored from localstorage (when we refresh the page, we want the items to still be there) so we would need to call it again.</p><p id="cf7113ee-6174-443f-8bde-462a595ba9c0" class="">We also need to display the items when we mark them as complete.</p><p id="dfe4f4b1-cebe-47dd-9850-275e39d3f6f7" class="">When we delete an item we will need to re-run <code>displayItems</code> because there is now one less item. And we call <code>displayItems</code> from a couple of other spots.</p><p id="73e9482f-99ad-4f0d-bb42-77aba388ee14" class="">Having those functions so tightly coupled now isn&#x27;t a big deal but what happens in larger JS applications is you may need to do more things after you display the items, and then sometimes you won&#x27;t want to run all those other things after displaying the items. So what people end up doing is copy and pasting the function and modifying it slightly which causes duplicated logic.</p><p id="71a5ff36-028e-4949-abd2-e7b9a24f63f9" class="">Instead, what we are going to do is use the event system in JavaScript to fire off our own events, and then listen for them.</p><p id="cfc67340-4df8-48c0-b950-b932f248b65a" class="">We are going to listen to an item updating event, and then anyone who cares about that event can listen for it, just like if it were a click or a hover.</p><p id="c53622bc-9a8e-4082-b76f-efd7d7ebd979" class="">That allows us to decouple it, and you will see this pattern a lot in JavaScript applications.</p><p id="9befadf3-341f-4814-9004-cf1d6ff957f9" class="">Let&#x27;s do that right now.</p><p id="dab4f9fe-6cc4-42b6-a495-0ebbdb95c24c" class="">Instead of displaying our items, we will fire off a custom event which will tell anyone who cares that our items have been updated.</p><p id="dc8f9a75-c611-41a7-85ae-632f85674300" class="">We will be using the term <strong>dispatch</strong> which means an event happens.</p><p id="7610b45d-126d-4261-8609-d6ee31295892" class="">When you click on something, the browser dispatches a click event.</p><p id="21c218f3-2e1d-4e53-8a1e-7887f6c3c375" class="">We need something to fire off an event about that data and we need to attach it.</p><p id="e17059d8-6892-4a74-88cd-e962a1e6d462" class="">If we look at our HTML, we will probably fire off the event from this list. You could also fire it off from the form or the body, it doesn&#x27;t matter that much.</p><p id="5c4b7302-c71b-4520-aa28-2ab208872407" class="">At the bottom of the <code>handleSubmit</code> function, run <code>list.dispatchEvent()</code>. The <code>dispatchEvent</code> method lives on all DOM elements. You provide it a <code>CustomEvent</code>, which is a constructor in the browser.</p><p id="3a2e6dc1-974c-461c-b947-1fa917a9db1b" class="">As you can see, it&#x27;s just a function.</p><pre id="239ebee1-1204-4a8b-bd1b-909470c6cc2f" class="code code-wrap"><code>new CustomEvent(&#x27;PIZZAS HERE&#x27;)</code></pre><p id="72e4d591-a185-4b14-a45d-a15a6888b1af" class="">If you were to run it by passing the name of your event, as shown above, you should see something like the image below in the console.</p><p id="0e390be7-1bfb-4cb5-bf2a-15e1a202c75b" class="">It gives us the type of events, as well as any details about when it is fired.</p><p id="e7ece845-d312-4cdd-87d4-8a8c02362f59" class="">So when we want to dispatch a custom event, we must first create a new <code>CustomEvent</code>, by passing the constructor the name of the event.</p><pre id="93d0760f-a8d8-46bb-8acc-9670b567b2e9" class="code code-wrap"><code>list.dispatchEvent(new CustomEvent(&#x27;itemsUpdated&#x27;));</code></pre><p id="e15052b7-4b1f-4898-bcf7-5e2b7b534512" class="">If you try to add an item now, nothing happens, it just dispatched that event. No one is listening for <code>itemsUpdated</code> so no one cares, but if we go down to the bottom of the JavaScript file, where we have added our event listeners, we can listen for that event like so...</p><pre id="5059809c-9d1f-4ddb-86ef-fbe0a3a84633" class="code code-wrap"><code>list.addEventListener(&#x27;itemsUpdated&#x27;, displayItems);</code></pre><p id="1d70d7df-3a2b-4dda-954c-317f6b3052b2" class="">Now when you add an item, you will see it in the list. That is because we are dispatching the <code>itemsUpdated</code> event and also listening to it, and then calling <code>displayItems</code> when it fires.</p><p id="aaeb4ac4-314d-4e60-9f77-87e9d5723593" class="">You can add as many event listeners to the same event as you want.</p><p id="fde8097b-d503-426f-95ed-e5f612ef866d" class="">If we were to add the following code and refresh the page and add an item, we can see the details of the event.</p><pre id="3aea8082-1f94-4ab5-a2c8-cd04901c4458" class="code code-wrap"><code>list.addEventListener(&#x27;itemsUpdated&#x27;, (e) =&gt; {
console.log(e);
});</code></pre><figure id="baccb5d7-6991-47e2-86ff-231f7d0a653e" class="image"><a href="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/834.png"><img style="width:700px" src="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/834.png"/></a></figure><p id="064d80fe-d98c-481d-866b-a424f61b29f4" class="">You can see all sorts of details such as the path, which is pretty neat because it shows you the path at which the events have bubbled through. It was first triggered on the <code>ul</code>, then bubbled up to the shopping list, then the <code>body</code>, <code>html</code>, <code>document</code> and then the <code>window</code>.</p><p id="a2557f80-379e-4ea4-abc7-bedba7ad095d" class="">That is a <strong>custom</strong> event, which Wes uses often when working with vanilla JavaScript to keep concerns separate, instead of tightly tying them together.</p><p id="b318858a-8399-4992-92ac-1de6bb5644d9" class="">Remove the second event listener where we are just logging the event.</p><h2 id="0903ef20-4a6c-4a9a-8067-a72d118079e8" class="">LocalStorage</h2><p id="2a41707e-1b2b-4e79-99d6-7542f1087ade" class="">Next, we want to mirror the data to <strong>localstorage</strong>.</p><p id="0924a6f1-eda3-41a9-912a-e6bc6d313d52" class="">Localstorage is kind of like a mini database that lives in your browser. It allows users who are using your website to come back with the same browser and pickup from where they last left. It does not send data to a server. It&#x27;s just the ability to save some data in the user&#x27;s browser.</p><p id="88d9bb2f-d8cf-4e4b-ba37-a5a503ba39d8" class="">If you go to the &quot;Application&quot; tab of the chrome developer tools and look at localstorage, and then click on the domain name, you won&#x27;t see anything. However Wes has already completed it so he has values there. There is all this information in his localstorage about the items.</p><p id="d1bdd2bf-631c-4907-a579-3ebd2d5e2c05" class="">So what we want to do now is create a function that will mirror our data to localstorage.</p><pre id="7dfb48fc-a02c-4fc4-86d3-df9f050c7836" class="code code-wrap"><code>function mirrorToLocalStorage() {
console.info(&#x27;Saving items to localstorage&#x27;);
}</code></pre><p id="cb8a6eaa-35ee-4adf-88cf-24b7d74224f0" class="">When we add something, we need to listen for the event, and then mirror all the items to localstorage. Let&#x27;s duplicate our event listener and call <code>mirrorToLocalStorage</code> when the <code>itemUpdated</code> event is triggered. Add the following code where we call the rest of our event listeners..</p><pre id="9f9b1894-dc6d-406e-923f-f29d8be1c00b" class="code code-wrap"><code>list.addEventListener(&quot;itemsUpdated&quot;, mirrorToLocalStorage);</code></pre><p id="d32513e8-6e9a-4c1f-b425-3e5eec2639e9" class="">See how nice having a custom event is?</p><p id="fba1cb65-967f-4d91-90ee-960e2db7edf3" class="">Anyone who cares about items updating can listen in on the event.</p><p id="729a3700-bdb5-4aa8-a499-e7e16164f01e" class="">If you try typing in an item, you should see logged in the console &quot;Saving items to localstorage&quot;.</p><p id="d05b35fc-fa18-4d17-8b19-c2669efca537" class="">How do you save items to localstorage?</p><p id="27103a98-56d3-4393-b913-2df00e78bede" class="">The API is pretty simple.</p><p id="a8154a98-0474-4a36-bc99-ae8e79a23be3" class="">If you type in <code>localStorage</code> in the console, it will return to you everything that is in localstorage.</p><p id="f84be467-d0da-4f44-9089-422a1e181c5c" class="">To set an item in localstorage, you can use <code>localStorage.setItem()</code> where you pass in the key and the value.</p><p id="270f97fa-2fac-4a1c-8e33-62e5acf9c7dd" class="">To get an item from localstorage, you can use <code>localStorage.getItem()</code> to which you pass the key that you are looking for.</p><p id="a41b478d-ba45-4302-a1ae-7e36f40be6fe" class="">If something funky is happening with localstorage, it&#x27;s best to just clear it out and start fresh which you can do by clicking this button in the Applications tab.</p><p id="7a85eab0-bff7-4a8c-89ec-18aa51cb91b9" class="">So how are we going to save items to localstorage?</p><p id="36b4a9b6-c23a-47bd-aa45-6fa4e7a947fc" class="">What if we do something like the following 👇</p><pre id="7ec454b0-23b2-4ff8-81a9-a01129648641" class="code code-wrap"><code>function mirrorToLocalStorage() {
localStorage.setItem(items, items);
console.info(&quot;Saving items to localstorage&quot;);
}</code></pre><p id="56231bfa-0acb-4f37-884a-2f6cca8fa7bb" class="">If you take a look, you will see <code>[object Object]</code>.. what is that? If you try to open it up, you can&#x27;t, it&#x27;s just the word object.</p><p id="6e1ec9b9-8686-4aa2-9bcb-c7c819453be2" class="">Why is that? That is because localstorage is text only. That means if you have an object or an array or a boolean, it will try to convert that item to text first before it puts it in.</p><p id="f6cf0710-73d8-4040-9bf9-880fb9938d53" class="">Every single type has a <code>.toString()</code> method, which will convert it to a string.</p><p id="7acf1a48-df6b-4927-8f77-7c7a27aff7a1" class="">If you have an object, and you call <code>.toString()</code> on it, it just gives you <code>&quot;[object Object]&quot;</code>, which is not helpful at all.</p><p id="a51a235e-b8c8-456e-9e06-17b510a93d32" class="">That is what is happening here, because we are passing it an object, it is trying to convert it to a string which isn&#x27;t very helpful because there is no data for that.</p><p id="0e95b02d-c3ed-45d9-831c-922ca813a8a7" class="">So how do you convert objects to strings? Using JSON.</p><p id="98df77cc-ee02-4bf1-b2d5-e1ee90f5c703" class="">If you call <code>JSON.stringify()</code>, you can pass it an object, and it will convert that object to a string representation of that object.</p><p id="a845749b-a903-430a-a306-bc9d757667c6" class="">At a later point in time, we can do the opposite which is <code>JSON.parse()</code>. If you pass it a string, it will convert it back to an object.</p><p id="b4672c96-3a17-4375-ae68-594dc7789944" class="">That is exactly what we will do here. Before we put the object into localstorage, we will convert it to a string and when we pull it out of localstorage, we can convert it back to an array of objects.</p><p id="1a36e6cb-54be-4a2f-a51f-0f68b63e7228" class="">Modify the code as shown below.</p><pre id="e1824fc3-dc6c-4baf-a8a9-acfc8a8807e2" class="code code-wrap"><code>function mirrorToLocalStorage() {
localStorage.setItem(items, JSON.stringify(items));
console.info(&quot;Saving items to localstorage&quot;);
}</code></pre><p id="674fb60b-ae8a-4fa3-a11f-35864a0eb2d2" class="">If you try to add some items now, you will see those changes reflected in localstorage.</p><p id="2acf3d68-b45a-4a38-8e84-e7a45ff352b7" class="">In order to mirror everything to localstorage, we need another function that restores from localstorage when you load the page.</p><pre id="38048450-34c4-456b-8c1b-a99757e8d9d9" class="code code-wrap"><code>function restoreFromLocalStorage() {
console.log(&#x27;Restoring from localstorage&#x27;);
}</code></pre><p id="a63b26a5-6570-448a-aa28-fb785069a1a5" class="">We will run that on page load so you can add the call <code>restoreFromLocalStorage()</code> to the end of the JavaScript file.</p><p id="0b7f1dd4-ddf6-4afa-a99d-3f9575d3d7f5" class="">If you refresh the page, you should see the message in the console.</p><p id="6763c509-accc-4728-9391-f0d4548a235e" class="">Now we need to pull the items from localstorage.</p><p id="836ec92d-b207-4a13-96eb-d93207574d3c" class="">To do that, call <code>localStorage.getItem()</code> which will bring us back a large string of text. Convert it back into an object by wrapping the <code>getItem</code> method around <code>JSON.parse()</code> which will convert the text back into an array of objects 👇</p><pre id="4a55774b-c541-481e-84c6-3933529cab64" class="code code-wrap"><code>function restoreFromLocalStorage() {
console.info(&quot;restoring from LS&quot;);
const lsItems = JSON.parse(localStorage.getItem(&quot;items&quot;));
}</code></pre><p id="95d2d8c5-6e5e-4c53-914a-fdfe0e2df20d" class="">Next we want to check if there are any items in the <code>lsItems</code> array, because it could be that this is the first time the user is loading the application, and there isn&#x27;t even an empty array yet.</p><p id="6fa48f05-0c38-4294-9a9f-33f082ee0e5f" class="">If there is something in localstorage, we will assign the value to the <code>items</code> variable and then dispatch the <code>itemsUpdated</code> event.</p><pre id="3a427593-db06-428d-a5f3-dd0cf47b31b2" class="code code-wrap"><code>if (lsItems.length) {
items = lsItems;
list.dispatchEvent(new CustomEvent(&#x27;itemsUpdated&#x27;));
}</code></pre><p id="f0c32a0d-a10e-494b-9754-ed8b784c2453" class="">However if you refresh that you will see an error in the console that &quot;items&quot; is read-only.</p><p id="25623de1-e151-4d0d-abf4-179d42a369b5" class="">Why? Because it&#x27;s a const variable.</p><p id="662a6e21-452e-4d33-8e3a-4cc7486db4d6" class="">We can fix that a few ways. We can change the variable from a <code>const</code> to a <code>let</code>, or push all the items into the items array like so 👇</p><pre id="19aee39f-efd4-4ae5-822d-55046b78dfad" class="code code-wrap"><code>lsItems.forEach(item=&gt; items.push(item));</code></pre><p id="6c71e626-977d-4fdc-a353-5aad57c1749d" class="">We could also use a combination of push and the spread operator as shown below.</p><pre id="a40cd2eb-1ece-4bef-8fc2-50501d03cb87" class="code code-wrap"><code>items.push(...lsItems);</code></pre><p id="adc0f8bb-3645-4984-8885-538d1242f489" class="">Why does that work?</p><p id="20e342c7-04bd-44e9-8196-17bbe75debad" class="">That works because push takes unlimited arguments. We could have called <code>items.push(lsItems[0], lsItems[1])</code> and that would have worked fine, but using the spread operator it takes each item in the array and spreads it into the method as an argument.</p><p id="d4060522-fe98-40e4-8b01-bc8af62ee47c" class="">Two more things we need to do. We need to handle:</p><ol type="1" id="6642ce3c-b43f-4ae7-82b5-3f8bfa61abe5" class="numbered-list" start="1"><li>the clicking of the checkboxes. As it stands right now, you can check the item but when you refresh the page, it will no longer be checked. It is not being mirrored to the state</li></ol><ol type="1" id="41684f24-3fcb-4ae6-a5c8-6fbbde06f043" class="numbered-list" start="2"><li>The deleting of items</li></ol><p id="0d2fd88f-fa56-4b4f-89f0-dcbb9cf78bf0" class="">Let&#x27;s start with deletion.</p><p id="88ded7fb-a3f0-42c2-bd80-a4de12317e51" class="">You might think we could select the buttons on the page, loop over them and listen for a click, and when that happens, remove it from our array. That is kind of right, but let&#x27;s show you why that doesn&#x27;t exist.</p><p id="45a1fee7-8150-408b-ba97-0c6c6ddc908d" class="">Add the code below to the very bottom of the JavaScript file/</p><pre id="9cbecae5-e7e6-4baa-b8cd-ea0565b5c546" class="code code-wrap"><code>const buttons = list.querySelectorAll(&#x27;button&#x27;);
console.log(buttons);</code></pre><p id="0cb9c8db-2f4c-4f5f-a86f-6ecf74982d90" class="">You should get 5.</p><p id="cd80bd70-2b00-4f5a-b103-0d3861497670" class="">However, if you move that code further up, above the event listener declarations, we get none.</p><p id="c47a70bd-5145-42ea-a9b4-2d88d5f6a08e" class="">Why is that?</p><p id="4fecce0f-56a0-4a1c-9843-8fc434c43147" class="">Because when we run the code from a bit further up in the file, none of the rest of the code below it has been executed and thus all those event listeners have not yet been created. So that means we have not yet created any of the items.</p><p id="15cb52ed-81cd-486e-8f61-ab0d8bd90db0" class="">If you throw a <code>debugger;</code> after <code>console.log(buttons);</code> and refresh the page, you will see that when the debugger hits, there are no items yet.</p><p id="466ce4d6-5712-4762-997f-2d956f6a28b0" class="">That happen a bit later. So you may think it&#x27;s safe to leave that code at the very bottom of the page. Let&#x27;s try that.</p><p id="1ee8400a-e519-460c-8af8-67a965f2bda0" class="">Create a function <code>deleteItem</code> which takes in an <code>id</code> and for now simply logs that it is deleting an item.</p><pre id="05fb64c0-429c-404a-9eed-d74c33f47093" class="code code-wrap"><code>function deleteItem(id) {
console.log(&quot;DELETING ITEM!&quot;);
}</code></pre><p id="c8313c3d-19cb-4fb5-bcdf-f54236849840" class="">If you try pressing all the delete buttons, you will see that it works.</p><p id="fabb5c66-2323-4429-b5d7-a9ea768be6e2" class="">However, if we were to add a new item, if you click on the x, it doesn&#x27;t say deleting item.</p><p id="929f01b1-24ff-4ee3-a5c2-2cbb687f0355" class="">If you try to click any of the delete buttons that worked before we added the item, you will notice that it no longer works.</p><p id="1120aeb9-b775-4f60-873c-a8afcbe61648" class="">Why?? There are 2 things going on.</p><p id="100b8557-ef6a-4f7f-b24f-fddbf87e236b" class="">If you try to listen for clicks on things that do not exist on the page, it will not attach an event listener to that element. That is why the code behaved so differently when we moved it above the event listeners.</p><p id="7ff342f4-9f60-42b6-ac86-89da2957a009" class="">The second problem is that when we add a new item, it re-renders the entire list.</p><p id="a6e9519a-5892-4c33-965f-37c3a0e91e69" class="">If you have the console open while you add an item, you will notice that for a second the <code>ul</code> disappears and is added back, because it is re-rendering.</p><p id="9acac531-1b88-4c1b-954a-979a1a6be318" class="">That is because we have re-run the <code>displayItems</code> function, and it&#x27;s actually creating a brand new list item each time.</p><p id="59c58ec9-c29a-4c9b-809f-516c392d30e6" class="">When you remove an item from the DOM, and replace it with a new item, all of those event listeners are lost.</p><p id="412b20c3-8bf2-4d62-b598-ce65726ce516" class="">We would have to manually add them back, which is a pain.</p><p id="da321f6c-091c-4445-9f49-d6b98362c44b" class="">So what do we do?</p><h2 id="ff9d34de-659c-42e1-87f4-5eb9cc815540" class="">Event Delegation</h2><p id="00c960ff-014b-4c7d-8d79-8f2fbcdca573" class="">We can use a concept called <strong>event delegation</strong>.</p><p id="ce84f709-32fe-484b-a2bf-a9e00f8ff95e" class="">What that means is instead of listening for clicks on things that might not exist yet, or things that will come in the future, what we do is listen for clicks on things that we do know will be there, and then we check if the things that they actually clicked on is a lower item.</p><p id="a0948a4e-d929-4f34-b230-7505e01ac536" class="">Let&#x27;s demonstrate this.</p><p id="892a425a-b0b5-48f3-915f-484500b7eda7" class="">Get rid of the button log and query selector, but keep the <code>deleteItem</code> function.</p><p id="d2b6760c-23d8-4dd9-b424-0fb22954cd2b" class="">Let&#x27;s listen for a click on the list, and then in the event handler log both <code>e.target</code> and <code>e.currentTarget</code>.</p><pre id="9989fee1-62e2-4f75-b22d-f3bba7263afa" class="code code-wrap"><code>list.addEventListeners(&#x27;click&#x27;, function(e) {
console.log(e.target, e.currentTarget);
});</code></pre><p id="5be93125-8d12-49de-b94e-f59265c2799d" class="">If you refresh the page and then click anywhere on it, you will see that it thinks we are click on the span, even though we listened on the list.</p><p id="617f88e6-c030-4e6e-8cdb-5cbc1b68f934" class="">Now if you click on the x next to an item, we listened on the list but we actually clicked on the button.</p><p id="717aec8a-3038-4ad2-9bb8-c89a546eec56" class=""><code>currentTarget</code> is the thing that you listened on and the <code>target</code> is the thing that you actually clicked on.</p><p id="8ac08271-0185-4874-9046-2c8d4b16d9ef" class="">Now we need to check if what was clicked matches the button, using <code>e.target.matches(&#x27;button&#x27;)</code>. That will check if an element matches a CSS selector, which in this case is <code>button</code>, then we will delete the item by passing the delete method the id of that item.</p><pre id="8348b421-211e-4117-90b2-0eeb88dda91e" class="code code-wrap"><code>// event delegation: We listened for the click on the list &lt;ul&gt; but then delegate the click over to the button if that is what was clicked.
list.addEventListeners(&#x27;click&#x27;, function(e) {
if (e.target.matches(&#x27;button&#x27;)) {
deleteItem();
}
});</code></pre><p id="f03774dd-9072-48dd-b4ca-a7e7fc324880" class="">Now, when you click on any X next to an item, you should see &quot;DELETING ITEM&quot;.</p><p id="56ffe9a7-ef58-43ba-af15-6d0d40da74c9" class="">If we add a new item and then click on it&#x27;s X button, we should still see &quot;DELETING ITEM&quot;, because we are simply just listening on the <code>ul</code> and delegating the event to the delete button.</p><p id="5caf1bfa-b24c-4edb-a37e-1d2559abe135" class="">One more thing we should mention is that whenever we add an item to the list, we re-render the entire list. We are basically deleting the existing list and adding a brand new one. This happens so quick you can&#x27;t even see it happening but on large applications, that can slow down how your application works.</p><p id="89476107-8a3c-4a82-b5cf-f4782b04be33" class="">That is where frameworks like Angular, React, Vue come in handy. They know how to instead of re-rendering the entire list, only update a specific piece of it.</p><p id="107c774f-8d9c-4b45-9a64-2d1d9681926c" class="">Just changing part of the DOM rather than wiping it out leads to better performing applications. That is hard to do in just Vanilla JS. For our purposes, the way we are doing it is fine.</p><p id="66e72aad-8d89-4509-af3b-14bcc3f34474" class="">Next, when someone clicks on the x, we need to figure out which item id is it related to. Give the button a value of the item&#x27;s id upon creation, as shown below 👇</p><pre id="6acc98d8-2632-4ce1-baa1-dcb140d3cae7" class="code code-wrap"><code>function displayItems() {
console.log(items);

const html = items
.map(
(item) =&gt; `&lt;li class=&quot;shopping-item&quot;&gt;
        &lt;input type=&quot;checkbox&quot;&gt;
        &lt;span class=&quot;itemName&quot;&gt;${item.name}&lt;/span&gt;
        &lt;button
          aria-label=&quot;Remove ${item.name}&quot;
          value=&quot;${item.id}&quot;
        &gt;&amp;times;&lt;/button&gt;
      &lt;/li&gt;`
)
.join(&quot;&quot;);

list.innerHTML = html;
}</code></pre><p id="7a8c747f-9729-48de-889d-83967a633682" class="">Now when you look at the HTML, you should see the id is in the button.</p><p id="b6968ecb-6b17-4c75-bf6c-f8a391038e9f" class="">Pass that value to the <code>deleteItem</code> function.</p><p id="7c93567b-c397-4c42-a356-2008051868d6" class="">Modify the code like below.</p><pre id="db06afa6-95ce-4c2d-84a3-a05f2b88cdcb" class="code code-wrap"><code>list.addEventListener(&quot;click&quot;, function(e) {
if (e.target.matches(&quot;button&quot;)) {
deleteItem(e.target.value);
}
});</code></pre><p id="081ab0ea-33be-49fd-8adc-3d45540aae69" class="">Add a log for the id in the <code>deleteItem</code> function.</p><p id="299e40f4-1a63-4a10-ab55-7bd38632dfa7" class="">That works now, because when you click on the button, you take the value of the button and pass it as an argument to <code>deleteItem</code>, which then logs that argument.</p><p id="d45b76aa-c881-4e65-9580-66c4ae580afb" class="">How can we update our <code>items</code> array to remove that one item?</p><p id="1513fae4-a1cb-48ba-b404-99c79479e0ba" class="">It&#x27;s actually pretty simple. Filter for every item that is not the one with the ID.</p><pre id="cf2e8dbf-66d9-42ba-a393-9939d66e4f4a" class="code code-wrap"><code>const newItems = items.filter(item =&gt; item.id === id);</code></pre><p id="f8bc3aba-2549-4c66-9fa5-ccc203a9362f" class="">That is the opposite, but we will flip it in a second.</p><p id="108d7b25-5f42-49e5-9a07-890597f2d608" class="">Now if you press the delete button next to an item, we get nothing.</p><p id="81e69bab-4518-4466-b46a-98e16b7f7315" class="">If we change the code from <code>===</code> to <code>==</code> will it work?</p><p id="4306ba9d-36d2-48ba-9efa-e8b71a77906b" class="">Let&#x27;s try that. Modify the code like below.</p><pre id="378fb242-30d4-4892-bb76-29ea0548e5f7" class="code code-wrap"><code>const newItems = items.filter(item =&gt; item.id == id);</code></pre><p id="51f26b56-2d1a-4310-b50c-f0bff95ce36b" class="">Why does it work with double equals?</p><p id="6227ea68-c7df-45fd-b9ab-5bac2dda873d" class="">That is because the <code>id</code> is being stored as a number, but when you pull it out, it is returned as a string.</p><pre id="f75a5a0f-9d80-4945-917f-b0ec2b8446af" class="code code-wrap"><code>deleteItem(parseInt(e.target.value));</code></pre><p id="ed2b80c1-7ae2-41a5-a40f-b19d1bbdb4b5" class="">When you pass the value to the <code>deleteItem</code> function, you can wrap it in <code>parseInt</code> as shown above, which will convert it to a number for us.</p><p id="441a5dae-1e40-4da8-89ed-a3cd18d811ad" class="">Now you can add back the triple equals.</p><p id="8bed9c8a-fb0a-4881-96c0-aca891209ba9" class="">Now when you click the button, you will get the item that needs to be removed.</p><pre id="514cd3da-2d50-4c51-84ef-95b562b4cd0c" class="code code-wrap"><code>const newItems = items.filter(item =&gt; item.id !== id);</code></pre><p id="39be6a28-3dd9-493f-ae6f-89b0bb4486ce" class="">We actually want the opposite so modify the line of code as shown above 👆.</p><p id="3cf148c8-d3a9-401f-95bb-ed1a1f821a20" class="">If you were to click the delete button for an item now, and you had 12 items, you would only get 11 returned.</p><p id="d679400e-6d94-4a33-a750-94edb850f10e" class="">We need to get the new items into our items array. How can we do that?</p><p id="3c0f73cf-8d7a-4118-a041-af2e17390124" class="">In our case, we just want to overwrite the entire list. To do that, change the declaration of the <code>items</code> array from a <code>const</code> to a <code>let</code>.</p><p id="13da846e-1417-4c84-acfe-cfec941022e3" class="">In <code>deleteItem</code>, modify the code so instead of assigning the filter to a variable <code>newItems</code>, you will assign it to <code>items</code> instead so it overwrites whatever the previous value was.</p><pre id="0685095d-3b13-4693-b925-534cc8554811" class="code code-wrap"><code>function deleteItem(id) {
console.log(&quot;DELETING ITEM!!!&quot;, id);
items = items.filter((item) =&gt; item.id !== id);
}</code></pre><p id="e287582d-a395-4447-abca-a4ee6190ef1a" class="">Now if you click the items, you can tell they are deleting because the array that is being logged keeps getting smaller but if you refresh the page, you will see they are all still there.</p><p id="94192290-f15d-4c2e-90a5-75b649414b15" class="">There are 2 things we need to do. We need to:</p><ol type="1" id="9480ced7-4655-43ad-bbb4-7c8ae765ef90" class="numbered-list" start="1"><li>re-render everything</li></ol><ol type="1" id="ebf019a8-a812-49f0-85ff-40ed670323e7" class="numbered-list" start="2"><li>localStorage</li></ol><p id="3608f313-dcd0-40e6-8da7-3dec2093adf8" class="">You might notice that both of those things are bound to the <code>itemsUpdated</code> event. That means you can just fire another <code>itemsUpdated</code> event as shown below 👇</p><pre id="eabb0a7e-cb4d-40c8-91b1-a309cadd1e90" class="code code-wrap"><code>function deleteItem(id) {
console.log(&quot;DELETING ITEM!!!&quot;, id);
items = items.filter((item) =&gt; item.id !== id);
list.dispatchEvent(new CustomEvent(&quot;itemsUpdated&quot;));
}</code></pre><p id="80d31e44-4312-4021-a78c-3e901e214f96" class="">Now it should just work, and when you click the item, it should be removed as you do it.</p><p id="9707fbb4-768f-4c49-88fb-ddd299b3e34d" class="">Why?</p><p id="9d0ca4e8-348e-42f6-9480-3255b1e86c44" class="">Because your event listener is listening for the items to be updated and then will do the respective work, mirroring them to the page and updating.</p><p id="a672e31a-41a7-42da-86b2-80b332ca4294" class="">The last thing we need to do is handle the checking and un-checking of the data.</p><p id="d79838ea-9a4e-4f86-8a94-3ef4153e3e8b" class="">If we have 3 items and 2 were checked, that information should persist when we refresh the page.</p><p id="5ea4e937-0118-4f60-98b9-2345064b7b01" class="">Create another function, <code>markAsComplete</code>, which will take in an <code>id</code>.</p><p id="a2621ff8-fade-4269-b811-b6c1b52df212" class="">What do we listen for in our case? We want to listen for a check of the checkbox.</p><p id="96377540-2ca0-4c9e-9d12-7bece86e443e" class="">We can use event delegation for that as well. We could add another event listener or do it inside of our existing click event listener.</p><p id="2128d76a-963d-4015-9f0a-702a5be87060" class="">Let&#x27;s do it inside of the existing one.</p><pre id="f3309eaa-8284-4524-9495-311cf62f1a26" class="code code-wrap"><code>list.addEventListener(&quot;click&quot;, function(e) {
if (e.target.matches(&quot;button&quot;)) {
deleteItem(parseInt(e.target.value));
}

if (e.target.matches(&#x27;input[type=&quot;checkbox&quot;]&#x27;)) {
markAsComplete();
}
});</code></pre><p id="64adba62-c44d-4687-9e1d-5a750827d128" class="">Our checkbox input currently does not have an <code>id</code> on it, so let&#x27;s fix that.</p><p id="9faccafc-cc23-40f7-82a7-ed21b627731c" class="">Go to where we make the HTML and modify the code as shown below.</p><pre id="08fbf74d-ed58-4d27-9ada-6c442f2b9669" class="code code-wrap"><code>const html = items
.map(
(item) =&gt; `&lt;li class=&quot;shopping-item&quot;&gt;
      &lt;input type=&quot;checkbox&quot; value=&quot;${item.id}&quot;&gt;
      &lt;span class=&quot;itemName&quot;&gt;${item.name}&lt;/span&gt;
      &lt;button
        aria-label=&quot;Remove ${item.name}&quot;
        value=&quot;${item.id}&quot;
      &gt;&amp;times;&lt;/button&gt;
    &lt;/li&gt;`
)
.join(&quot;&quot;);</code></pre><p id="d34b817e-e12e-48b5-960b-491c2a408bab" class="">Now, we have the value of the <code>id</code> in the input so we can go to our event delegation and pass the id like so 👇</p><pre id="6831a78b-3a2c-4bc0-aac4-3a56b51d9889" class="code code-wrap"><code>if (e.target.matches(&#x27;input[type=&quot;checkbox&quot;]&#x27;)) {
markAsComplete(parseInt(e.target.value));
}</code></pre><p id="26ba977c-759a-4066-b827-39a591646971" class="">Now when you check them, you should see &quot;marking as complete&quot; with the id logged to the console.</p><p id="81b25425-7872-4bec-bcd4-0040140bbb5b" class="">We are repeating ourselves a bit in our event delegator so refactor it as shown below 👇</p><pre id="d5d3c6a1-5d8a-46c6-8d61-b849f6b9e43a" class="code code-wrap"><code>list.addEventListener(&quot;click&quot;, function(e) {
const id = parseInt(e.target.value);

if (e.target.matches(&quot;button&quot;)) {
deleteItem(id);
}

if (e.target.matches(&#x27;input[type=&quot;checkbox&quot;]&#x27;)) {
markAsComplete(id);
}
});</code></pre><p id="837290aa-ead3-4271-a0d6-3315c6abc8fa" class="">Back to the <code>markComplete</code> function, we have to actually find the item that we need to set as completed.</p><p id="70204ae1-de11-40f5-817f-91141bf5e5cf" class="">How do we look for it? We can use <code>find</code>.</p><p id="0287d89b-92eb-44be-b78b-7312b58b3807" class="">Look for an item whose <code>id</code> matches the <code>id</code> that was passed in, using the code below. 👇</p><pre id="8a2f35f1-0e2f-4cbf-94c2-8dc129ea919e" class="code code-wrap"><code>function markAsComplete(id) {
console.log(&quot;Marking as complete!&quot;, id);
const itemRef = items.find((item) =&gt; item.id === id);
console.log(itemRef);
}</code></pre><p id="fbc43306-c126-4e02-ab8d-028ee033a8fa" class="">The reason we called it <code>itemRef</code> because if we change a value on the objet, it will be reflected in the array of items. So we can update the value of the item&#x27;s <code>complete</code> property easily.</p><pre id="0ce13a30-4aa5-49fe-83f9-c2a397a7e8cf" class="code code-wrap"><code>itemRef.complete =</code></pre><p id="cdbe24c1-9907-497b-9267-9592ce96e0a4" class="">This function will be used to check the item on and off.</p><p id="dc897f06-f79e-4d0a-8369-ad267457fb62" class="">You could have an if statement that says if it&#x27;s true, set to false and if false, set to true.</p><p id="ce3a6adb-775f-4d97-866b-9672a58b1b85" class="">Or you can just set it to itself, but the opposite, as shown below 👇</p><pre id="57a8fa17-c456-4122-b2a6-43656fa3564c" class="code code-wrap"><code>itemRef.complete = !itemRef.complete;</code></pre><p id="540597ab-d6d0-49e9-a02d-3858520f54f4" class="">That should work because the opposite of true is false and vice versa. Thus, setting it to the bang version of itself should work.</p><p id="f4700863-e307-41c0-a8ac-4dec3f19545a" class="">Now all you have to do is dispatch the <code>itemsUpdated</code> event because after updating the items.</p><pre id="4323148b-e96d-4cf8-80a3-827fbc193d07" class="code code-wrap"><code>itemRef.complete = !itemRef.complete;
list.dispatchEvent(new CustomEvent(&#x27;itemsUpdated&#x27;));</code></pre><p id="dfeccadb-f81e-4017-856f-0286fdf76113" class="">You will notice that if you try to enter an item and the check it, it looks like nothing is happening.</p><p id="bc929daa-0707-4c48-8fe2-1597f277d3b0" class="">However if you go to the application tab, you will see that the localstorage values are updating.</p><p id="0df0b5ed-7bb5-4b1e-9968-96d9efc18dcb" class="">What is going on?</p><p id="7ce6ae18-1312-4959-b619-1883a04dac07" class="">What is happening is the value is toggling true to false, but the checkbox is never working because we have not yet supplied the &quot;checked&quot; attribute to it when we rendered our HTML.</p><p id="cf451b72-5a7b-46e9-a6e4-8225d2a75a3f" class="">Modify the code as shown below to add the checked attribute 👇</p><pre id="b41a7d59-2173-49d2-838e-8fb0355b13c3" class="code code-wrap"><code>const html = items
.map(
(item) =&gt; `&lt;li class=&quot;shopping-item&quot;&gt;
      &lt;input
        type=&quot;checkbox&quot;
        value=&quot;${item.id}&quot;
        checked=&quot;true&quot;
      &gt;
      &lt;span class=&quot;itemName&quot;&gt;${item.name}&lt;/span&gt;
      &lt;button
        aria-label=&quot;Remove ${item.name}&quot;
        value=&quot;${item.id}&quot;
      &gt;&amp;times;&lt;/button&gt;
    &lt;/li&gt;`
)
.join(&quot;&quot;);</code></pre><p id="4cd6d60e-83ea-42d7-8017-d2403cb56a66" class="">Now all the items will be checked by default.</p><p id="b9b90f34-a71f-48a2-adfe-dc2eb35e7b08" class="">One of the things about the checked attribute is if you do <code>checked=&quot;false&quot;</code>, they will still maintain checked. Even just passing <code>checked</code> as shown below works.</p><pre id="d2d4c309-ff34-4533-aa3f-152212ef7f22" class="code code-wrap"><code>&lt;input type=&quot;checkbox&quot; value=&quot;${item.id}&quot; checked /&gt;</code></pre><p id="48278772-5165-416e-b59a-719784e267b4" class="">The absence of the checked attribute marks something as unchecked.</p><p id="3b7b1a4e-45f1-49e8-9145-83ddb8c2d7e6" class="">If the checked attribute is true, you need to add the checked attribute, otherwise we will pass nothing.</p><p id="ce2b97ec-f302-46cc-b4f7-242d8377550f" class="">Do that by modifying the code as shown below 👇</p><pre id="a8739dc0-7ae5-49dd-8d82-f0514cd7d496" class="code code-wrap"><code>const html = items
.map(
(item) =&gt; `&lt;li class=&quot;shopping-item&quot;&gt;
      &lt;input
        type=&quot;checkbox&quot;
        value=&quot;${item.id}&quot;
${item.complete ? &#x27;checked&#x27; : &#x27;&#x27;}
        &gt;
      &lt;span class=&quot;itemName&quot;&gt;${item.name}&lt;/span&gt;
      &lt;button
        aria-label=&quot;Remove ${item.name}&quot;
        value=&quot;${item.id}&quot;
      &gt;&amp;times;&lt;/button&gt;
    &lt;/li&gt;`
)
.join(&quot;&quot;);</code></pre><p id="9253f7eb-1ec3-484e-80b4-c4059db02cf1" class="">We could have also used the <code>&amp;&amp;</code> operator instead like so 👇</p><pre id="6010b00a-8f98-4b9e-aca9-3df9ac69212f" class="code code-wrap"><code>${item.complete &amp;&amp; &#x27;checked&#x27;}</code></pre><p id="4464924c-8fa3-46a7-aae0-898f2e60a1dc" class="">Now if you refresh, the check marks should stay as they were.</p><p id="b39df2e4-8e4a-43e9-b50d-11c070bb32de" class="">That was a lot, but that is how all of those frameworks work.</p><p id="4d627dfe-8c77-41bf-b258-ce2db8e3363c" class="">You basically have some state, you write a bunch of handlers to update state and to modify it, filter it, change it. When that state changes, you re-render out the HTML that is on the page.</p><p id="edd74a02-c467-487e-a327-c237780f0f1e" class="">One last thing is that security, which we will go over in future lessons in more details. Right now, if you wanted, you could submit an image as a list item input, which is a security issue. When you take input from a user and then display it in the HTML, we need to clean all the data the user types in.</p><p id="9f2e51a2-6188-4528-ae47-39ba1ce95889" class="">Find an issue with this post? Think you could clarify, update or add something?</p><p id="3f678f18-ca69-472b-aab9-1646bf52c38e" class="">All my posts are available to edit on Github. Any fix, little or small, is appreciated!</p><p id="70511890-d880-41a0-afad-a1a4b883fe97" class="">Edit on Github</p></details></li></ul><ul id="47904c7f-5c92-4f02-b01c-e37b0ef87f90" class="toggle"><li><details open=""><summary>58 - Building a Gallery</summary><p id="e6aecf87-80f8-416f-945a-949ca564c977" class=""><a href="https://wesbos.com/javascript/10-harder-practice-exercises/58-building-a-gallery">https://wesbos.com/javascript/10-harder-practice-exercises/58-building-a-gallery</a></p><p id="16fafe57-f3f1-4d60-b263-24f17312990e" class="">
</p><figure id="0477b605-c45f-499a-b34b-99bb8fb48078" class="image"><a href="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/bjs%203.png"><img style="width:700px" src="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/bjs%203.png"/></a></figure><p id="9d598378-b204-4043-a374-72b41b3d814e" class="">Enjoy these notes? Want to Slam Dunk JavaScript?</p><p id="85d1a44d-10c4-4d93-810a-46c7fb978887" class="">These are notes based on my <a href="https://beginnerjavascript.com/">Beginner JavaScript</a> Video Course. It&#x27;s a fun, exercise heavy approach to learning Modern JavaScript from scratch.</p><p id="a461db51-a812-4de0-a24a-a81baebaf4c4" class="">Use the code <strong>BEGINNERJS</strong> for an extra $10 off.</p><p id="00467651-a224-4b1c-aac4-a2c492577abd" class=""><a href="https://beginnerjavascript.com/">BeginnerJavaScript.com</a></p><p id="a91da8c2-28cb-4ee0-acc2-7968b0b42eab" class="">JavaScript, GalleryEdit Post</p><p id="366e4418-5890-4e86-9182-50df842a8116" class="">In this exercise we will be building a gallery.</p><figure id="0cef9032-fca7-4300-b8f5-40e74939ab48" class="image"><a href="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/856.png"><img style="width:700px" src="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/856.png"/></a></figure><p id="7dc54710-7a95-4e36-8332-c37be57fe208" class="">We are going to be building it in a standard way, and then come back and refactor it for prototypes once we understand what those are. Then we are going to come back to this exercise a third time and refactor the gallery for classes.</p><p id="fe52c8cb-df30-4d7d-8004-d979ff213baf" class="">Hopefully that gives you a good idea about why we need prototypes and what classes are.</p><p id="7e4aa6be-9e67-49cf-bc66-817c4cf76395" class="">This is an interesting example already because we want the ability to use this JavaScript many times over. A lot of the JavaScript we have written so far assumes that things are on the page and that there is only ever one of them.</p><figure id="beac1f05-bf0a-42a8-8155-cc7d54fba91a" class="image"><a href="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/gallery.gif"><img style="width:517px" src="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/gallery.gif"/></a></figure><p id="da0dbefe-c3ec-4453-a0c2-d74d807ea163" class="">This gallery allows you to tab through the images when they are tiled and select an image and have it open up larger with an overlay. The image has arrows on each side, allowing the user to navigate back and forth by clicking them or using the arrow keys, you can press the escape key to close the overlay view. It is basically a full featured gallery.</p><p id="f17e58c6-e5d9-4e2a-95c5-bb1230fa2d85" class="">However, if we were to have another completely separate gallery below, we should be able to re-use the same code and have it function in the same way, while keeping both galleries separate.</p><p id="b8db0e51-31b5-41b6-af10-c49a89099ea9" class="">So in this video we will be building the gallery from the ground up, multiple times, with the ability to re-use it multiple times.</p><p id="f8d7c2ed-7f01-4c01-b9ed-bb8500b171d1" class="">We will be working from the exercises directory, specifically <code>58 - Gallery</code>. Open up the <code>gallery.js</code> file to get started.</p><h2 id="650b607c-fb61-4c9c-b5ee-1d5245391e94" class="">Closures</h2><p id="9b9044ba-5080-4796-aeda-1b6147b1a867" class="">The first thing we need to do is create a closure.</p><p id="3991e6b4-ea56-4a7e-b6a7-3aac8773caa0" class="">We learned a couple lessons back that a closure is the ability to create a function, and that functions have scope.</p><pre id="da6028a5-2204-4acf-a8a7-139d89909b4f" class="code code-wrap"><code>function Gallery(gallery) {

}</code></pre><p id="15e50d6f-1b88-4d4a-9a2f-393af591c17e" class="">For example, the function shown above will have scope.</p><p id="46f42765-35d0-4f78-9536-421a3c164838" class="">If inside of that function you were to make some variables, such as a variable to hold all the buttons, and also create another function called <code>showNextImage</code> which references those button variables, then you have created a closure.</p><pre id="01c4d06a-2a25-4cd8-89ba-c640b7143ef6" class="code code-wrap"><code>function Gallery(gallery) {
const buttons = gallery.querySelectorAll(&#x27;button&#x27;);
function showNextImage() {

}
}</code></pre><p id="ed640c44-9758-4cb8-858f-91081b05302c" class="">That means that the gallery function will run when we create it, and the function <code>showNextImage</code> will exist for things like click handlers. The variables (<code>buttons</code>) that have been created in between the 2 functions (<code>Gallery</code> and <code>showNextImage</code>) will still be accessible even after the <code>Gallery</code> function has closed and stopped running.</p><p id="14fbff7f-e2a6-468c-a524-6002a0f04be6" class="">We are going to use that concept to allow us to create scope for each of the galleries, so that they don&#x27;t interfere with each other but they can reuse the same code.</p><p id="2c5e294b-c8a8-472b-b23e-d74f31a8176e" class="">If you added any of the code, clear out everything within the <code>Gallery()</code> block.</p><p id="590d4836-72de-4f46-bf1f-abbd3f6fe27f" class="">The idea with the Gallery is that at the end of writing the code, we have built almost like a plugin and we can go ahead and use it on the page.</p><p id="d112a25a-8325-413e-923f-706585aab5aa" class="">The idea is to be able to do something as shown below.</p><pre id="342e7155-71b5-49b9-9700-720b0a96ccf6" class="code code-wrap"><code>const gallery1 = Gallery();</code></pre><p id="729d5f3f-34c1-4d4d-8f65-2c666d9efc51" class="">Soon there will be a <code>new</code> keyword before we do <code> = Gallery()</code> but for now we don&#x27;t need that.</p><p id="e3f4dd9b-85f2-48c8-8576-0085c246b5a3" class="">If we go to the <code>index.html</code> that is on the Gallery exercises directory, you will see that we have a <code>div</code> with class of <code>gallery1</code>, and then a secondary gallery.</p><p id="dec5b6ce-66a9-4635-9c5d-79123e83ddd4" class="">Pass the gallery function reference to the gallery we want, which is the first one.</p><pre id="c84a508d-9f1c-44e5-b2ac-78292cb63c07" class="code code-wrap"><code>const gallery1 = Gallery(document.querySelector(&#x27;.gallery1&#x27;));
const gallery2 = Gallery(document.querySelector(&#x27;.gallery2&#x27;));</code></pre><p id="d9cc7799-7f1a-4825-b17a-f95946ab1234" class="">From the beginning we will be running these examples with 2 different galleries so that we know that every line of code that we are writing is safe for re-use over time.</p><p id="6723ce8f-8bb8-43ab-8885-07272387eca6" class="">The first thing we want to do is log the gallery from within the <code>Gallery</code> function. When you refresh the page, you should see both <code>gallery1</code> and <code>gallery2</code> logged.</p><p id="60cfd7be-4bd4-41ef-bc6d-3174b71690b2" class="">One helpful thing we can do is if no gallery argument was provided, throw an error that says &quot;No Gallery Found&quot;.</p><p id="5e60d7e7-82c7-4a5f-acdf-38d2315f6965" class="">By throwing an error like that, it will be logged to the console.</p><pre id="785b4fb4-ac6e-4714-8972-af962eb276ef" class="code code-wrap"><code>function Gallery(gallery) {
if (!gallery) {
throw new Error(&#x27;No gallery Found!&#x27;);
}
}</code></pre><p id="803f791e-55f1-4788-8222-c190022b5569" class="">If instead you want the function to gracefully degrade, you can simply return without throwing anything. That will break and exit the function without throwing any errors in the console.</p><p id="b8a6439d-ce19-4e7b-b264-866d3ef73d53" class="">Keep the code you added above.</p><p id="b93a7bc1-015b-4d27-94d8-847e78c60875" class="">Next you need to select the whole bunch of images.</p><p id="2a86f403-476e-4a16-91df-4b742f28affe" class="">Previously, Wes has been selecting everything at the top of the file, however, since we need to select these things for each of our instances, we will be selecting the images from <em>within</em> the <code>Gallery</code> function.</p><p id="972208ad-c0e9-4cad-b243-e53601ab6069" class="">The first thing you need is a list of all of the images. Instead of using <code>document.querySelector</code> however, you need to make sure it&#x27;s scoped to the gallery element that was passed in to the function.</p><p id="82d7cded-7863-45fd-9835-7cdd10605de8" class="">Use the <code>gallery</code> variable as our selector. For the list, use <code>Array.from()</code> because you will need to loop over it at some point.</p><p id="62144f38-9b3a-4f73-a75e-c371ca239f15" class="">Add the following code 👇</p><pre id="1d8ba501-0dac-4aa0-a0f1-e64c652dfc20" class="code code-wrap"><code>const images = Array.from(gallery.querySelectorAll(&#x27;img&#x27;));
console.log(images);</code></pre><p id="52ee0a74-e389-4dc9-a8e8-0c9f35091bb4" class="">If you add that code and look at the console, you will notice it is empty.</p><p id="53f704e0-d1cf-4f11-ade3-adae128acaa3" class="">Let&#x27;s debug that.</p><p id="181949ff-51d5-4ea4-83ee-052540848e0d" class="">Start by logging <code>gallery</code> before we declare the <code>images</code> variable.</p><p id="167d7b5d-bded-4559-9320-7deaf0d378eb" class="">As you can see, the gallery is showing up.</p><p id="b5788d95-116e-45c9-a48b-ece486bbea42" class="">If we look inside of the gallery, we can see lots of image elements.</p><p id="3ea1499d-05cf-406d-8bf1-4781fc8afe63" class="">The next thing you need is the modal, with the next and previous buttons.</p><p id="c6292e7f-d808-4b6d-b217-7e1547224ce6" class="">If you take a look at the HTML Wes has provided us with, he has scaffolded out the HTML for showing the modal.</p><pre id="e2e0eaf3-fe2b-4696-baa6-83f448e895f0" class="code code-wrap"><code>&lt;div class=&quot;modal&quot;&gt;
&lt;div class=&quot;modalInner&quot;&gt;
&lt;button aria-label=&quot;Previous Photo&quot; class=&quot;prev&quot;&gt;←&lt;/button&gt;
&lt;figure&gt;
&lt;img src=&quot;./images/kith-hoodie.jpg&quot; /&gt;
&lt;figcaption&gt;
&lt;h2&gt;Test Title&lt;/h2&gt;
&lt;p&gt;
          Lorem ipsum dolor sit amet consectetur adipisicing elit. Dolor
          dignissimos obcaecati nisi placeat eaque voluptate,
          exercitationem eius? Non, iusto provident itaque, voluptate
          labore a alias officia, amet sunt pariatur praesentium tenetur
          voluptatibus dolores mollitia quasi aliquid assumenda possimus
          maiores exercitationem!
&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;button class=&quot;next&quot; aria-label=&quot;Next Photo&quot;&gt;→&lt;/button&gt;
&lt;/div&gt;
&lt;/div&gt;</code></pre><p id="2558e6a2-7452-45dc-80d7-de25a80e8b64" class="">So we have a <code>figure</code> with an <code>img</code>, a <code>figcaption</code>, an <code>h2</code>, a paragraph.</p><p id="33ea5c71-a0c3-48c8-b106-030c35fbc725" class="">WHen someone clicks on an image in the gallery, that will open the modal and we will swap the text content of the modal out with the content associated with that image.</p><p id="2d5d9da0-5c48-42b0-b7d5-0c118cf8a8f0" class="">Start by selecting the modal. Do that with the <code>document</code> selector because in this instance, the markup for the modal will be shared between the galleries because we can only ever have one modal open at a time.</p><p id="8656b5ff-16dc-4bf0-9b20-10f2926d6874" class="">After that, look inside of the modal for the previous and next buttons.</p><p id="1b349b33-5394-4994-9ff8-014c65c3514a" class="">Add the following code to do so 👇</p><pre id="adffba4b-327a-4f05-829c-126e583dcdd6" class="code code-wrap"><code>const modal = document.querySelector(&#x27;.modal&#x27;);
const prevButton = modal.querySelector(&#x27;.prev&#x27;);
const nextButton = modal.querySelector(&#x27;.next&#x27;);</code></pre><p id="9dec4ea0-73da-476e-a8ac-245f40f9b53f" class="">For the rest of this exercise, we will be chunking up the functionality into a bunch of little functions.</p><p id="755b5981-9f0c-47db-bbb5-475a0817ea9e" class="">Those functions will be responsible for showing the image, opening and closing the modal, listening for clicks... there is a lot going on!</p><p id="90493f8b-aaae-4241-b10c-355b44b39844" class="">This is a great example of how you can take a JavaScript app and make it simpler by breaking it into smaller, little functions.</p><p id="07604b03-8de4-4e24-b1fe-6de058154cb1" class="">Let&#x27;s start with the showing of the image.</p><p id="99973faa-417d-4507-8c5f-aac4f81c2611" class="">When someone clicks on one of the images, you need to update that modal with the associated images, as well as pop open the modal.</p><p id="df15d4b5-44d4-498f-b2ce-eaf907c44ff4" class="">Name the function <code>showImage</code>. It will take a reference to an image element as a parameter which we will call <code>el</code>.</p><p id="62c860ca-5135-4dfd-a74e-6caf059624a0" class="">Within that function, check whether a reference to an image was passed.</p><p id="a6084e97-29ea-4e27-b7b2-c3f76c1b6095" class="">We are adding these checks because sometimes if for some reason something is broken when the function is run, having those safety checks will prevent the application from breaking on your page.</p><p id="4532a252-f4f7-48f8-a158-f71740764b11" class="">If a reference was not passed, log the message &quot;no image to show&quot; and return from the function.</p><p id="12d266d9-c20f-49a1-825d-ba037052c2f6" class="">Otherwise, we will update the modal with that image&#x27;s information but for now just log <code>el</code>.</p><p id="96cf87ae-0a07-40f8-91ec-9288d3dbba70" class="">The function should look like below.</p><pre id="a83161f2-a359-412d-b5ef-50d2fc87d7b3" class="code code-wrap"><code>function Gallery(gallery) {
if (!gallery) {
throw new Error(&quot;No Gallery Found!&quot;);
}

const images = Array.from(gallery.querySelectorAll(&quot;img&quot;));
const modal = document.querySelector(&quot;.modal&quot;);
const prevButton = modal.querySelector(&quot;.prev&quot;);
const nextButton = modal.querySelector(&quot;.next&quot;);
function showImage(el) {
if (!el) {
console.info(&quot;no image to show&quot;);
return;
}
// update the modal with this info
console.log(el);
}</code></pre><p id="d8e3510e-7220-4e85-9431-4e08d58aad90" class="">Next, take the images and loop over each of them to add an event listener on the click event.</p><p id="a351a82a-07aa-44c3-b278-4c4291e4e7c5" class="">When the image is clicked, the callback function <code>handleImageClick</code> will be run, which takes in the event as an argument.</p><pre id="8fdb9f2b-ae00-4b14-b49a-a4d7d1b27226" class="code code-wrap"><code>function handleImageClick(event) {

}

images.forEach(image =&gt; image.addEventListener(&#x27;click&#x27;, handleImageClick));</code></pre><p id="be027c43-d199-496a-b427-1b7a44a1f49a" class="">Inside of <code>handleImageClick</code>, call <code>showImage</code> and pass it the image tag that was clicked by using <code>event.currentTarget</code>.</p><p id="cd31fe89-40e2-4614-b2e5-b42f35ecd3a9" class="">Now that you have added a bunch of different functions, let&#x27;s check that it works and refactor it out to another arrow function.</p><p id="804f6822-8900-4186-9b9b-f1fa1cbec265" class="">If you refresh the page, you should see that when you click an image, that image element is logged to the console.</p><p id="c37bdec6-cf04-446f-8f99-f00629e2e294" class="">Refactor the code so instead of having a separate <code>handleImageClick</code> function, you can just do the same functionality with an arrow function.</p><p id="3fc27d35-2125-402e-8dfb-6f30e414d1aa" class="">Remove the <code>handleImageClick</code> function and refactor the code as shown below.</p><pre id="657f546e-85af-417a-99e5-a3e8c86def77" class="code code-wrap"><code>images.forEach(image =&gt; image.addEventListener(&#x27;click&#x27;, (e)=&gt; showImage(e.currentTarget)));</code></pre><p id="57d90e18-37db-479c-bead-be6254bb2de1" class="">If you run the code now, everything should work exactly the same.</p><p id="b02357b3-26a2-4139-989a-8adab83b4f49" class="">Back to <code>showImage</code>, there are a few things that need to happen.</p><p id="eec6ac8c-65ae-42b9-8989-6f9a3b37b503" class="">When someone clicks the image, you need to update the source of the image element in the modal and the <code>h2</code> and <code>p</code> content.</p><p id="7cfa3519-e71b-49c1-9ccd-25eef96b9fca" class="">Add the following code 👇</p><pre id="c8b9ce36-8582-40cc-8f10-5ab11b681672" class="code code-wrap"><code>console.log(el);
modal.querySelector(&#x27;img&#x27;).src = el.src;</code></pre><p id="d7f7e7ab-cb11-458a-881f-c67a24de790d" class="">Now if you refresh the page and click on an image, you should be able to go into the elements tab and look inside the modal to check the <code>img</code> src. It should be the source of the image that you clicked.</p><p id="697b3b3d-cf3b-47ba-9d2d-f56deb82e6c7" class="">Go ahead and duplicate the last line of code you added and switch the selector to be the <code>h2</code> instead.</p><p id="6540cdd1-2984-4f1f-be3d-8b80a3caa8fb" class="">Instead of setting the <code>src</code>, update the <code>textContent</code> of the <code>h2</code> to be <code>el.title</code>.</p><pre id="67b08207-b7dc-48a1-a5e6-5a1c11c2a667" class="code code-wrap"><code>modal.querySelector(&#x27;h2&#x27;).textContent = el.title;</code></pre><p id="48ae6cde-cda7-4efc-a6ce-5a1a2a274676" class="">Why do you need to do that?</p><p id="f0f60d1d-7118-441f-893b-291e6270dadd" class="">If you take a look at the image elements, you will see a couple of attributes on them.</p><p id="be1429bb-0412-4fab-ab7b-ddd766cee87b" class="">One of those is the <code>title</code>. Take the title from the image and then duplicate it again and grab the paragraph.</p><p id="b7c7ba93-24a0-49ff-a7d0-b3e66772e8ea" class="">The description is a data attribute on the image element, and you will need to use <code>dataset</code> to grab that value.</p><pre id="18fa35fb-33a3-48b1-996d-2e23503daead" class="code code-wrap"><code>modal.querySelector(&#x27;figure p&#x27;).textContent = el.dataset.description;</code></pre><p id="c3fb5e4d-02e3-43f2-8e67-ab3212fb639e" class="">Finally, you want to keep track of what the currently opened image is. Underneath where you declare the next button, add the code below.</p><pre id="5253aef9-9dd8-44ba-996f-aa4170bda004" class="code code-wrap"><code>let currentImage;</code></pre><p id="dbe33c28-5bc6-42eb-baf2-e64b68b5369c" class="">At the very bottom of the <code>showImage</code> function, add <code>currentImage = el;</code></p><p id="6a4da77b-b61d-449e-b313-ce9c86a98dc0" class="">If you refresh the page, then click on an image with the dev tools elements tab open, you should see the modal values being swapped out.</p><p id="a1c5cff6-f32e-4e56-9176-fb0554591f5a" class=""><em>Note: the demo text is the same for each image, but you can tell it&#x27;s being swapped because the first time you load the page, and then click, the value will be different.</em></p><p id="090d6e08-15f6-440b-bff4-3bb3c3eaa811" class="">Let&#x27;s work on actually opening the modal now.</p><p id="63ac5141-1a31-4a51-93b3-8ad1f320cb99" class="">Add a function <code>openModal</code>, and inside of it log &quot;Opening Modal&quot;.</p><p id="b805f229-1f9f-4ea2-be4b-a18342291a30" class="">At the bottom fo the <code>showImage</code> function, run <code>openModal()</code>.</p><p id="56f92418-f188-4509-8d57-9d19e9de0a1e" class="">Within <code>openModal</code> function, we need to check if the modal is already open. <em>(We need to perform this check because Wes has added some animations that will animate it in and out. We don&#x27;t want to be triggering those animations if the modal is already open for some reason.)</em></p><p id="0e4e5198-3b10-440d-bdcc-4f5f58e44fb7" class="">We can do that using <code>modal.matches(&#x27;.open&#x27;)</code>, which will take in the modal and check whether it matches the CSS selector we have passed it. In our example, we are checking whether the modal is open or not by the presence of the CSS class <code>open</code>.</p><p id="b806bfee-25c7-4c6f-bc62-ce1d551dcdfc" class="">If it is open, log that it&#x27;s already open and return from the function.</p><p id="078774be-c953-4544-8272-635ffa023581" class="">If it&#x27;s not already open, add a class of &quot;open&quot; to it, as shown below 👇</p><pre id="4971fb6b-5903-41e6-b8a8-8a0e68bf0f82" class="code code-wrap"><code>modal.classList.add(&#x27;open&#x27;);</code></pre><p id="4cee7acf-2e64-47ee-befd-cc63c5e5226b" class="">Your open modal function should look like the following 👇</p><pre id="70afd440-ff9f-43bc-af5b-9b324912534f" class="code code-wrap"><code>function openModal() {
console.info(&quot;Opening Modal...&quot;);
// First check if the modal is already open
if (modal.matches(&quot;.open&quot;)) {
console.info(&quot;Modal already open&quot;);
return;
}
modal.classList.add(&quot;open&quot;);
}</code></pre><p id="2ce10288-c728-425a-b02e-813b0ae6458c" class="">If you refresh the page, when you click on an image, the modal should now open.</p><p id="6f8cefd5-db9b-47d0-97ed-a235f838bf4d" class="">The previous and next buttons won&#x27;t work in the modal, and neither will closing the modal by hitting escape on the keyboard or clicking outside of it. But it does slide down from the top when we click an image.</p><p id="d0c718d0-21f5-413a-b02d-65e90bcc4b92" class="">Why does that work?</p><p id="51b23749-6d05-46d0-b625-7e9d4ef95954" class="">If you look at the <code>gallery.css</code>, you will see that by default, the modal has an opacity of 0 and pointer-event of none.</p><p id="2152af82-105a-4815-96fa-fd20d4270e16" class="">However the modal with the class of <code>open</code> has opacity of 1 and pointer-event of all.</p><p id="2327ce55-7b9c-4bbf-aae3-c1d48743de02" class="">The CSS style <code>opacity:0</code> will hide the element from the user, and setting <code>pointer-events:none</code> will ignore all the clicks on the element.</p><p id="05a28a22-8436-49a4-b68a-9ecc48f1f704" class="">There is also the <code>modalInner</code> which is currently off the page, via the CSS style <code>transform: translateY(-100vh);</code>.</p><p id="c0f416bb-2e5b-4f2e-869e-254a52cf5776" class="">If we comment that CSS style out and also set <code>opacity:1</code> by default on the modal, you will see that the modal is actually open and visible on the page by default. -100 viewport will move it off the screen.</p><p id="04fc15f7-364c-4c69-8082-4bbe505464d4" class="">When there is an open property on the parent, <code>.modalInner</code> gets a <code>translateY</code> of 0.</p><p id="8d056197-47a0-438a-8bf5-792344da23eb" class="">Make a function <code>closeModal</code> which will remove the <code>open</code> class from the modal. Add a TODO comment to remind you to add event listeners for clicks and keyboard like the escape key later.</p><pre id="013c1249-0a6f-4054-aee7-46a67a6ab527" class="code code-wrap"><code>function closeModal() {
modal.classList.remove(&#x27;open&#x27;);
//TODO: add event listeners fro clicks and keyboard
}</code></pre><p id="c6f64c79-a09e-4e77-8ab7-ad2e075fbb4f" class="">If you click outside of the modal, you want to be able to run the <code>closeModal</code> function.</p><p id="99cfa4ff-b8c0-4b7b-b3a4-b1dfd63b55f7" class="">How can you do that?</p><p id="356f9894-fd66-4a8c-bf42-063e0b32084d" class="">We only want the modal to close when someone clicks outside of <code>modalInner</code>. If you click within the modal, it should not close.</p><p id="c5594cf0-bb07-4f44-a253-ccde6e94a3f9" class="">Make a new function <code>handleClickOutside</code>, which takes in an event.</p><p id="d40194ce-a7ee-45eb-98d6-fe266126426f" class="">Go down to where we have our event listeners and add a comment of <code>//These are our Event Listeners</code> and then add <code>modal.addEventListener(&#x27;click&#x27;,handleClickOutside);</code>.</p><p id="c6848d95-56ac-4fbd-b6b8-af76a4899e57" class="">Inside of <code>handleClickOutside</code>, check whether the <code>event.target</code> is equal to the <code>event.currentTarget</code>. If it is, run <code>closeModal()</code>.</p><pre id="52bb23f7-6fce-423a-9498-37fc59c4b98f" class="code code-wrap"><code>function handleClickOutside(e) {
if (e.target === e.currentTarget) {
closeModal();
}
}</code></pre><p id="2c2466c9-2ce8-40ab-9625-453dd208fba9" class="">The code above checks whether the thing the user clicked matches the thing that you are listening for a click on. If they are the exact same thing, that means the user has clicked outside, and not within the modal.</p><p id="e66a350e-b9c7-44bb-84d9-6566ef933676" class="">So if you clicked within the modal, that would return false but if you clicked outside of it, it would return true.</p><p id="13598c5f-fb89-4dda-b1f6-0097eadde878" class="">Refresh the page and open the modal and click outside of it, to ensure it works. (It should.)</p><p id="b79beeff-d494-421a-9b9a-2bbabb7f30a1" class="">Next, let&#x27;s wire up the escape key on our keyboard. Make another function <code>handleKeyUp</code>, which takes in an event.</p><p id="1acad2d4-fcfb-4b50-b398-38e1fcb12f6a" class="">Inside of the function, add an if statement that checks if the key that was pressed matches &quot;Escape&quot;, and if it does, run <code>closeModal()</code>.</p><p id="fc24a3eb-73f7-412a-ada4-3746d281b60d" class="">This if statement is a good use case for a blockless if statement because it is a clean one liner.</p><pre id="73a96668-4f54-4d27-9e4b-689e4c830207" class="code code-wrap"><code>function handleKeyUp(event) {
if (event.key === &#x27;Escape&#x27;) closeModal();
}</code></pre><p id="cc0dc663-b124-42d4-8a3d-e9572353d0c8" class="">The <code>keyup</code> event will fire for any key that is pressed, so we will add more logic to only listen for the keys we care about in the future.</p><p id="7e72f6e4-6d99-4ab6-8ebb-24d10e566194" class="">Go down to our event listeners and add an event listener on the window. Listen for the <code>keyup</code> event and pass it the <code>handleKeyUp</code> function.</p><pre id="b18e9de5-92f4-4614-8498-c47fab157bd4" class="code code-wrap"><code>window.addEventListener(&#x27;keyup&#x27;, handleKeyUp);</code></pre><p id="12be4a6d-79bb-43cf-b756-8481975ef12a" class="">If you refresh the page, you will see that when you open the modal, you can hit the escape key and that will work. Try the second gallery to make sure it&#x27;s still working too.</p><p id="43373758-da54-444d-af85-d6b86a7def6d" class="">Next we need to hook up the next and previous buttons and arrow keys to show the next and previous images.</p><p id="083a84f0-d2a6-41e8-b8b8-e3502cf86550" class="">Let&#x27;s start with the button. Add the following event listener in the event listener section.</p><pre id="50a7e0ed-9f5c-44c4-b649-90791b2d9d5f" class="code code-wrap"><code>nextButton.addEventListener(&#x27;click&#x27;, showNextImage);</code></pre><p id="a0d2b3d9-feab-44e0-a422-e489d0f0c671" class="">Notice that we have all these small little functions already? It doesn&#x27;t necessarily matter in which order you put each function, but Wes likes to group them.</p><p id="746199a9-55d4-4676-b2c6-2668dcd95efe" class="">Further up, above the <code>showImage</code> function, add the function <code>showNextImage</code>.</p><p id="8c2c67c5-a301-41e4-ac58-d08bae5d54c5" class="">To be able to display the next image, we need to know which image is next.</p><p id="b9c1ce40-e7e1-447b-9d7a-d7cd00eb83d8" class="">When an image is opened, set it to be equal to the variable <code>currentImage</code> we created earlier.</p><p id="7aaafb09-5803-4f1f-8a8c-ea4e448aa0c6" class="">Now when we run <code>showNextImage</code> we will have access to the current image by referencing the <code>currentImage</code> variable.</p><p id="bbe26830-6bf7-4f65-9c4b-f1a7ffc5151b" class="">To grab the next image, you should able to use the <code>nextElementSibling()</code> method of the <code>currentImage</code> variable.</p><p id="635df239-3b8d-48b5-bf0c-e7d99e215b9d" class="">Log the value of that within <code>showNextImage</code> for now.</p><pre id="d508b835-d55b-47dd-a264-4aa5b8b2809e" class="code code-wrap"><code>function showNextImage() {
console.log(currentImage.nextElementSibling);
}</code></pre><p id="838592a1-b97b-4985-ae7a-37818a82f9f7" class="">It gives Wes the suitcase which is correct but we get an error.</p><blockquote id="15ac6ead-3304-4d49-8d66-8e0069b191a4" class=""><p id="a190df23-5a04-4260-919a-a1fb921c5e0c" class="">gallery.js:37 Uncaught TypeError: Cannot read property &#x27;nextElementSibling&#x27; of undefined at HTMLButtonElement.showNextImage</p></blockquote><p id="7185eb96-8f8f-4b7d-ad53-f5c2bfbae9ce" class="">Why is that happening?</p><p id="10ec7645-f33c-4ce2-b12e-12859d58f1e4" class="">That is a frequent problem that you will run into when you listen for clicks on things for multiple instances.</p><p id="c0615dd5-5ebb-43b3-98d2-dfae9f8c7d22" class="">In our case, what happened is we are listening for a click on the <code>nextButton</code>. We are listening for a keyup on the <code>window</code>.</p><p id="e9a4e590-a1c5-41f5-bdda-2758e6f113d7" class="">Because we have 2 galleries, there are 2 event listeners tacked onto the <code>window</code>, and onto the <code>nextButton</code>.</p><p id="b7bdab9b-0712-4bfe-bd74-bee3d1b3d624" class="">So what happened is it worked fine for the first instance and it errored out after the second one.</p><p id="e42bd968-3458-49f1-afe5-a4c61e93a056" class="">To fix that, we will take those 2 event listeners and move them the end of the <code>openModal</code> function.</p><pre id="765ac46a-c930-43b0-a4ba-d0f865caca65" class="code code-wrap"><code>function openModal() {
console.info(&quot;Opening Modal...&quot;);

// First check if the modal is already open
if (modal.matches(&quot;.open&quot;)) {
console.info(&quot;Modal already open&quot;);
return;
}

modal.classList.add(&quot;open&quot;);

// Event listeners to be bound when we open the modal
window.addEventListener(&quot;keyup&quot;, handleKeyUp);
nextButton.addEventListener(&quot;click&quot;, showNextImage);
}</code></pre><p id="aa7147b3-87d3-4b54-a60a-f4fd324c2bbb" class="">In the <code>closeModal</code> function we now need to do the exact opposite, which is to perform some cleanup when the modal closes.</p><pre id="5662f1f8-ce4c-497b-b9fe-ac20fb34a3a5" class="code code-wrap"><code>window.removeEventListener(&quot;keyup&quot;, handleKeyUp);
nextButton.removeEventListener(&quot;click&quot;, showNextImage);</code></pre><p id="c50acdf0-d657-4f9f-9fca-97c2fc0f67d2" class="">That makes sure that we are only ever listening for <code>keyup</code> and <code>click</code> on the things once, and then when the modal closes, we cleanup after ourselves and remove the event listeners.</p><p id="04056cfe-8a72-4502-a14d-ec4db6030ece" class="">If you refresh the page and open the console and click the image and then hit next, you should see that works. If you go to the other gallery and try it, you should still see it works and isn&#x27;t duplicating or anything.</p><p id="55fd1835-fbf3-408c-9cf1-b83d12f6b2de" class="">Now instead of logging it, we will instead pass it to our <code>showImage</code> function.</p><pre id="f7746f3b-4dc9-44fa-8429-bec795909ca6" class="code code-wrap"><code>function showNextImage() {
showImage(currentImage.nextElementSibling);
}</code></pre><p id="6aaac1fb-4fe7-431a-b53e-088b522d6586" class="">Now when you click one and then click the next one, it will automatically just change to the next one because we are passing the reference to the next image to our <code>showImage</code> function.</p><p id="71fcea8c-6ce8-4a9b-8ead-a2c19fd30006" class="">Now you probably see why we checked if there is no image passed in. When you hit the last image and click the next arrow, there is no next image, so it shouldn&#x27;t work.</p><p id="cd9792a3-d115-4b3d-8f8e-d061eac96dfa" class="">Let&#x27;s actually write a function where if we are on the last image we show the first image.</p><p id="e6b28236-bb3e-4c90-9f10-8ee5e08ac5af" class="">Modify the code like so 👇</p><pre id="5d82dcb9-1289-450d-88b1-516d9b36a8cb" class="code code-wrap"><code>function showNextImage() {
showImage(currentImage.nextElementSibling || gallery.firstElementChild);
}</code></pre><p id="3cab1852-f6a5-4aa2-999c-ad075b27b24a" class="">Now when you hit the last one, the first image will be shown.</p><p id="a0d56aa4-bbe6-4bcf-a98f-cccb204526b6" class="">Onto the back button now. Duplicate the function we just wrote and modify it as shown below.</p><pre id="dafecd8b-3dbb-49df-8111-c6b35082f06a" class="code code-wrap"><code>function showPrevImage() {
showImage(currentImage.prevElementSibling || gallery.lastElementChild);
}</code></pre><p id="2f176e5b-2e58-4c87-8efb-f14f8af64c14" class="">In the open modal, duplicate the <code>nextButton</code> line of code and modify it like so 👇</p><pre id="9689e2bb-33b5-496a-b2f7-01ac51c9b639" class="code code-wrap"><code>prevButton.addEventListener(&#x27;click&#x27;, showPrevImage);</code></pre><p id="c3bf847a-f70b-4961-9338-cb5da9a1ca01" class="">If you refresh the page and try that, you will notice clicking next works but previous doesn&#x27;t work. It&#x27;s always wrapping around.</p><p id="580139bb-dc07-4950-b5fa-28011c1a1309" class="">Go back to the <code>showPrevImage</code> function. We should have called <code>currentImage.previousElementSibling</code> not <code>prevElementSibling</code>. If you fix that it should now work.</p><p id="9c98866e-a183-46e1-84ab-7bb12a85dd37" class="">The next step is to hookup the arrow keys. Let&#x27;s piggyback on our <code>handleKeyUp</code> event handler.</p><pre id="33bac0a9-ab6d-4b02-b739-00b79418f02b" class="code code-wrap"><code>if (event.key === &#x27;Escape&#x27;) closeModal();
if (event.key === &#x27;ArrowRight&#x27; ) showNextImage();
if (event.key === &#x27;ArrowLeft&#x27;) showPrevImage();</code></pre><p id="d766df33-651c-4948-bb7b-b9605b36f418" class="">Now if you try using the arrow keys, you will see it works beautifully.</p><p id="d6fa36e9-21c1-46d4-8e21-eb8ef2e5ebb4" class="">One thing you could do is type <code>return</code> after each if statement. Although we aren&#x27;t actually returning anything, the return makes the function stop running. If it was escaped, there is no point in checking if arrow right or arrow left were clicked</p><pre id="e36a1c84-5ed8-401e-b0ca-bdca7732c79b" class="code code-wrap"><code>if (event.key === &#x27;Escape&#x27;) return closeModal();
if (event.key === &#x27;ArrowRight&#x27; ) return showNextImage();
if (event.key === &#x27;ArrowLeft&#x27;) return showPrevImage();</code></pre><p id="7061528b-0ca2-4b0a-bf26-58565e923101" class="">The last thing we need to do is the enter key.</p><p id="72965530-d618-4a55-890a-dfa7a91d274a" class="">Images by default are not keyboard focus-able, and in order to make the gallery accessible to keyboard users, we need to ensure that when they tab through it, they highlight and when you hit enter, it opens it up.</p><h2 id="07966094-b707-4cc4-bdde-06ddeffcec1f" class="">Tab-Index</h2><p id="58b402e2-b8c9-41f9-8ba0-71047b33897a" class="">If you look at the HTML page, you will see that all the images have a <code>tab-index</code> of 0.</p><p id="6e8021e2-0829-4add-8bcc-2eb87302fbd9" class="">By giving it a <code>tab-index</code> of 0, you are telling the browser that this is an element that you can tab through, just like an input or links. Giving them all a tab-index of 0 will allow the tab to just naturally go in the flow of the document.</p><p id="9a3324e5-645a-4809-b764-4b3389f34f5e" class="">If you added an input as a sibling of one of the images, you would see that we could tab from the input to the image with no problem.</p><p id="8c2ff773-045d-4de2-804f-d70942d8c2f0" class="">On some elements when you tab to them and hit enter, like a button, it will fire a click event but that is not the case for an image that has a tab index.</p><p id="75d305fd-6f5a-4b25-b45f-ed5574659b24" class="">Let&#x27;s listen for a keyup or keydown event and check if the user had hit enter when its&#x27; focused.</p><p id="769ea897-708c-4e56-adcc-83b00c5d3e53" class="">G down to our event listeners and take all the images, and loop over them again.</p><p id="9d9ccba0-d8d8-4ae4-b676-371f7a730806" class="">Note: you could do it in the same loop but for sanities sake, let&#x27;s keep them separate.</p><pre id="a9a25169-0c26-4666-9b61-3e9e5df9a795" class="code code-wrap"><code>// loop over each image
images.forEach((image) =&gt; {
// attach an event listener for each image
image.addEventListener(&quot;keyup&quot;, (e) =&gt; {
// when that is keyup check if it was enter
if (e.key === &quot;Enter&quot;) {
// if it was, show that image.
showImage(e.currentTarget);
}
});
});</code></pre><p id="1a26b5c1-4191-40ed-a42b-ee245edb4fa8" class="">Now when you tab through, you can hit enter and it will open the modal and you can press escape and it will close it.</p><p id="6568b490-b875-4f10-81eb-9ac3e60c69b2" class="">There is a lot going on but we are at only 91 lines of JavaScript code for a full featured gallery, which is pretty cool.</p><p id="5726ccee-f76f-4ee1-a280-30a47852c3a6" class="">We will be coming back to this video and refactoring it after we learn about <strong>prototypes</strong>.</p><p id="2958d5c1-6772-48dc-a6c3-732e7ca3f8fc" class="">The one thing about having all these <code>closeModal</code> and <code>openModal</code> functions inside of the gallery function is that those functions are not actually shared between the two galleries, they are just duplicated.</p><p id="48972a68-0506-48b7-ae3f-4216a58e855e" class="">We basically have double functions that do the exact same thing.</p><p id="2a049c04-2ca1-461e-ad32-d8bf84e231dc" class="">When we learn about prototypes in classes, we will learn about how to share the functionality between galleries as well as open up the functionality so we can call them manually ourselves.</p><p id="bf8e98ce-f418-49d2-aa67-9650a67f1458" class="">Find an issue with this post? Think you could clarify, update or add something?</p><p id="5fa2437a-7e78-4f96-b5b6-a6d81ec096d1" class="">All my posts are available to edit on Github. Any fix, little or small, is appreciated!</p><p id="0adbb58f-8ee0-4546-8a7d-993e998e8013" class="">Edit on Github</p></details></li></ul><ul id="6630419a-e5fb-44cd-86b0-fe626678e873" class="toggle"><li><details open=""><summary>59 - Building a Slider</summary><p id="0ac2ca86-6bf4-4f75-875b-c0f195077939" class=""><a href="https://wesbos.com/javascript/10-harder-practice-exercises/59-building-a-slider">https://wesbos.com/javascript/10-harder-practice-exercises/59-building-a-slider</a></p><p id="89313d2c-9988-4e69-a5e1-796690990056" class="">
</p><figure id="66757eb5-1516-4794-bd03-f03575acb2ba" class="image"><a href="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/bjs%204.png"><img style="width:700px" src="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/bjs%204.png"/></a></figure><p id="8c7d9363-ad15-4c3f-9cad-f5fb2564c537" class="">Enjoy these notes? Want to Slam Dunk JavaScript?</p><p id="41fbc58f-6f8a-4b7c-ba57-9651e370f82f" class="">These are notes based on my <a href="https://beginnerjavascript.com/">Beginner JavaScript</a> Video Course. It&#x27;s a fun, exercise heavy approach to learning Modern JavaScript from scratch.</p><p id="d60c6993-3733-4831-8b3e-04b2ee280dba" class="">Use the code <strong>BEGINNERJS</strong> for an extra $10 off.</p><p id="5e8d18bd-4164-4e3b-8e91-1767d1307fb9" class=""><a href="https://beginnerjavascript.com/">BeginnerJavaScript.com</a></p><p id="ba864618-65ab-4be3-9136-0f2b128b7e96" class="">JavaScript, SliderEdit Post</p><p id="c2d3cffd-7206-47ff-aa0a-033210de08df" class="">In this video, we will be building a slider.</p><figure id="e86908d7-2fc0-4c98-9397-4dc9616b3aec" class="image"><a href="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/881.png"><img style="width:700px" src="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/881.png"/></a></figure><p id="16dc55ce-c0e0-4a99-9b9c-7bc3bcc2a667" class="">A slider may seem simple, but once you dive into it, it starts to get pretty complex. We will build the basics of the slider together and then you can feel free to add any functionality you want to it.</p><p id="4a5342e7-a69e-46de-aea1-8523bd38b987" class="">Similarly to the last lesson, we will be writing everything in the same JavaScript file, and then later we will revisit this exercise and refactor it twice to use <strong>prototypes</strong> and <strong>classes</strong>.</p><p id="8b58aada-c5f8-47bf-b7de-79567174b91a" class="">We have 2 sliders on the page, so we can be sure that our code can be used more than once on the same page.</p><p id="b39bc2df-1717-4b2b-9067-ab0dc7bf94ac" class="">If we look at the HTML structure of the slider within the element tab of the dev tools, you will see that we have all 20 slides. Now as we hit the next button and previous buttons, the classes are actually changing on the sliders depending on what button you press.</p><figure id="a0677d3c-f6b6-4369-9a4c-d3ec101fca71" class="image"><a href="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/882.png"><img style="width:700px" src="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/882.png"/></a></figure><p id="bc22c0b1-75cf-4f0a-805b-134d0ae1df7a" class="">In this lesson we will use <strong>SASS</strong>, just to demonstrate that it is possible. Wes will show us how to get that up and running.</p><p id="12fb2d93-fbd4-4f0d-8488-0d4ae67f2148" class="">We are starting with the CSS shown below.</p><pre id="ac6c6123-a3c0-4845-bfb6-65947813a8b3" class="code code-wrap"><code>.slide {
position: absolute;
background: var(--pink);
height: 100%;
width: 100%;
display: grid;
align-content: center;
justify-content: center;
color: white;
font-size: 100px;
font-family: sans-serif;
border: 5px solid white;
transition: all .25s;
transform: translateX(-200%);
}</code></pre><p id="b03be33b-0113-4fda-a617-810ef8ee70bb" class="">The <code>slide</code> class positions the slide absolutely, using <code>display: grid</code>. Then we take the slides and put them off the screen like so 👇</p><pre id="064c737a-30cd-4c98-ad39-365a3693a5dd" class="code code-wrap"><code>.slide.prev {
z-index: 10;
transform: translateX(-100%);
}

.slide.current {
z-index: 10;
transform: translateX(0);
}

.slide.next {
z-index: 10;
transform: translateX(100%);
}</code></pre><p id="d4d69733-5b6d-4d93-ad35-f8cbe2a5f9c5" class="">Our current slide has <code>translateX(0)</code>, which puts it in the middle. As we modify the value that we pass to <code>translateX</code>, you will see the slide is moving.</p><figure id="c11051ba-4e1a-4a2e-ae6a-ab9b62be8a58" class="image"><a href="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/883.png"><img style="width:700px" src="10%20-%20Harder%20Practice%20Exercises%20141a50e3654647c98c05b05af06fcf63/883.png"/></a></figure><p id="1809ca58-df15-46d1-b215-9e7cb1c7f2b2" class="">By translating something 100%, we are essentially just putting it outside the slides <code>div</code> and we have an <code>overflow:hidden</code> on it so you cannot see what is outside of it.</p><p id="b4e674e9-15f2-43d5-a88f-239d3eaebb63" class="">Have the previous, current and next slide on translateX -100, 0 and then 100% makes for that animation. Wes has added a transition on the animation to make it look smooth.</p><p id="e5bfe29e-5dc2-4491-940c-59ec20e85471" class="">Back to the SASS, in the SASS file we aren&#x27;t actually using any special SASS syntax, so you could change the file extension to <code>.css</code> and it would work. However, Wes wanted to demonstrate that the Parcel bundler is able to recognize a SASS file if you add it via a stylesheet tag.</p><p id="c78925f4-9136-4e3e-840f-fa49b66d1ce8" class="">The Parcel bundler detects that the file is a <code>.scss</code> extension and it will compile it SASS for us before it puts it into the browser.</p><p id="2113b618-fc7c-43ea-8a20-7b499b55cbed" class="">Let&#x27;s get started. Navigate in our terminal to the <code>exercises/59 - Slider</code> folder. Run <code>npm install</code> once you are in that directory.</p><p id="79432de0-d423-472b-9468-e1ca3830dec5" class="">While that installs, open up the <code>package.json</code> file and take a look.</p><p id="aa022888-b748-4958-ae36-6f53dd72b42d" class="">You will notice that we have 2 dev dependencies, one for Sass and one for Parcel. When we type <code>npm start</code>, that will run the <code>parcel index.html</code> command.</p><p id="72cb83a4-ad8f-4433-bf06-4f39421f034e" class="">You should see the server is running on a specific port indicated in your terminal. Nothing should be happening on the page because haven&#x27;t added any JavaScript yet.</p><p id="1219a4a4-8ce7-421c-8027-c94a6ba3b24d" class="">Our JavaScript file lives in the <code>src</code> directory of our current exercise folder. Putting scripts in a <code>src</code> or <code>lib</code> folder is a pretty common thing to do. There is nothing special there, it&#x27;s just a way to organize your files.</p><p id="e075aa38-c6e7-488e-b745-4e0193a57079" class="">Let&#x27;s start writing some code. Create a function called <code>Slider</code> which will take in an argument, <code>slider</code> which will be the reference to the slider element that was passed as an argument.</p><p id="67e463dd-9905-4b66-9565-58ee78493f61" class=""><em>(Sometimes you will see people naming elements with an &quot;El&quot; at the end, just to specify that it is an element, but we won&#x27;t do that.)</em></p><p id="ac838c83-cd59-4c9d-b05d-31ab7b11ac4b" class="">Let&#x27;s create 2 variables, one for each of the sliders we have on the page.</p><pre id="5d942621-69dd-4430-867e-632242686aa1" class="code code-wrap"><code>function Slider(slider) {

}
const mySlider = Slider(document.querySelector(&#x27;.slider&#x27;));
const dogSlider = Slider(document.querySelector(&#x27;.dog-slider&#x27;));</code></pre><p id="ffeb2b5c-3185-4ec5-bbf6-fa7cfe31b615" class="">Within the slider function, add a check for whether someone has passed a slider in or not.</p><pre id="0e5fe89b-db9e-401d-bac1-6b2cc06f8b56" class="code code-wrap"><code>if (!slider) {
throw new Error(&#x27;No slider passed in&#x27;);
}</code></pre><p id="47a382b3-5ad3-4c94-82cd-fd4adc161cfb" class="">Now if you were to run the function and pass in anything instead of a reference to an element like <code>const mySlider2 = Slider(12322)</code>, it would not error out, because we are just checking whether we are getting anything.</p><p id="d477625c-7d6b-4bbf-8bfa-7d1ceb785ad7" class="">How can we check whether the function was passed in an actual HTML element? Like Wes has mentioned before, if we look at the docs for <code>document.querySelector()</code>, you will see that it returns an element.</p><p id="251c3978-6e4b-4d4a-adf4-0b7078f1c4b1" class="">The element is the most general base class from which all objects in a document inherit. That may not be very interesting to you, but wh at that means is when we create a div or a span, it inherits all of it&#x27;s base attributes from the Element in the browser.</p><p id="2a0a0a3a-431a-4c82-9bf0-16f2fe125e76" class="">If you open up your dev tools and type <code>Element</code>, you will see that it is a function.</p><p id="65523c3f-8ee5-46a8-8900-156b1e917992" class="">This means that we can use <code>document instanceof Element</code> to check whether something is an instance of the Element base class.</p><p id="a84d22d5-1a21-4553-8f3c-47f8890ae7ae" class="">Modify the code as shown below 👇</p><pre id="cfa08c63-a0fa-4f74-a8f2-fce4b32ed705" class="code code-wrap"><code>if (!(slider instanceof Element)) {
throw new Error(&#x27;No slider passed in&#x27;);
}</code></pre><p id="53af9122-6028-4b09-a962-f0da2bc045bb" class="">As we move through the slider, we will need to keep track of what is the current, next and previous slides. Create some empty variables that we will use to keep track of that.</p><pre id="2ed9e73e-d81b-43d1-8ce7-987afefe819d" class="code code-wrap"><code>let current;
let prev;
let next;</code></pre><p id="1cee37a2-716b-44ad-b938-1b34f6177698" class="">We will set those values when the slider starts, and when the user navigates with the previous and next buttons.</p><p id="3d9f5832-f9ef-4c32-b946-f0aeec275c0a" class="">Next, we need to select the elements needed for a our slider. If you look at the HTML code, it consists of all the slides and then the next and previous buttons.</p><pre id="f2048832-8a9e-4ca2-be98-78b09ffd014e" class="code code-wrap"><code>const slides = slider.querySelector(&#x27;.slider&#x27;);
const prevButton = document.querySelector(&#x27;.goToPrev&#x27;);
const nextButton = document.querySelector(&#x27;.goToNext&#x27;)</code></pre><p id="2e52a456-3607-4db4-9ea4-3169682c2215" class="">Just like we did in the last lesson, we will be adding a whole bunch of functions to add and remove CSS classes and figure out what is next.</p><p id="f9d7d180-5c2f-4350-aba4-9cd965d71708" class="">Create a function called <code>startSlider</code>. Within that function we will be populating those variables.</p><p id="893eaaf1-cf38-47a5-b84c-c6c5ba02e219" class="">We want to update the <code>current</code> variable from within this function. The reason we are creating the variable outside of the function is that it needs to be accessible by other functions we will create in the future like move next functionality.</p><p id="751c85b7-4828-40d4-8149-db55059c1efb" class="">If we created the variable inside of the <code>startSlider</code> function, that would make it scoped only to the function, and it would not be accessible elsewhere. By creating the variable at the top, all of the functions that live inside of our slider will have access to it.</p><p id="a8285d58-97ce-4506-adc2-d6f3cc18f027" class="">That is the concept of what a <strong>closure</strong> is. We have these variables that existing within our <code>Slider</code> function that other functions will be able to grab onto. They are not global variables, they are variables that live inside the closure of the <code>slider</code> function.</p><p id="e2096e2e-b722-48d4-85fd-cf510eb9c08c" class="">We will set the <code>current</code> variable to be either the first slide that is in the slider, or where the slider has the class of <code>current</code> (so you could set the slider to start at a specific image on page load).</p><p id="8e664976-4063-43da-9f7b-7ca3bce96918" class="">In one of the sliders on our HTML page, Wes has set the starting slide by passing a class of current to one of the slides and in the second slide there is no current class on load.</p><p id="26cf5613-1ee6-410e-b1f4-138ad8f05278" class="">We will set the value of current to be the slide that contains the class of &quot;current&quot; or if no slider has a class of current, we will get the first element child of <code>slides</code>.</p><pre id="386ec04f-54d8-4f16-9c03-2605f0e416e9" class="code code-wrap"><code>function startSlider() {
current = slider.querySelector(&#x27;.current&#x27;) || slides.firstElementChild;
console.log(current);
}</code></pre><p id="e96361d4-f807-4160-8c29-5b940960e5a8" class="">When we create the slider, we now have to run the <code>startSlider</code> function. Add it to the bottom of the <code>Slider</code> function.</p><pre id="864899f8-2525-419d-a331-fd3d581779a9" class="code code-wrap"><code>//when this slider is created, run the start slider function
startSlider();</code></pre><p id="3c5c685c-dda5-4917-bf2b-4487d36c9c7e" class="">That is often what we refer to as a <strong>constructor</strong>, which we will be getting into more when we hit classes.</p><p id="cc9d953b-cb89-47bc-b7dc-63c518f2ad14" class="">If you refresh the page you will see that we now have both of our slides logged in the console. The first slide starts at 16 because it has the class current on it and the slider had no class of current on any of the slides so it started on the first slide.</p><p id="421a1a7e-a337-4692-8584-cfdcd29e02aa" class="">For the previous one we will grab the element that is behind the current one using <code>previousElementSibling</code>.</p><p id="14ad8517-9945-4042-937a-81c4c1c495ca" class="">Let&#x27;s demo how that works by going to the HTML page in the browser, selecting slide #2 in the elements tab and then going back to the console and typing <code>$0.previousElementSibling</code>. You will see that the slide that says 1 will be returned.</p><p id="54086861-13eb-45b5-a022-3ae2e34d5b4c" class="">If you were to do the same thing but with #1 slide, you would get <code>null</code> because because there is nothing next to one.</p><p id="8d555716-6085-4fd0-8afb-f23aa0a41efa" class="">So we want to set the previous slide to be the <code>previousElementSibling</code>, or if that doesn&#x27;t exist, we can fall back to the last slide within our slides div.</p><pre id="03819cc9-08a3-433f-b4ee-e9ca2bc4afbe" class="code code-wrap"><code>prev = current.previousElementSibling || slides.lastElementChild;</code></pre><p id="b77b81dd-8626-4200-b7a4-6b147a4704d2" class="">Why is Wes using the Element version of the methods instead of using <code>current.previousSibling</code> or <code>slides.lastChild</code>? What is the difference between <code>lastElementChild</code> and <code>lastChild</code>?</p><p id="28d870c9-c921-4b82-b309-6657978edd5f" class="">Let&#x27;s demonstrate with an example.</p><p id="f9d27cd2-352c-44af-adde-3ad555e69006" class="">Add a paragraph at the top of the HTML page such as <code>&lt;p&gt;I &lt;strong&gt;love&lt;/strong&gt; to eat &lt;strong&gt;pizza&lt;/strong&gt;&lt;/p&gt;</code> and inspect it.</p><p id="6ffb902b-5446-4b63-8730-519c675577b3" class="">Click on &quot;love&quot;, and then go into the console and try the following 👇</p><pre id="f7915aa5-9280-4c89-b059-89cd7df4e633" class="code code-wrap"><code>$0
$0.nextSibling;
$0.nextElementSibling;</code></pre><p id="7fee8175-735f-41fe-951f-095daed3fa25" class="">What is the difference? <code>nextSibling</code> gives us a Node, and a node can be text or an element, whereas <code>nextElementSibling</code> will only return elements. Always use <code>elementSibling</code> when you are looking for an element.</p><p id="3fa6fad8-c617-41f7-b0e4-e36f1a2f6583" class="">Next will be <code>next = current.nextElementSibling || slides.firstElementChild;</code>. Then we will add <code>console.log({current, prev, next });</code></p><pre id="b49162f3-535c-4301-aa77-5001f5e249c9" class="code code-wrap"><code>function startSlider() {
current = slider.querySelector(&quot;.current&quot;) || slides.firstElementChild;
prev = current.previousElementSibling || slides.lastElementChild;
next = current.nextElementSibling || slides.firstElementChild;
console.log({ current, prev, next });
}</code></pre><p id="b11ee32a-ccd8-435a-8837-80b0b5e404d5" class="">If you open the console, you will see we have <code>current, prev, next</code>.</p><p id="72304f45-eeaa-4480-b3d4-3e6df45994bf" class="">Now we need to start applying classes to those to make them show up.</p><p id="47b25586-569d-4745-ac19-3b59aafce438" class="">Make a function <code>applyClasses</code> and we will take the current, add the class of current to it and then do the same the prev and next.</p><pre id="b9ed9479-5479-4457-86a1-e43a0c36c603" class="code code-wrap"><code>function applyClasses() {
current.classList.add(&#x27;current&#x27;);
prev.classList.add(&#x27;prev&#x27;);
next.classList.add(&#x27;next&#x27;);
}</code></pre><p id="5c9b6918-8a3a-48bc-a1ab-737a7ac72d7e" class="">Now when the code runs, we will just run <code>applyClasses</code> as well.</p><pre id="17e15076-7170-4b8d-af14-8c15b42e9cf5" class="code code-wrap"><code>startSlider();
applyClasses();</code></pre><p id="448374ad-ef46-4d26-b806-2c66d9fff3e4" class="">If you were to inspect the code you would see that now the appropriate slides have classes.</p><p id="67a7e76c-bb20-4e6c-b7d8-2b587ed03827" class="">Next we need a method called <code>move</code> that takes in a direction like back or forwards.</p><pre id="32fae94b-b936-47e2-801d-25a8f748bb4e" class="code code-wrap"><code>function move(direction) {

}</code></pre><p id="7f14077d-ace3-490e-8843-f0b253dafc1a" class="">When we call the <code>move</code> function it will move the classes around to switch which the current, next and previous slides are. You could manually edit the classes yourself in the element panel to do that.</p><p id="ef8a6b7f-d702-412b-a69a-b1403bd7b046" class="">The first thing this function will do is strip all the current classes off the slides.</p><p id="62aec3ed-197e-423f-acdb-993b11036a29" class="">Make an array of classes to remove and put the classes that we want to remove inside of the array. Then take the previous element and call <code>remove()</code>. Remove will take in as many arguments of classes that you want to remove as you want.</p><p id="f32f8df6-f4df-4b03-be88-ffd3c2593e32" class="">We will have to do that with current and next as well which is kind of annoying.</p><pre id="19620324-c560-4886-baf6-c954ec520de4" class="code code-wrap"><code>prev.classList.remove(&quot;prev&quot;, &quot;current&quot;, &quot;next&quot;);
current.classList.remove(&quot;prev&quot;, &quot;current&quot;, &quot;next&quot;);
next.classList.remove(&quot;prev&quot;, &quot;current&quot;, &quot;next&quot;);</code></pre><p id="be3781bd-5622-4d6d-a066-ed494f4b7c8b" class="">What is even better is we can take the array of classes to remove and spread it into the remove method, like so 👇</p><pre id="fbe715ff-b26d-4850-9359-02dd171469c8" class="code code-wrap"><code>function move(direction) {
// first strip all classes off the current slides
const classesToRemove = [&#x27;prev&#x27;, &#x27;current&#x27;, &#x27;next&#x27;];
prev.classList.remove(...classesToRemove);
current.classList.remove(...classesToRemove);
next.classList.remove(...classesToRemove);
}</code></pre><p id="5499deec-21c1-4b31-9127-4a8a8d8f4559" class="">We could even make that shorter by putting our elements into an array and then calling <code>forEach</code> on them and then within the <code>forEach</code> calling <code>remove</code> and spreading the <code>classesToRemove</code> array into it.</p><pre id="2a5ff0fa-856c-40a6-9b93-e39a53e3a027" class="code code-wrap"><code>[prev, current, next].forEach(el =&gt; el.classList.remove(...classesToRemove));</code></pre><p id="1237bd0f-cd9c-40a0-bd14-30903425c475" class="">Let&#x27;s go with the approach where we have three lines instead of the one liner to make it more readable instead however.</p><p id="adfc8ff1-3c83-4da7-a834-92535fbf2c46" class="">Now we need to figure out which direction the slides are going.</p><p id="4b7d63ba-821f-4e24-9cbd-903663b652cc" class="">If the slides are going backwards, the need to take our <code>current</code>, <code>previous</code> and <code>next</code> variables and shift them by one. If we are going backwards previous will become current, current will become next. We are basically shifting everything to the left.</p><p id="14428c78-b8db-4ec4-a87b-88b777c7ffed" class="">There is a bit of a problem when you are assigning variabels to be each other. Let&#x27;s say we tried the code below 👇</p><pre id="60f5cbe0-fa30-4cf4-bafd-3d7a96418105" class="code code-wrap"><code>if (direction === &#x27;back&#x27;) {
prev = prev.previousElementSibling;
current = prev;
}</code></pre><p id="d25d29c2-792f-442c-acb1-6c84c87e7948" class="">We have run into this problem where we have already updated what previous is. How do we access the old previous? We could do have a variable called <code>oldPrev</code> and then assign the value of prev to that before we reassign it but that is not the best way.</p><p id="b4d3c491-db18-4151-9770-29c662de1bf4" class="">What Wes will show us instead is how to use <strong>destructuring</strong> to switch variables easily.</p><p id="b44d0ffe-7f35-433c-80c4-22e8af8e4261" class="">We will destructure the <code>[prev, current, next]</code> variables and make an array of their new values and destructure them over and into the prev, current and next variables.</p><p id="b08e18a0-18ac-4379-bab4-690fec3bbf93" class="">That means the first thing we put into the array will be assigned to <code>prev</code>. Then next item will be <code>current</code> and the last will be <code>next</code>.</p><p id="3ca0431b-b02d-4806-bca7-05efd6c8257e" class="">The first thing will be <code>prev.previousElementSibling</code>. Then the current will be the <code>prev</code> and the <code>next</code> will become the current.</p><pre id="2377426a-03f9-4b95-8e14-c427064251ea" class="code code-wrap"><code>[prev, current, next] = [prev.previousElementSibling, prev, current];</code></pre><p id="494e7bb7-391c-498b-be96-70285e5889b3" class="">Now we will do the opposite if the direction is forward.</p><pre id="b29b601a-4c97-4c4b-996c-af39e4967a79" class="code code-wrap"><code>if (direction === &quot;back&quot;) {
[prev, current, next] = [prev.previousElementSibling, prev, current];
} else {
[prev, current, next] = [current, next, next.nextElementSibling];
}</code></pre><p id="650f6fbc-f485-41ae-88ac-a04cc28ec4cc" class="">That seems confusing but all we are doing is shifting them all one lower.</p><p id="dd1c1e0c-2b01-4899-8a02-a793a593eaed" class="">Next we will just run the <code>applyClasses()</code> function which will in turn add the current, previous and next classes.</p><p id="61a67e46-3197-4f73-a122-deae2a45935a" class="">Now we can take our previous button and our next button and hook up click events.</p><p id="5eb5329a-72a9-406d-a768-8c0c1f842074" class="">Let&#x27;s do it at the very bottom of our <code>Slider</code> function.</p><p id="5b82a647-1b54-4215-9566-707ad4d28d72" class="">Call the move function from the event listener handlers and pass <code>&#x27;back&#x27;</code> to when the previous button is clicked using an arrow function. When the next button is clicked, we will just pass reference to <code>move</code> since unless you pass the string &quot;back&quot;, it will move in the forward direction.</p><pre id="80b4cfe9-5807-41b3-a3a0-a37231757cf2" class="code code-wrap"><code>// Event Listeners

prevButton.addEventListener(&#x27;click&#x27;, ()=&gt; move(&#x27;back&#x27;));
nextButton.addEventListener(&#x27;click&#x27;, move);</code></pre><p id="6ab6f894-b54b-4732-94a4-c967ef051479" class="">While handling an event, if you need to pass an argument to the event-listener, you need to use an arrow function here. Or, you use <strong>call and apply</strong> which you will learn about in the next video.</p><p id="2f52d2b7-f357-4a47-9dfc-b5be0648ed66" class="">Now when you click it, you will see the slider works.</p><p id="1cb9c983-cfec-4156-b213-dbd93ae65eb5" class="">One error is when you get to the very end or very beginning, we will get an arrow because we lose our <code>next</code> class.</p><p id="4bb938cb-836b-45fc-a15e-74fd5f2a05f4" class="">Now we need to say when we have the edge case where a previous element or next sibling doesn&#x27;t exist you will add an or condition and get the <code>slides.lastElementChild</code> or <code>slides.firstElementChild</code> for the next button.</p><pre id="d378893d-4182-4765-98a6-cd0c616b3824" class="code code-wrap"><code>if (direction === &quot;back&quot;) {
[prev, current, next] = [
// get the prev slide, if there is none, get the last slide from the entire slider for wrapping
prev.previousElementSibling || slides.lastElementChild,
prev,
current,
];
} else {
[prev, current, next] = [
current,
next,
// get the next slide or if its at the end, loop around and grab the first
next.nextElementSibling || slides.firstElementChild,
];
}</code></pre><p id="f8cb20c0-23ff-4646-a19b-db5b19bc1164" class="">Now if you refresh the page you will see the slider is working but the second one is not. Why not? Let&#x27;s debug.</p><p id="3684347c-4426-48e6-accc-675e4598d17e" class="">The reason is that the buttons are not working for the second slider.</p><p id="479946f6-5006-42eb-86ba-c856165d1576" class="">Why is that?</p><p id="8c97fa6a-4b53-4c31-8fcf-cf569a5564f9" class="">Because if you look back at where we grab the buttons in our code, we are using <code>document.querySelector()</code> instead of <code>querySelectorAll()</code> to grab the buttons, which means both sliders are being moved by the same button. <code>querySelector</code> just finds the first element on the page and binds to that. It shouldn&#x27;t be <code>document</code>, it should be <code>slider</code> because we need to look for the buttons within the slider itself.</p><p id="18196c8e-ca06-4d58-9306-bccf51d5aebf" class="">If you refresh the page you will see they now run on their own.</p><p id="369171f2-33f2-4844-8733-690c3a8fe356" class="">63 lines of code for a slider!</p><p id="2079e7ed-0858-44b7-8b36-bea8c00da05c" class="">It would be cool to get the arrow keys working but only when someone is focused in on one of the dev. That would be an interesting exercise to give a shot yourself if you&#x27;re interested.</p><p id="44e718f0-b2d3-487f-a366-d0ae18aa5ce0" class="">We will be revisiting this exercise in our prototype lesson. The functions, <code>move</code>, <code>applyClasses</code> and <code>startSlider</code> are going to be moving to what are called <strong>the prototype</strong>.</p><p id="3b34051c-f555-4c76-8ca7-efd4fdb37f60" class="">Find an issue with this post? Think you could clarify, update or add something?</p><p id="f477eb63-894c-44bd-8032-83c587f62698" class="">All my posts are available to edit on Github. Any fix, little or small, is appreciated!</p><p id="0dc6f0c1-349a-4847-9edb-e4dde6ab9405" class="">Edit on Github</p></details></li></ul></div></article></body></html>