<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>8 - Data Types</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	padding-inline-start: 0;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.page-description {
    margin-bottom: 2em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-interactiveBlue { background-color: rgba(35, 131, 226, .07); }
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-translucentGray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }
.select-value-color-pageGlass { background-color: undefined; }
.select-value-color-washGlass { background-color: undefined; }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="1a54edb1-ad29-4901-8323-acf1435070d4" class="page sans"><header><h1 class="page-title"><em><strong>8 - Data Types</strong></em></h1><p class="page-description"></p></header><div class="page-body"><ul id="757d19ed-7f33-4bff-b672-c3dfe696738a" class="toggle"><li><details open=""><summary>42 - Objects</summary><p id="90dddf2c-1386-4405-8dc0-f45ee09bec94" class=""><a href="https://wesbos.com/javascript/08-data-types/objects">https://wesbos.com/javascript/08-data-types/objects</a></p><p id="33f8545b-05e5-41a5-85aa-17bbd073ec72" class="">
</p><figure id="a1202dc7-28c1-4a73-b2c2-2327a5458a2b" class="image"><a href="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/bjs.png"><img style="width:700px" src="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/bjs.png"/></a></figure><p id="91aea82c-1c1e-4ddf-93b4-9f64ec4b9e86" class="">Enjoy these notes? Want to Slam Dunk JavaScript?</p><p id="49dea9c9-611f-4a5d-b313-a53da6efdf49" class="">These are notes based on my <a href="https://beginnerjavascript.com/">Beginner JavaScript</a> Video Course. It&#x27;s a fun, exercise heavy approach to learning Modern JavaScript from scratch.</p><p id="3de7f8b3-9f7e-4b7a-811a-22837b7089b6" class="">Use the code <strong>BEGINNERJS</strong> for an extra $10 off.</p><p id="2df955b5-30d1-4e35-ad16-d5923ef672e1" class=""><a href="https://beginnerjavascript.com/">BeginnerJavaScript.com</a></p><p id="2ee12a82-dbd8-4c23-a9c3-1e57700fe613" class="">JavaScript, Data Types, ObjectsEdit Post</p><p id="5ff49e72-f4c4-4682-8154-630c119b35a3" class="">In this section of the course we will be learning about Objects and Arrays.</p><p id="4768a5bf-4ad0-4e94-b38c-e25b1bd43f04" class="">In this particular video, the focus will be on objects.</p><p id="23dd6515-0b99-4adf-b8c7-8267fc98e3d5" class=""><strong>Objects</strong> are another fundamental building block of JavaScript, just like strings, numbers and booleans. Actually, almost everything in JavaScript is an object, as you soon will see.</p><p id="a9ccd966-83a1-4018-a795-07e5a8d11850" class="">So, what are they?</p><p id="ffcfdaf4-9a9f-40b7-ab5c-2e5787fff7e8" class="">Objects allow us to group together <strong>properties</strong> and <strong>values</strong>, or <strong>keys</strong> and <strong>values</strong> is what they are often called (throughout the course Wes will be saying <strong>properties</strong> and <strong>values</strong>).</p><p id="f754dcfd-bac0-4399-8db9-cf5f76f0a6e1" class="">Objects have many uses from storing related data to storing functionality, all the way through to creating your own custom types.</p><p id="f71b2556-757d-4d42-9122-aa2a17e981fc" class="">Objects are used for when the order of the properties does not matter.</p><p id="189af830-4ee3-4d9a-b75a-c014baa222cf" class="">That is very important to note.</p><p id="dd4ba9c0-f068-46b4-ad44-ebdc5dd38267" class="">Let&#x27;s do an example to demonstrate this.</p><p id="c6949843-f993-484d-800b-38c18b70461e" class="">Open <code>objects.html</code> and add the following code in the body tag 👇</p><pre id="9668841f-a946-4a54-a373-b86090de2b52" class="code code-wrap"><code>&lt;script&gt;
const person = {
    name: &quot;wes&quot;,
    age: 100
};

console.log(person);
&lt;/script&gt;</code></pre><p id="22f01a16-c85a-4e17-8c5c-065578906ac0" class="">Now if you log the person object, what will you see?</p><p id="426dafa8-af3a-464b-a31a-abbe1a86bcb2" class="">You will probably see the object displayed with the properties in the same order.</p><figure id="ca211631-6a8f-4301-bb8d-46e25dcbed9b" class="image"><a href="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/440.png"><img style="width:700px" src="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/440.png"/></a></figure><p id="187ca046-4fcb-4f6a-a6ad-6cbc36a2ec84" class="">If you modify the code to swap out <code>age</code> and <code>name</code> so <code>age</code> comes first and then log, you will see that the properties also changed order when you logged it.</p><p id="5e5c1405-903e-4100-ba4f-e493ac61a4d6" class="">However, just because the JavaScript interpreter does that, never rely on the properties that you put into the object being in the same order.</p><h2 id="4ef007bb-b6ed-443c-a7ea-b131e25d48a5" class="">Creating an Object</h2><p id="4a1ea275-2c80-42f1-babc-04b5e643d245" class="">Typically when you create an object, you are going to open up a curly bracket, and then go ahead and close that curly bracket like so 👇</p><pre id="5c349ac0-901b-4d4a-9f87-f46a3c2c84c7" class="code code-wrap"><code>const person = {

};</code></pre><p id="76d1b3f7-78b1-442b-b024-bc6dab60ac41" class="">That is called the <strong>object literal</strong> syntax.</p><figure id="86fe0a88-4d57-4f5f-a277-0423b8b8cd3c" class="image"><a href="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/441.png"><img style="width:416px" src="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/441.png"/></a></figure><p id="9b22257f-bee3-41ec-9264-36de989e07d5" class="">You can also create an object like this 👇</p><pre id="e3690b79-7cf1-42bc-9301-ea65dd34147e" class="code code-wrap"><code>const person = new Object({
  name: &quot;wes&quot;,
  age: 100
});</code></pre><p id="808bc8c3-74a8-4818-9909-cfde125c606f" class="">You probably won&#x27;t see that notation often or ever because the object literal syntax is much cleaner.</p><p id="cd8fa491-a054-4c23-bc14-6725743dccfe" class="">In fact if you wanted to, you could create strings by doing <code>const name = new String(&#x27;wes&#x27;);</code> but we don&#x27;t because it&#x27;s simpler and shorter to use the <strong>string literal syntax</strong>.</p><p id="773fc8ba-d225-4cab-84d8-2b2715f9d755" class=""><em>Note: we will talk about the </em><code><em>new</em></code><em> keyword in coming videos.</em></p><p id="a3594609-bed5-457e-8019-a055e309135d" class="">Let&#x27;s talk about some of the keywords related to objects.</p><figure id="4db66771-9aea-4c06-a91c-f456adfb7e59" class="image"><a href="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/442.png"><img style="width:250px" src="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/442.png"/></a></figure><p id="83c93600-66cf-4e76-9f76-1e5d91fbd387" class="">The <strong>property</strong> is on the left, and then there is a colon and then we have the <strong>value</strong> on the right.</p><p id="0b9e99f7-d4fe-4a63-8c50-943b29484de3" class="">The values of an object can be any type (string, function, boolean, other objects, arrays etc).</p><p id="52b220bd-ae53-489a-bc8f-7aa84e391b12" class="">So for example, let&#x27;s say we have a variable, <code>age</code> which is set to 100 like so <code>const age = 100;</code>.</p><p id="c29aca53-b66e-49f2-95eb-2d1c1b436ab4" class="">Now you could swap out the hardcoded age from the person&#x27;s object and instead assign it the variable like so 👇</p><pre id="a4d732c9-99df-4936-9067-15de66799dca" class="code code-wrap"><code>const age = 100;

const person = new Object({
  name: &quot;wes&quot;,
  age: age
});</code></pre><p id="ea1654ad-9cfd-47e0-a8fc-91b2e78b1132" class="">If you log the <code>person</code> object now, you will see that <code>age</code> still shows the value of 100.</p><p id="56c51c6d-2afe-4d9a-a73f-61d4aa1fb8cd" class="">That&#x27;s a pretty common thing that we&#x27;ll do.</p><p id="9d13756a-1733-4df0-8b35-f6b1561270ee" class="">Now if you ever run into this situation where the property is the same name as the value variable that you&#x27;re setting it to, you can simply get away with simply writing age like this 👇</p><pre id="1395733e-72d6-41da-871f-8b5815b49433" class="code code-wrap"><code>const age = 100;

const person = new Object({
  name: &quot;wes&quot;,
age
});</code></pre><p id="9f56e4fb-884a-4ad4-bbae-28a77a94d80e" class=""><code>age</code> is both the property name and the value because the <code>age</code> variable is being used for the <code>age</code> property.</p><p id="25b6fabe-4860-41ca-853f-4e64476e6864" class="">That is the exact same thing as doing <code>age: age</code>.</p><p id="b55ef4f7-2e7e-4798-bbfb-79382bb7648a" class="">The properties of an object pretty much follow the same rules as variables and Wes would recommend that you use the same rules as variables.</p><p id="d87db93c-86a8-4498-a61b-e6dce0304bb6" class="">However, you can go a bit further with the properties of an object.</p><p id="fbd23e17-0443-4fc6-824b-48c4696347fc" class="">For example let&#x27;s say you added one more property to the <code>persons</code> object 👇</p><pre id="beaa7b01-ee8e-4a86-ab34-e19706abc66b" class="code code-wrap"><code>const person = new Object({
  name: &quot;wes&quot;,
age,
&quot;cool-dude&quot;: true
});</code></pre><p id="4f562dd1-03cc-4fce-9145-e28b36da6200" class="">As you can see, you can have a property with a dash in it, whereas you cannot have variables with dashes in them.</p><p id="ced825af-c81c-4ad5-a9ca-f15d4943e8d1" class="">Similarly you can also have spaces and numbers in your properties like so 👇</p><pre id="9f8ef9b8-43eb-411d-85ec-e61ef61fc240" class="code code-wrap"><code>const person = new Object({
  name:&#x27;wes&#x27;,
age,
&#x27;cool-dude&#x27;: true,
&#x27;really cool dude&#x27;: false,
&#x27;777&#x27;: true,
});</code></pre><p id="3722f772-17a5-4aa8-b912-ef3f166765b4" class="">Also, you might notice that in the console the order of the properties look different from our code, which is expected and fine.</p><p id="6c3f7371-f5b5-4fc6-8af0-f4067130e6e0" class="">After each property, you might notice that we add a comma.</p><p id="ed269ff8-d1fb-473a-a6a2-258b9fa4b279" class="">Wes recommends adding a comma after the last property in the object, even if there is nothing that comes after it.</p><p id="77619cfb-2683-4457-ad66-e819587573ac" class="">That is what is called a <strong>trailing comma</strong> or a <strong>comma dangle</strong>.</p><p id="00767eb5-44f5-4890-acdd-c2d23215082d" class="">It&#x27;s not totally necessary, but putting a <strong>trailing comma</strong> on there will make sure that the next time you come around and add in a property, we can easily add it.</p><p id="138160f5-c70c-42d8-8df5-e7134667b5df" class="">What happens all the time is if you don&#x27;t leave a trailing comma, the next time you go to add a property it&#x27;s very easy to forget to include the comma.</p><p id="acc56b48-5b67-4680-9f14-20b6cdcfcd2c" class="">If you forget to add a comma between properties, you will see an error similar to what is shown below.</p><p id="0eeadeca-c17f-4c8b-b6e0-1c71acaf8ac8" class="">Another reason is version control.</p><p id="0ea2eff8-3a55-4fc5-9740-3026038f2b1f" class="">Let&#x27;s say someone else is coming in and editing your code.</p><p id="f5634ca0-571f-4f98-a2f4-585f905bc8d1" class="">Instead of just adding a new property, they have to edit the line above to add a comma, and even though you only modified the line above by adding a comma, it will show up in git blame that you modified that line of code last.</p><p id="87344715-6c36-465b-b4c6-18fe9ce3f0e5" class=""><em>(Git blame is a git functionality that shows who wrote which line of code.)</em></p><p id="d10ee910-be94-476b-a9ec-40feba230fbc" class="">It used to be that comma dangles weren&#x27;t supported, but now all modern browsers do support the comma dangle on object properties.</p><p id="aeec9d11-5964-4048-b746-1623c2385f63" class="">Other things you can do is add <strong>nested properties</strong> or <strong>nested objects</strong>. For example, you can create a property called <em>clothing</em> and assign it a sub object like so 👇</p><pre id="d3daa1ef-97ec-43b6-a082-c7bfa9f2216e" class="code code-wrap"><code>const person = new Object({
  name: &quot;wes&quot;,
age,
&quot;cool-dude&quot;: true,
&quot;really cool&quot;: false,
&quot;777&quot;: true,
  dog: &quot;snickers&quot;,
  clothing: {
    shirts: 10,
    pants: 2
}
});</code></pre><p id="67723457-6997-41e3-befd-bb761136240d" class="">As you can see, now the <code>person</code> object has a nested object <code>clothing</code> which has <code>shirt</code> and <code>pants</code> properties.</p><p id="61697348-6613-4ec8-b389-9a7e2d790002" class="">You can nest objects as deep as you could possibly want.</p><p id="c00836a6-9ff2-49f7-9180-40c747ebcc4f" class="">There is a gotcha about copying or cloning objects which we will talk about in just a second.</p><p id="49639b6c-db3f-48d0-95df-8f3aa3e24ffd" class="">You can add new properties to an object even after it has been created, using the dot notation.</p><p id="63f9b7c3-3382-4cd2-816b-25ed3c292e08" class="">For example if we wanted to add a <code>job</code> property to the <code>person</code> object, you could simply add this line of code 👇</p><pre id="1d1376f6-7370-452a-aefc-36423a192ea9" class="code code-wrap"><code>person.job = &#x27;Web Developer&#x27;;</code></pre><p id="808a1f0b-277f-452e-8c7a-c8594bf8c5d2" class="">Now if you were to take a look at it in the console, you will see the <code>job</code> property has been added and is now part of the object.</p><p id="87f9a9d2-fdd8-45ee-becb-fa9403799233" class="">Similarly if you were trying to overwrite a property, you could do that as well.</p><p id="db37cee9-2774-4ed5-a771-04b426da4468" class="">For example, is you add this line <code>person.age = 50;</code> and then refresh the HTML page and look at the console, you will see that <code>age</code> is now set to 50 even though when creating the object, we set it to the variable <code>age</code> which was 100.</p><p id="7b05dc24-255a-4b88-809b-b6457b120249" class="">You might have noticed that the <code>person</code> object is a <code>const</code> variable, however you just went ahead and changed part of it.</p><p id="b0b07368-daba-4883-a3e7-bb00ebd3d1dd" class="">That is a gotcha in JavaScript.</p><p id="9f0d9f44-12ed-4676-93da-eb913467156b" class=""><code>const</code> does not mean that the value of an object cannot be changed. <code>const</code> means that the binding (reference) to that variable cannot be changed.</p><p id="7c7c68d3-d408-488f-9f42-8d21719b6aee" class="">What does that mean?</p><p id="a6c97606-5004-4597-b2b0-09e745962420" class="">To explain, let&#x27;s rename the <code>person</code> variable to <code>wes</code>.</p><p id="c456b983-c9cb-4d75-80b8-59552acf4df6" class="">You code should now look like this 👇</p><pre id="d2309426-db09-4404-b4fa-1861902ee5ac" class="code code-wrap"><code>const age = 100;

const wes = new Object({
  name: &quot;wes&quot;,
age,
&quot;cool-dude&quot;: true,
&quot;really cool&quot;: false,
&quot;777&quot;: true,
  dog: &quot;snickers&quot;,
  clothing: {
    shirts: 10,
    pants: 2
}
});

wes.job = &quot;Web Developer&quot;;
wes.age = 50;
console.log(person);</code></pre><p id="786417e7-8e2c-402c-9d62-4a1f0e4e0e14" class="">Think about it like this.. Wes is Wes, he has been born and this object represents properties about him.</p><p id="6a8edd9b-982c-4dcb-a81b-cf75b54666b2" class="">Those properties can change as he grows up, however no one can ever replace him. No one can ever overwrite the binding to him.</p><p id="31d66bca-077f-4e87-8a90-ecbbf19c295e" class="">No one could ever come by and say &quot;oh a new Wes was born&quot; and create an object like this further down in the code 👇</p><pre id="b78df99e-114f-4be4-a6f7-d6cfddf3ed0e" class="code code-wrap"><code>wes = {
  name: &#x27;Westopher&#x27;,
  age: 12,
  job: &#x27;Web Master&#x27;
}</code></pre><p id="0972056c-5bd7-47ea-b497-9394195d4fba" class="">You can&#x27;t do that.</p><p id="f4814494-14ca-4e06-9f21-3abf4f63c388" class="">If you refresh the HTML page and open the console, you will see this error 👇</p><p id="24610a85-6789-41f6-92ca-d87c274b5b29" class="">Even if you put the keyword <code>const</code> in front of the second <code>wes</code> object, you will still get an error that says</p><blockquote id="bde288d3-d154-41e4-84c3-25fa60b3be2f" class=""><p id="2be61edc-7355-4eba-8446-4b5931bf48d1" class="">Identifier &#x27;wes&#x27; has already been declared.</p></blockquote><p id="e6d86926-4e9a-44f0-9eed-9b0faff57835" class="">It doesn&#x27;t work because the binding to <code>wes</code> has already been created.</p><p id="e53503e0-1efe-4a7f-91c2-110acc6296e7" class="">Even though properties on the <code>wes</code> object can change, the actual object itself will can never be overwritten entirely.</p><p id="2391c8b2-70ec-415b-bd17-1a1c3a19bcd4" class="">If you do ever want to freeze the values in an object, what you can do is create a frozen object.</p><p id="7788fdd5-b191-4c0b-afd8-c2dd1f132376" class="">You use the capital &quot;O&quot; <code>Object</code> and call <code>.freeze()</code> on it and pass the object to it that you want to freeze.</p><p id="e34eaa5d-24ed-4dda-bd7e-c9d3cd2322b7" class="">Add the following code at the bottom of the script tag 👇</p><pre id="fb06ffc5-29db-4064-95bd-f00b9ba38d77" class="code code-wrap"><code>const wesFroze = Object.freeze(wes);</code></pre><p id="827ce3fd-63d2-4d86-8385-1a465d7558e1" class="">That will freeze the original object <code>wes</code>, and return it. In this case, <code>wes</code> and <code>wesFroze</code> are exact same objects.</p><p id="c6e107b2-4a50-49d8-9fa4-6e76aa6c28d6" class=""><code>freeze()</code> returns the exact same object that was passed into the function. It does not create a copy.</p><p id="6ef51723-601a-4a97-a571-ef0b93bb0271" class="">To demonstrate this, refresh the HTML page and then type <code>wesFroze</code> in the console. That should return the object.</p><p id="c3734f06-bd3c-4a15-9c3f-40d919769892" class="">Now type in <code>wesFroze.age = 100</code> to try to overwrite the age, and hit enter (it should return 100).</p><p id="d7777427-ad8c-4d5a-ba1c-5ffa34f03fd4" class="">Now type in <code>wesFrozen</code> again and the object should be returned to you and the <code>age</code> property should still be set to 50.</p><p id="f77208ec-63ad-4c51-83cf-d4bb0de87dfd" class="">So if you ever want to make an object so it cannot be changed, you could do that with <code>Object.freeze()</code>.</p><p id="0de39edb-b10d-418a-8bfb-1db14a865ef5" class="">The word in programming that we use to describe something that cannot be changed is <strong>immutable</strong>. <strong>Mutation</strong> is changing a value.</p><h3 id="b97807e6-b97d-4cd5-ad8b-ca8d856cb9e8" class="">Accessing Properties</h3><p id="ddb6d5d1-8044-410e-aaee-aaaa8be01052" class="">Wes has already shown us one way to access properties, which is using the dot notation.</p><p id="6783043b-0f4b-43c0-a139-8fc58d685dc8" class="">For example to access the job property you would write <code>wes.job</code> which would return &quot;Web Developer&quot;.</p><p id="f51aa6b2-5e34-4a14-8626-faf04d966b6d" class="">Just like when we looked at DOM elements, we have <code>getters</code> and <code>setters</code>, <code>objects</code>. That is the exact same thing with an object.</p><p id="137c2962-95fb-4d1e-8d7a-138b4bd9ac04" class="">In fact, a DOM element is just an object with a bit of extra functionality added to it.</p><p id="6d1a355d-c911-40ea-b391-3a010e7198ea" class="">That is the first way, and that is typically the approach you will use in almost every use case.</p><p id="9a6eb5c6-8b33-44e2-beeb-0d4ad6814f03" class="">However, we have this other notation to access properties and that is with <strong>square brackets</strong>.</p><p id="80973722-3420-44fb-894f-d53c8492bec2" class="">Similarly to how you can access the property using the dot notation you can also use <strong>square brackets</strong>.</p><p id="d629f680-8ddb-40ae-b55c-69e6c3d7da2b" class="">You simply write the object name then a set of square brackets, and between the square brackets you give the property name in strings, like so 👇</p><pre id="9d3063a1-066c-4334-9cd8-40114db797b1" class="code code-wrap"><code>console.log(wes.age);
console.log(wes[&quot;age&quot;]);</code></pre><p id="38c3aa57-4dc2-4b82-83c5-eeb5123376b6" class="">Why do we have that? That seems like a much uglier way to access the properties.</p><p id="d2a25498-66a8-49f2-a3bb-1956fa7bbcc9" class="">There are a few reasons.</p><p id="88a7cd07-5da0-4110-a117-3c28a92d83d6" class="">One reason is that this method allows us to pass a variable that is a string type to the square brackets instead of passing a string directly.</p><p id="2a33d869-d63e-47bf-84df-c144912e9ac6" class="">Let&#x27;s do an example.</p><p id="8cb36191-f78f-41f6-a8c0-6851eeeff4f0" class="">In the <code>person</code> object, add another property like so 👇</p><pre id="c65864e1-e733-42ac-ae89-711cd431ac99" class="code code-wrap"><code>const wes = new Object({
  name: &quot;wes&quot;,
  propertyToCheck: &quot;NEVER&quot;,
age,
&quot;cool-dude&quot;: true,
&quot;really cool&quot;: false,
&quot;777&quot;: true,
  dog: &quot;snickers&quot;,
  clothing: {
    shirts: 10,
    pants: 2
}
});</code></pre><p id="64354b9d-a78b-450d-8c08-d630fb28146a" class="">Remove the square bracket log we added above and add the following code instead 👇</p><pre id="0df1400f-2fc9-4158-b50f-8d853e23825d" class="code code-wrap"><code>console.log(wes.age);
const propertyToCheck = prompt(&quot;What do you want to check?&quot;);
console.log(propertyToCheck);
console.log(wes[propertyToCheck]);</code></pre><p id="ed5602df-3c9d-493a-9cc3-5bcdc79eff1d" class="">As you can see, instead of passing <code>&quot;age&quot;</code> to the square brackets, we are passing the <code>propertyToCheck</code> variable instead.</p><p id="14b383a5-7d71-45f3-bd94-f5537968bce4" class="">The value of <code>propertyToCheck</code> is assigned to whatever we enter into the prompt.</p><p id="381746ae-b18d-4c5a-ad47-f67a42e30b8f" class="">Refresh the HTML page and you should see the following 👇</p><p id="96355247-8759-41ae-959d-c6689b59f04b" class="">If you open the console and then enter a property into the prompt such as <code>age</code>, you will see the value is logged.</p><p id="85664d19-f0cf-4a66-a1a6-49aa2de851ab" class="">For example, if you were to type in <code>clothing</code>, it gives you the object that is the clothing.</p><p id="24def1f0-f332-4766-85cf-a26f9386cc36" class="">That is one reason: when the property of the object is stored in a variable, because you can&#x27;t just write <code>wes.propertyToCheck</code> because the code will literally look for a property named <code>propertyToCheck</code> on the object, it will not be able to interpret that it is a variable.</p><p id="4d683d15-7115-4722-8b15-16c8ef3c23e7" class="">Let&#x27;s test this out. Add the following line of code and refresh the HTML page 👇</p><pre id="a3c0c870-124f-4171-9b21-e09f3968215e" class="code code-wrap"><code>console.log(wes.propertyToCheck);</code></pre><p id="2fb3acd0-83a7-4427-b611-81705cbe0739" class="">You should see the word &quot;NEVER&quot; logged in the console.</p><p id="edecd225-a6e9-45d8-bd3f-090e3a4055c7" class="">Wes asked us to add that property earlier to demonstrate that if you use the dot notation, the code will assume you are looking for a property with that name, and it will not know it&#x27;s a variable.</p><p id="67057363-0a83-437a-a30a-67681ab38d03" class="">If the property name is stored in a variable, you <strong>must</strong> use square brackets.</p><p id="2ea70f2e-2dcc-4531-bf0a-286726809f96" class="">There is another reason, which sometimes the properties of your object are not referenceable via JavaScript, and instead you have to use a string.</p><p id="2a634644-1471-4209-98dd-8609e28b0939" class="">Comment out the following code as demonstrated below and refresh the html page.</p><pre id="2496585a-d606-4743-8adb-32b20b606748" class="code code-wrap"><code>// const propertyToCheck = prompt(&quot;What do you want to check?&quot;);
// console.log(propertyToCheck);
// console.log(wes[propertyToCheck]);</code></pre><p id="96780a06-ca55-479c-a57f-df162007491a" class="">In the console, you can write <code>wes.age</code> and the age will be returned, however you cannot type <code>wes.cool-dude</code> for example because they are invalid property lookups.</p><p id="56119daf-61c8-404e-a0cc-4c5e13bd6913" class="">So if that is the case for all three of those properties, (<code>777</code>, <code>really cool</code>, <code>cool-dude</code>) you would have to use square bracket notation to access them.</p><p id="e14691f8-db7f-45de-b228-2e0793664284" class="">So why is that there if it&#x27;s not really a good idea?</p><p id="492ceeb0-e12b-433e-8619-121dbfebbd52" class="">Well sometimes you get data that comes from another language, or you get data that comes from serverside. If that&#x27;s the case, you don&#x27;t really have a whole lot of options so you have to use the square bracket notation in order to reference it.</p><p id="e8c3bdda-5ff2-4c5e-9d7b-b4a023699166" class="">To reference multiple levels deep, it&#x27;s the same.</p><p id="d1d6e88e-35cb-4b34-8523-a08effe64089" class="">For example you would write <code>wes.clothing.pants</code> to return the value of the pants property within the children object that is nested within the wes object.</p><p id="8c8b6af8-03df-4bf9-90d7-923b7c8dbd1b" class="">The only gotcha there is if you try to access a property on an object that does not exist, such as <code>wes.jobs</code>, it will evaluate to <code>undefined</code>.</p><p id="4d6bab3f-4b64-4a9c-8be0-228a440f195b" class="">However, if you try to access a nested property on a property that does not exist, it will throw an error 👇</p><p id="c7816da0-3d3d-4bd8-9910-98c97fc898b5" class="">This is a very common error 👇</p><blockquote id="254ff1f5-188f-44cb-8793-deb431842692" class=""><p id="06324818-e05a-495b-bd4b-c1a92e330829" class="">Uncaught TypeError: Cannot read property &#x27;main&#x27; of undefined at <code>&lt;anonymous&gt;</code> :1:10</p></blockquote><p id="2b511e4d-8971-41b3-b50b-41ff5c4aead0" class="">That is because there is no property that exists on that <code>undefined</code> value.</p><p id="bad5290f-8bb3-4929-bb1f-2a2b2a63cc65" class="">Because <code>wes.jobs</code> is <code>undefined</code>, there are no properties that live inside of that.</p><p id="f78a4c46-522d-4ed8-ad64-b1705d455785" class="">If that is the case, the you have to write the following to not throw an error 👇</p><pre id="6a7a4b5a-8a5b-48ad-9741-14974569e840" class="code code-wrap"><code>wes.jobs ? wes.jobs.side : &#x27;Jobs doesn&#x27;t exist`;</code></pre><p id="b1a57222-6781-479c-8de8-177ed03713ee" class="">There is a proposal and hopefully it will be out soon, which will allow us to do a deep check.</p><p id="a9daee97-973e-4a4c-8be6-bcc2a22dec4a" class="">It will allow us to do something like this 👇</p><pre id="16958415-2c43-4eb8-8b36-7d1567afce17" class="code code-wrap"><code>wes?.jobs?.side</code></pre><p id="a23a3fb3-7ed7-483e-bcd0-5dadadc7a40f" class="">What that would do is the code would say does <code>wes</code> object exist?</p><p id="33eeb21a-a1f2-48a8-8b1b-ab2f2095458d" class="">If so, check is the <code>jobs</code> property exists, and if so, get the value of <code>side</code>.</p><p id="54d8904e-0c10-40cb-a95d-d6b2f8ebde33" class="">That would allow us to do many layers deep.</p><p id="e3b908e2-6db8-4396-b25a-1139fcc40438" class="">It is often the case that we have to write code like this to safely check for the existence of a nested property 👇</p><pre id="ab29a344-287a-48cb-8022-d99f37c69953" class="code code-wrap"><code>if (wes &amp;&amp; wes.jobs &amp;&amp; wes.jobs.first) {

}</code></pre><p id="4b1c659d-2853-41ca-adee-ee8e52ff5706" class="">Sometimes you don&#x27;t know if any of the properties exist and instead have to check one by one or else you will run into the &quot;cannot read property of undefined&quot; error.</p><p id="9dfa1519-d0a2-4ecf-8897-f450271761a4" class=""><em>NOTE: This currently does not exist. If you wish to see the status of it, search &quot;Optional Chaining MDN&quot;.</em></p><p id="e0ac30a3-befb-4272-9307-4dfbd708ae71" class="">You will often use an if statement like that when you are using inputs.</p><p id="e7552446-0c29-41c1-b898-37235b2cd26f" class="">To demonstrate, add the following code right after the opening body tag 👇</p><pre id="57e860a6-9a88-42ff-bd72-bb1c952997a2" class="code code-wrap"><code>&lt;body&gt;
&lt;input type=&quot;text&quot; name=&quot;first&quot;&gt;</code></pre><p id="287e554f-9b3b-4132-a829-33e861cf5b53" class="">If you refresh the HTML page, you will see the input on the page 👇</p><p id="7ca6ebba-04f1-45c9-a7f9-b1d32d346b5c" class="">Often what happens is we will try to select that input from the form as shown below.</p><pre id="52926b77-76ca-4565-98a6-de685c5cf41c" class="code code-wrap"><code>const nameInput = document.querySelector(&#x27;[name=&quot;first&quot;]&#x27;);
const name = nameInput.value;
console.log(name);</code></pre><p id="39184256-ee21-4981-a74b-48cf1c347a6d" class="">Set a value on the input so that it is there on page load by modifying the code like so 👇</p><pre id="b6fb2626-f0b9-4fee-b930-1ea0b04df52d" class="code code-wrap"><code>&lt;input type=&quot;text&quot; name=&quot;first&quot; value=&quot;Wes&quot; /&gt;</code></pre><p id="3000034e-77d9-4424-9fff-e635bcc57081" class="">When you refresh the page, you should see &quot;wes&quot; in the console.</p><p id="62d80f64-f7fb-4b0e-bb32-ec6be5756e37" class="">However, if you comment out that input and then refresh the page, you will get an error</p><blockquote id="57a1c4a6-228d-4b1c-9335-8d6006565882" class=""><p id="fc087391-e879-4dca-a5b4-e2c9576ecd64" class="">cannot read property value of null</p></blockquote><p id="0b019c0f-cb3f-4fa4-9709-f474a22ba3b4" class="">Why does that happen?</p><p id="00bbd3f8-2b41-4473-87c4-d024b0f85f68" class="">Because you are assigning to the variable <code>nameInput</code> an HTML element that does not exist so <code>nameInput</code> is null.</p><p id="f858fdbd-8614-4d4c-a2e0-35dc7a58659d" class="">And then it checks for a property called <code>.value</code> on it.</p><p id="006a0939-4729-401c-9957-4c2f469fd723" class="">So if that were the case (and you run into this all the time), you have to do the following 👇</p><pre id="03f02827-2ab9-495e-86d7-69bf47adff3f" class="code code-wrap"><code>if (nameInput) {
const name = nameInput.value;
}</code></pre><p id="c046a3f4-4f8d-4dc5-9ff1-c1317995c4a5" class="">However there you are making a scoped <code>const</code> variable which isn&#x27;t very useful because it cannot be used outside the if block.</p><p id="69ddc072-4308-404a-923e-d13780949ff2" class="">To fix that you could do 👇</p><pre id="43ef260e-674d-45ad-826f-6ce77911e61b" class="code code-wrap"><code>const name = nameInput? nameInput.value : &#x27;&#x27;;</code></pre><p id="81ac024f-fda3-4526-b32c-59fcabd8731f" class="">That code is first checking whether <code>nameInput</code> exists.</p><p id="95dac32b-0fb6-451b-a422-dfb56fe08380" class="">If it does, it gets the <code>value</code> property on it, and if it doesn&#x27;t, the name variable evaluates to an empty string.</p><h3 id="058b6df4-f513-43f0-b498-f45f28ec8d9d" class="">Deleting a Property from an Object</h3><p id="f8ff467e-3b66-478b-8fe6-cc1f6eb0ca9c" class="">To delete a property object you use the <code>delete</code> keyword.</p><p id="6ad6657b-f0e2-4596-a679-18e24dc00edd" class="">For example <code>delete wes.job;</code> will delete the job property.</p><p id="56edfbd0-cd5f-43e2-a380-e53a89d01a59" class="">If you are curious if it worked or not, you can save the result in a variable or simply log it and a delete will either return true or false based on whether it is deleted or not.</p><p id="8f2fff34-0db5-404e-95ea-a0d7752a58cd" class="">Add the following code 👇</p><pre id="b2439216-4630-4859-8d80-12b350eda7fa" class="code code-wrap"><code>console.log(delete wes.job);</code></pre><p id="bd28c6cd-214b-49fa-a69f-1695e3b48d69" class="">Now if you take a look, you will see it is <code>undefined</code>.</p><p id="51f3506b-1be0-410d-adb4-f2baf55763d5" class="">Sometimes you will also see people setting values to be <code>null</code> or <code>undefined</code>, for example <code>wes.age = undefined;</code> or <code>wes.age = null;</code>.</p><p id="da4ab1fb-97ab-428a-9757-8341bd2edbda" class="">Those are not deleting the properties, they are simply setting them to be <code>null</code> or <code>undefined</code> (in some frameworks that will allow the code to just skip over it).</p><h3 id="69fac02f-00e6-44ff-b054-5d2e8077dd24" class="">Methods</h3><p id="fd1e5354-171d-497d-bee8-b6824edae893" class="">Now, let&#x27;s talk about methods.</p><p id="712076f9-ad3b-45d5-9149-f1da8ff619ce" class="">We have already talked a lot about this.</p><p id="f81f8b3d-8e01-4612-b3e1-809aecafd802" class="">As we went over earlier, the difference between a method and a function is that a method is just a function that lives inside of an object.</p><p id="38fb6793-7b64-423f-bfa0-7718135deb40" class="">That is all we have learned so far.</p><p id="1334bb1b-b562-4cfc-a3ff-a594a62f631b" class="">If you go back to the <code>wes</code> object and add a property <code>sayHello</code>, and you can set it to a function, and that function could take in a greeting if you want <em>(the function works the same as any function that you would have)</em> and from that <code>you</code> could return the greeting in a string and then the <code>name</code> like so ;po</p><pre id="2250b6a2-1dba-4afc-b421-a8c1206321f6" class="code code-wrap"><code>const wes = new Object({
  name: &quot;wes&quot;,
  propertyToCheck: &quot;NEVER&quot;,
age,
&quot;cool-dude&quot;: true,
&quot;really cool&quot;: false,
&quot;777&quot;: true,
  dog: &quot;snickers&quot;,
  clothing: {
    shirts: 10,
    pants: 2
},
sayHello: function(greeting = &quot;Hey&quot;) {
return `${greeting} ${this.name}`;
}
});</code></pre><p id="14ed369c-3c64-4283-8aae-442aa0b0ceae" class="">Now if you refresh the page, open the console and type in <code>wes.sayHello()</code>, you should see &quot;Hey Wes&quot; in the console.</p><p id="8c72132d-b816-467b-befc-0369d4ba733d" class="">You can also try passing in a greeting as shown below, which would return &quot;Hello wes&quot;.</p><pre id="e3b35d31-5726-40ca-9ca3-d6b421619566" class="code code-wrap"><code>wes.sayHello(&#x27;Hello&#x27;);</code></pre><p id="9c0e0398-a92b-42ec-ad1f-51d7714f96a8" class="">You may be working what is the <code>this</code> keyword that you use in the <code>sayHello</code> function when you call <code>${this.name}</code>.</p><p id="2e79501a-615b-4d5a-8b98-812c80c6b16a" class="">Like we have mentioned in the past, when you take a look at a method, and if you look to the left of the dot, <code>this</code> will always be equal to the left of the dot.</p><p id="fd866ac6-e6f0-407a-8a62-fc550c340842" class="">So in this case, <code>${this.name}</code> is going to be equal to &quot;wes&quot; because that is the value of the <code>name</code> property on our object.</p><p id="ee6a3b70-faba-49dc-91bf-e5f30113aa32" class="">You can access the other properties using the <code>this</code> keyword too.</p><p id="9c5424f9-cbd7-46e0-8eb2-cda4194a5de2" class="">The reason you use the <code>this</code> keyword instead of using <code>${wes.name}</code> within the <code>sayHello</code> function is because when we get into <strong>prototyping</strong>, you are going to see how you can use methods like <code>sayHello</code> on multiple people rather than just on a person named wes.</p><p id="abb891de-1030-43df-acdb-a5c3d2a9dbea" class="">You could create a <code>person</code> object that is a new instance of Wes or Scott and Kate etc.</p><p id="861347c4-3b6c-4460-a459-e89fdc4631f1" class="">In that case, the <code>sayHello</code> method will exist on all of them, and you can reference the current person&#x27;s name using <code>${this.name}</code>.</p><p id="6c96b423-ad92-480c-97df-eeb2bb3a3c94" class="">We will get into that a lot more in the future once we get into prototypes.</p><p id="0221a2c2-f3a4-4ce2-8dd7-bd776caff261" class="">For now, just know that when you have a function as a property on an object, that is referred to as a <em>method of that object</em>.</p><p id="dfedbf66-0698-4d25-aa80-5b3e18e49caa" class="">There also is a method shorthand that consist of taking the <code>function</code> keyword away and the colon like this 👇</p><pre id="9a83ef65-6c2b-48ed-a0b0-89d7ec66cf40" class="code code-wrap"><code>const wes = new Object({
  name: &quot;wes&quot;,
  propertyToCheck: &quot;NEVER&quot;,
age,
&quot;cool-dude&quot;: true,
&quot;really cool&quot;: false,
&quot;777&quot;: true,
  dog: &quot;snickers&quot;,
  clothing: {
    shirts: 10,
    pants: 2
},
sayHello(greeting = &quot;Hey&quot;) {
return `${greeting} ${this.name}`;
}
});</code></pre><p id="f2da7030-5c10-4ebc-8bf0-2461ccc595a8" class="">That is just a shorthand, it does the exact same thing. It is <strong>not</strong> an arrow function.</p><p id="cc015f9d-0d4c-4761-ab51-ce2511a8c8ef" class="">However, you can add arrow functions.</p><p id="b61c4de4-af1b-4457-a569-42ce3c73e232" class="">Let&#x27;s add another property called <code>sneeze</code> like so 👇</p><pre id="5c8e4ea5-87ad-4af7-98cb-9431e2cc525f" class="code code-wrap"><code>sneeze: () =&gt; {
console.log(&quot;AHHHH CHOOO&quot;);
}</code></pre><p id="e1a226a0-6c97-4782-9004-7db62a3c347f" class="">That is still a method, however because it is an arrow function as a property on an object, we do not have access to the this keyword.</p><p id="fc2b69f0-c486-4ef0-9599-c650f34a3fa7" class="">If you also try to console log the <code>this</code> keyword like so, you will see it evaluates to window.</p><pre id="0437e7d0-f394-4fcf-947a-c017eae17150" class="code code-wrap"><code>sneeze: () =&gt; {
console.log(&quot;AHHHH CHOOO&quot;, this);
}</code></pre><p id="8c3f100f-2c05-49a2-8fbd-1c3ac283550e" class="">If you were to change that, to a regular function, <code>this</code> would be equal to wes.</p><p id="e9a3acbc-0329-4980-8b6f-55086bcb2200" class="">We will go into why that is later but the short answer for now is that arrow functions do not scope <code>this</code> to the thing they are called against, and the parent scope will inherit that.</p><p id="0484809b-319c-4c57-97c2-65a2245350ac" class="">That is a high level overview of what objects are.</p><p id="b381859b-2ffd-41e6-8cd9-e063dedb5772" class="">In the next few videos we will get deeper into things you need to know, such as little gotchas before we can then dive into arrays.</p><p id="9e20b705-70f1-4f8e-a92a-ac3830a6b80e" class="">Find an issue with this post? Think you could clarify, update or add something?</p><p id="d891c990-8c2c-413f-9851-14d8cd34fc91" class="">All my posts are available to edit on Github. Any fix, little or small, is appreciated!</p><p id="e880b33f-ea1c-4223-8e6f-b6b42b3bb0e8" class="">Edit on Github</p></details></li></ul><ul id="cdd48ac0-c5ea-46f8-b75d-e72e64232250" class="toggle"><li><details open=""><summary>43 - Object References vs Values</summary><p id="8d4131ae-eda4-4cda-92dc-3f7542d2a20f" class=""><a href="https://wesbos.com/javascript/08-data-types/object-references-vs-values">https://wesbos.com/javascript/08-data-types/object-references-vs-values</a></p><p id="3e8e0974-cdad-40a3-bfc6-d671ce7fd0da" class="">
</p><figure id="71812441-29e4-40e1-a949-e7820a507696" class="image"><a href="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/bjs%201.png"><img style="width:700px" src="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/bjs%201.png"/></a></figure><p id="9f709268-b194-46db-bea8-69a1603c5e73" class="">Enjoy these notes? Want to Slam Dunk JavaScript?</p><p id="758d519d-aaa8-4573-a07b-3a6a47c5a2af" class="">These are notes based on my <a href="https://beginnerjavascript.com/">Beginner JavaScript</a> Video Course. It&#x27;s a fun, exercise heavy approach to learning Modern JavaScript from scratch.</p><p id="1a46a416-be6c-448d-ae7e-25f172b7e579" class="">Use the code <strong>BEGINNERJS</strong> for an extra $10 off.</p><p id="d62e3e7d-33fe-4ab8-a398-a541a6927e1b" class=""><a href="https://beginnerjavascript.com/">BeginnerJavaScript.com</a></p><p id="2bb854f0-ca5b-4944-8d8a-e28ecaa6532b" class="">JavaScript, Data TypesEdit Post</p><p id="aeb3ce26-fc75-40fc-8fcb-9f864f4cb47c" class="">An important thing to understand in JavaScript is the difference between a <strong>reference</strong> and a <strong>value</strong>.</p><p id="eb4cb61e-5819-4a3b-bbec-06bbcd8301ca" class="">We will use an example to highlight the differences.</p><p id="9a2e58a8-5093-435e-9e8f-6c753f77725a" class="">Let&#x27;s say you have the following 2 variables, both assigned the value of &#x27;wes&#x27; 👇</p><pre id="00ee2c29-2bb5-4ed1-a0aa-438583e95d8d" class="code code-wrap"><code>let name1 = &#x27;wes&#x27;;
let name2 = &#x27;wes&#x27;;</code></pre><p id="6352d299-da93-4fde-81ea-962f89246762" class="">You can check if those variables are equal by adding this line of code <code>console.log(name1 === name2);</code>, which should return true because both values are identical in both value and type.</p><p id="71e67ff0-1caf-4b71-9837-abaf58c98a6f" class="">However, what if you assign <code>name1</code> the value of &quot;scott&quot;, and then check if they are equal like so? 👇</p><pre id="a76b24c4-3878-4f6e-8371-1e93774dce18" class="code code-wrap"><code>let name1 = &#x27;wes&#x27;;
let name2 = &#x27;wes&#x27;;

console.log(name1 === name2);
name1 = &#x27;scott&#x27;;
console.log(name1 === name2);</code></pre><p id="221f25a2-56eb-489e-a5b6-eebe8c8111fd" class="">That will return false, which is no surprise.</p><pre id="94e66a43-589e-4aa2-9173-1b5c58f12bf1" class="code code-wrap"><code>name1 = name2;</code></pre><p id="1785ef52-98b3-45c8-b185-c7c878869ea1" class="">Now, the question is, what if you set <code>name1</code> to equal <code>name2</code> as shown above 👆?</p><p id="92aa8c86-90fc-487a-aea7-22600b2711eb" class="">If you log again to check the comparison, it will return true.</p><p id="3926f661-cdfe-4c2f-b3c3-51f43b556dc7" class="">If you check the value of each variable, <code>name1</code> and <code>name2</code> will both return &quot;wes&quot;.</p><figure id="3d09a3c4-60da-415b-8fd4-5cbfbabcf670" class="image"><a href="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/467.png"><img style="width:700px" src="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/467.png"/></a></figure><p id="ba135902-504c-4039-84d0-f357418d7632" class="">If you were to take <code>name2</code> and set it to <code>name1</code>, that is the same thing, both values would still equal &quot;wes&quot;, like so:</p><pre id="d494fed9-85ca-4c49-b7d3-52ee47b175a5" class="code code-wrap"><code>name2 = name1;</code></pre><p id="08c40a06-3ff1-42c3-9845-eb6abe9ac63b" class="">Now the question is, if you change <code>name2</code>, like so <code>name2 = &#x27;westopher&#x27;;</code>, will <code>name1</code> and <code>name2</code> still be equal?</p><p id="a83b7b7d-f967-4db7-8815-b1a45e34c0d7" class="">You can check what both variables evaluate to by typing them into the console.</p><figure id="9394d36b-1c0c-4397-82fa-79cd9044fa54" class="image"><a href="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/468.png"><img style="width:700px" src="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/468.png"/></a></figure><p id="157802d5-4c1c-4fcd-802c-6fbdb709d5fc" class="">You will notice that <code>name1</code> is still &quot;wes&quot; while <code>name2</code> is &quot;westopher&quot;, because we have not updated <code>name1</code>.</p><p id="9d04a877-53f8-47f6-b61f-322710b3dd73" class="">So there are a couple of things to note in this exercise:</p><ul id="8700f086-7e1e-40fb-9dd9-f208b5314967" class="bulleted-list"><li style="list-style-type:disc">The triple equals checks that both the type and the value are identical.</li></ul><ul id="743ae744-32ee-49f3-8c6b-63f04338657a" class="bulleted-list"><li style="list-style-type:disc">When the set one string variable to be another, the value is copied from one to another. Meaning that when you take <code>name1</code> and set it to <code>name2</code> (<code>name1 = name2;</code>), it just takes the value of <code>name2</code> and pastes it to <code>name1</code>.</li></ul><ul id="ce587342-ae55-44c8-a551-4b27ad103ac7" class="bulleted-list"><li style="list-style-type:disc">When you update one of the variables, the one pointing to it does not update itself. You may be saying duh, obviously, that&#x27;s how variables work. But now we will go over how that works for objects, because the example we did was with a string.</li></ul><p id="d6eb807c-8076-4dd6-bb7a-6d5064dcfdbc" class="">Let&#x27;s demonstrate this with an object now.</p><p id="0dcfc65d-77ce-4269-a45d-8be214e97af8" class="">Create a <code>person1</code> variable and assign to it an object with <code>first</code> and <code>last</code> properties like so 👇</p><pre id="b4e5484c-d081-4c05-a1be-91749f90e41a" class="code code-wrap"><code>const person1 = {
  first: &quot;wes&quot;,
  last: &quot;bos&quot;
};</code></pre><p id="ae178fe1-4916-42d1-8162-b2aa75f31b53" class="">Duplicate that code by copy and pasting and renaming the variable to <code>person2</code>.</p><pre id="b2cfd125-f8ce-4722-a137-5e5cdc2cf4c0" class="code code-wrap"><code>const person1 = {
  first: &quot;wes&quot;,
  last: &quot;bos&quot;
};

const person2 = {
  first: &quot;wes&quot;,
  last: &quot;bos&quot;
};</code></pre><p id="b689233f-4bf6-4f86-82bc-f803c02f5fb0" class="">If you refresh the HTML page and open the console, if you try typing in <code>person1 === person2</code> you will see it is returning false.</p><p id="f8a2bffa-2db8-49d0-bbb7-771683d5e6e6" class="">Why?</p><p id="0d6cbe43-00fb-4a79-a064-55a23b48ae46" class="">You be thinking &quot;it&#x27;s the exact same object. It&#x27;s an objects with the same contents inside of it, so why are we getting false when we are checking them?&quot;.</p><p id="3b1b053f-237c-4e83-b0b2-ab48c03c5e32" class="">That is because when you are comparing objects, it is done by reference to the object itself, not the values inside of it.</p><p id="eb0b5791-40d9-4115-97ef-5fbeb376592e" class="">So in our example, <code>person1</code> and <code>person2</code> are both objects with the same contents inside of them, but they are not the same because they are not the same object.</p><p id="4dfbb3c7-0aac-41cc-b4a8-3abb09aeb612" class="">That is difference from the contents of a string because a string can only have a value whereas an <strong>object</strong> and, as we will learn, <strong>array</strong> can have multiple things inside of them, whether they are property and values, or just straight up items.</p><p id="2a9e86e2-8590-4b3f-8307-76e726ca52c3" class="">Next thing we need to know about objects is that if you make a new <code>person</code> object like so 👇</p><pre id="df23d3f7-0bee-4f8a-bbe4-3d20dc248d1c" class="code code-wrap"><code>const person3 = person1;</code></pre><p id="42f7df2e-9e62-4e85-a8f3-97bcb1121d22" class="">If refresh the HTML page and look at <code>person3</code> in the console, you should see the following 👇</p><p id="5e1282af-00a3-4ac0-9727-894abb6d760c" class="">Now if you go ahead and update <code>person3</code>&#x27;s name as demonstrated below, what will you see in the console when you log <code>person3.first</code>? 👇</p><pre id="372c7853-0f9f-4226-82ea-2839289ec5af" class="code code-wrap"><code>const person3 = person1;
person3.first = &#x27;Larry&#x27;;
console.log(person3.first);</code></pre><p id="e93a0b03-20c8-4f8d-a138-29f911e2e042" class="">You get Larry.</p><p id="cb7384b6-a0f0-4598-bde4-c77729e401f5" class="">However, what if you log <code>person1.name</code> as shown below? 👇</p><pre id="ddfbd9ba-2c5d-4708-8ecd-ed05b0a3024b" class="code code-wrap"><code>const person1 = {
  first: &quot;wes&quot;,
  last: &quot;bos&quot;
};

const person2 = {
  first: &quot;wes&quot;,
  last: &quot;bos&quot;
};

const person3 = person1;
person3.first = &#x27;Larry&#x27;;
console.log(person3.first);
console.log(person1.first);</code></pre><p id="29d7d400-7849-4d3b-a1ca-875edf41524e" class="">If you look at the person1 object, we have set &quot;wes&quot; as first and &quot;bos&quot; as last. So <code>person1.first</code> should be Wes, right?</p><p id="db8de69d-dcd7-4358-b0fd-04b3f67cd3b4" class="">WRONG! It returns Larry.</p><p id="9986bcff-5365-4510-b8b9-aeec04d3475f" class="">If you try typing <code>person1</code>, <code>person2</code>, and <code>person3</code> in the console, you should see the following returned 👇</p><p id="c6bc4cdb-58cd-430c-a9fe-2f5827df6b2f" class="">What is going on there?</p><p id="ade07ed8-9d44-41c7-8dc9-9c91d0fb0e29" class="">You just updated <code>person3</code>, but for some reason, <code>person1</code> was updated as well.</p><p id="dc5a7ae5-e482-47a1-bdd9-0795b86ebe13" class="">In the console, let&#x27;s try updating <code>person3.last</code> like so: <code>person3.last = &#x27;Cool&#x27;</code>. So <code>person3.last</code> should now return &quot;Cool&quot;, but what about <code>person1</code>?</p><p id="5cf15add-5f62-495d-b933-b1af4c2e4a4b" class="">So what the heck!? Why is <code>person1</code> being updated?</p><p id="17c236d7-f460-4a2a-9b58-2a2da23bbbba" class="">The reason that it happens is a fundamental concept of JavaScript, that will come and bite you in the butt if you don&#x27;t understand it.</p><p id="2f4e042b-12a4-4c11-b13c-219ffd454c7c" class="">The reason that it happens is that when objects and arrays are copied by reference, (like you did with <code>const person3 = person1;</code>), you are not taking a copy of it.</p><p id="c4e43e14-0721-40a8-bc5f-b810465623ad" class="">You are simply creating a variable that references, or points to, the original variable instead of making a copy of it.</p><p id="5fbcbe12-0024-479e-933b-b2704eb2e247" class="">That can lead to unexpected bugs down the road because you might think you&#x27;re simply creating a copy of it, and then modifying it, but you are not.</p><p id="825f8ed7-ada6-43bd-913b-49fa3995eabf" class=""><code>person3</code> was never it&#x27;s own object, it was just pointing at the original object.</p><p id="9a20aeb7-ccd7-4642-b3ae-b04a5142c6c2" class="">The same thing works with Arrays and Maps and Sets which we will learn in the future.</p><p id="a3202b73-e205-4c74-bd22-50809829b690" class="">So what are your options as a developer when you want to take a copy instead of referencing?</p><p id="e05f3bfa-debf-4cee-9b4b-a78dbf4a431d" class="">There are a couple of different ways you can copy an object.</p><h2 id="12534779-403c-46b2-b842-3bc206f6a93f" class="">Spread Operator</h2><p id="32fc1f0c-0a42-43e9-8a16-6caefba1d13c" class="">The easiest way to copy something is via something called a <strong>spread</strong>.</p><p id="6b962e25-bb19-4396-bf59-074dd9a272b3" class="">A <strong>spread</strong> is a three dot operator and it&#x27;s used for taking every single item in a object and spreading it into a new object.</p><p id="1f4416a7-2668-47eb-9a9a-a635e5f8c4ee" class="">So instead of doing <code>const person3 = person1;</code>, you would do something like this 👇</p><pre id="9fd5e95e-c9f5-4d6c-8a9c-144b3c805f66" class="code code-wrap"><code>const person3 = { ...person1 };</code></pre><p id="508b55e9-8a7b-40a9-8d0c-b18ed31f674d" class="">What you are doing there is you are assigning the variable <code>person3</code> to a new object using the object literal syntax, and then using the spread operator within the object literal to copy <code>person1</code>.</p><p id="eb6e1ecd-85df-46d0-8bff-1f565291f594" class="">If you log <code>person3</code>, you will see that it has the same properties as <code>person1</code>.</p><p id="552db2d6-ff22-43b5-ab1f-9d725428bcb7" class="">That is because the spread operator will take every single item that is in an object and spread it into the next object.</p><p id="a6689b4d-ccfb-4f07-aa18-a49c56de6eed" class="">There is another way to do this, which is not as popular since spread has been introduced, but previously a lot of people used this method.</p><p id="e7fd4553-bf1d-4459-8594-dc613d7caaf2" class="">You call <code>Object.assign()</code>, and start with an empty object, and then fold in the other object into it.</p><pre id="6037d629-8f3c-4b57-b0ba-cb1d69353a8d" class="code code-wrap"><code>const person3 = Object.assign({}, person1);</code></pre><p id="05e41fd0-effe-487a-967c-d46ac46c8344" class="">You probably won&#x27;t see that all that much but if you do, know that is a way to take a copy of an object just like the spread.</p><p id="155cdabc-fc21-48e8-908d-a6a721b0afa8" class="">So if you use the spread operator and then try to change the value of <code>person3.first</code> to Larry, like so, what would you get?</p><pre id="a2632075-ae8f-4181-a5cb-7cb78b011cea" class="code code-wrap"><code>const person3 = { ...person1 };
person3.first = &#x27;Larry&#x27;;</code></pre><p id="caffc107-e9c1-466b-bbd4-261232076acc" class="">If you refresh the HTMl page and then log <code>person3.first</code> and <code>person1.first</code>, you will see that only the value of <code>person3.first</code> was updated.</p><p id="fa3ad411-681f-4514-9ae1-81d37b807407" class="">That is because this time you used the spread operator which gave you a copy of the person1 <code>object</code>, and not a reference.</p><p id="47d6176b-7e64-4fd8-af19-3522370d2cad" class="">One thing to do note is that the spread operator only goes one level deep.</p><p id="e8864121-99e0-4051-a468-a5108e47c347" class="">That means that if you went up to <code>person1</code> and added a <code>clothing</code> object, then take a copy of that in <code>person3</code> like so 👇</p><pre id="5b995aa2-dfbd-4216-8b99-f82c60b59605" class="code code-wrap"><code>const person1 = {
  first: &quot;wes&quot;,
  last: &quot;bos&quot;,
  clothing: {
    shirts: 10,
    pants: 2
}
};

const person3 = { ...person1 };
person3.first = Larry;</code></pre><p id="101829f6-e096-4e41-80f4-3622ed123ab8" class="">If you try to update <code>person3.clothing.shirts = 100;</code> and then view the object in the console, you will notice that <code>person3.clothing.shirts</code> does equal 100.</p><p id="903b8308-a2f3-4324-b762-f6b7b41e6140" class="">However if you look at <code>person1</code>, you will notice that <code>person1.clothing.shirts</code> was also updated to be 100.</p><p id="783dbfc5-171e-44b6-b510-36253be2fb3d" class="">This is the same problem. <code>person1.clothing.shirts</code> was also updated even though Wes just told us we can take a copy of an object with a spread operator.</p><p id="bdde0835-c077-408e-a681-8bf0471ba31e" class="">So what we need to take away from that is that the spread operator and the <code>Object.assign()</code> operator, they do what is called a <strong>shallow</strong> copy, meaning that they will only ever go one level deep when copying.</p><p id="adee9949-377b-4249-b936-b4099c0fb0e8" class="">If you do want to do a <strong>deep clone</strong> or a <strong>deep copy</strong> of an object, of all of the properties, there are a number of different ways to do it.</p><p id="108d4980-327b-4c0b-91b5-6dfb06fe7494" class="">The most popular way is most likely to use something called a <strong>utility library</strong>.</p><h2 id="5671ebd7-d0d6-4adb-a8f5-6960ca17ddda" class="">Lodash</h2><p id="97aff49a-21c4-4ee2-82ac-5ef6809dbb1b" class="">Wes most often uses https://lodash.com.</p><p id="4a4f083a-6c0f-4f93-a66c-b8052075d759" class="">Lodash is a library that you can include into your script.</p><p id="a8bd84ac-b1d3-4760-93bc-3b18447f69ed" class="">It has a lot of methods that are used when working with objects and arrays. One of those is for doing copies of objects. Let&#x27;s take a look at the documentation by searching for the keyword clone on the website.</p><p id="809cec24-2d9a-49ba-8dd2-0bb327e106f2" class="">Based on the documentation you can see that <code>_.clone(value)</code> creates a shallow clone of a value.</p><p id="befbdda4-7cac-4d17-a7b3-b0341251cda2" class="">The documentation also provides an example of how to use the method. You would use it by calling <code>_.</code>, which is where all the lodash methods live, and then calling <code>.clone()</code>.</p><p id="d3b60645-8485-4822-ad6e-444c11e17c1f" class="">That will just do a high level clone like we did with the spread operator earlier, so there is not much value in that.</p><p id="eaaec53a-cbbb-477f-9f92-0911c6f2302a" class="">There is another method called <code>_.cloneDeep</code>.</p><p id="5d2d033f-99a3-42c9-af9c-0e53385416eb" class="">Clone deep will also take a copy of any nested objects for us.</p><p id="9054bc6e-ad27-4afa-93d7-939f69d5341c" class="">How do you use that?</p><p id="42b28ecc-b10d-4597-835d-9a59385e5aed" class="">Wes likes to use something called UNPKG (https://unpkg.com).</p><p id="ca47822d-78b4-437f-aaf7-d19f501d8964" class="">If you navigate to <code>https://unpkg.com/lodash</code>, it will load the latest lodash, so you can just take that url and go up above the script that you need and add it.</p><p id="7bba6ad6-3464-4e13-982b-cbe42da673c1" class="">When you&#x27;re loading JavaScript that other code is dependent on, you need to load that first.</p><p id="a701e0a3-eb3f-4521-905f-2fa9074ad08b" class="">Add the following within the body, after the input 👇</p><pre id="7d8497de-acc3-45f6-821b-d35b12b2ae23" class="code code-wrap"><code>&lt;script src=&quot;https://unpkg.com/lodash@4.17.15/lodash.js&quot;&gt;&lt;/script&gt;</code></pre><p id="80155522-0142-4a1b-a60b-a14542c0b630" class="">Now if you type <code>_.</code> in your console, you will see that all of the lodash values are available to us.</p><p id="9c7f1d89-aa8d-411d-8f6a-6d4ddb29e1e9" class="">Later when we cover modules, Wes will show us how to load just the ones you need, because it&#x27;s unlikely you will need every method in the library but for simplicities sake, we are loading the entire library now.</p><p id="64877fcf-be3b-403d-a593-5f8e43021b4b" class="">Further down in our code, comment out the code where you were copying person1 into person3 with the spread operator, <code>const person3 = {... person1};</code>,.</p><p id="bae5e10f-521d-4e56-a6b7-9f2c45b00833" class="">Underneath it add the following code👇</p><pre id="aaf73ae3-033c-42f6-8e36-936c1a6887aa" class="code code-wrap"><code>const person3 = _.cloneDeep(person1);
person3.first = &#x27;Larry&#x27;;
person3.clothing.shirts = 100;</code></pre><p id="b3e6941c-ef90-4f45-b187-ea6fe2ee14c8" class="">As you can see, <code>person1.clothing.shirts</code> still equals 10, because you performed a deep clone using the lodash method and then modified the value only for the <code>person3</code> object because <code>person3</code> was no longer a reference to <code>person1</code>.</p><p id="55c2c103-bbc2-45b1-93a8-37d71185f8fb" class="">Wes doesn&#x27;t reach for this a lot of the time but that is mostly because the stuff he does can just be done by JavaScript, but when you do have to do harder things like a deep clone, you can reach for a lodash method.</p><p id="42f0536e-d374-47c9-9cdb-60d30d8bbd8c" class="">Lodash also has methods for working with arrays.</p><p id="9ce09f9d-c8ad-4ef1-870b-5f39342be510" class="">The <code>...</code> spread operator is also helpful when working with merging objects.</p><p id="5779f6a6-88da-44f2-8eca-9dba5d9f43fa" class="">To demonstrate that, let&#x27;s do an example.</p><p id="bf2eb53e-1af8-4baf-8963-f60425914d54" class="">Add the following code 👇</p><pre id="1b30ba82-22b1-4536-b15c-695c51382e71" class="code code-wrap"><code>const meatInventory = {
  bacon: 2,
  sausage: 3.
};

const veggieInventory = {
  lettuce: 5,
  tomatoes: 3,
};</code></pre><p id="dabe9b4b-983e-485b-ac06-cb8e3ba6d1cf" class="">So we have these 2 objects, <code>meatInventory</code> and <code>veggieInventory</code>, both of which have 2 properties.</p><p id="8f80ff25-f1af-444c-80b8-6661e0ae76de" class="">You want to merge these 2 objects and the easiest way to do that is to just make a new variable, an object literal, the <code>...</code> followed by one of the objects you want to merge, and then a comma followed by a <code>...</code> of the next object you want to merge, as so on, like so 👇</p><pre id="15ae68b3-6254-422f-b00f-579deef802d8" class="code code-wrap"><code>const inventory = { ...meatInventory, ...veggieInventory };</code></pre><p id="4f58d8d2-df0e-4b6c-b341-27c8ec7557e6" class="">You can spread in as many objects as you want.</p><p id="b488d738-cdab-4378-a51d-522fd3a28813" class="">Now we have a new inventory property which you can see if you refresh the page, open the console and type in <code>inventory</code>.</p><p id="8aabbca8-21ab-4917-92d5-91749acf83ad" class="">You can also put some objects on their own line and add your own values in.</p><p id="23f55756-4129-4e0a-80e8-8c6f2f102a6b" class="">For example you could do the following 👇</p><pre id="d3069b5d-e32a-4fb4-9441-e57751d70e12" class="code code-wrap"><code>const inventory = {
...meatInventory,
...veggieInventory,
  oysters: 10,
};</code></pre><p id="8e6e863e-ff62-4050-b569-963a8466ce1f" class="">And you can see that <code>oysters</code> will be added to it.</p><p id="1659d22d-6ea3-4643-bbe4-d328808000af" class="">You can mix and match the spreading.</p><p id="4268f572-d390-40ac-9769-a15df64e8d02" class="">The only thing you really need to know about that is if there are duplicates (for example oyster could be an oyster mushroom or an oyster from the sea), which one will win out?</p><p id="62fca1cc-6217-45c6-b459-054bd351bf72" class="">Let&#x27;s say you added oyster to <code>meatInventory</code> AND <code>veggieInventory</code> like so 👇</p><pre id="403d82e9-1c12-4b9e-bd93-1103f6602d95" class="code code-wrap"><code>const meatInventory = {
  bacon: 2,
  sausage: 3.
oyster: 10,
};

const veggieInventory = {
  lettuce: 5,
  tomatoes: 3,
  oyster: 15,
};

const inventory = {
...meatInventory,
...veggieInventory,
};</code></pre><p id="746d67fe-2ece-4aba-952b-e1ec12a856b3" class=""><code>oyster: 15</code> wins out. Why?</p><p id="b0174b6d-f56d-4a25-998f-e389387d99f9" class="">Because <code>veggieInventory</code> comes after in the spread, so the order of the spread does matter in this case.</p><p id="3eb20f80-64dd-4446-ba70-2eb1b4a55d35" class="">Similarly, if you were to type in the following code 👇</p><pre id="932f17b9-7562-4215-a377-d732f1f433b8" class="code code-wrap"><code>const inventory = {
...meatInventory,
...veggieInventory,
  bacon: 10,
};</code></pre><p id="1865e40f-02cb-4db7-9ac2-e18162289829" class="">Bacon would be 10 because it would overwrite the value in the <code>meatInventory</code>.</p><p id="ec0938bb-c925-4a8d-9638-56cb4bef3d15" class="">Wes really likes the spread operator. It can also be used for arrays which we will learn about in the array lessons.</p><p id="7b96abad-8142-4b50-969c-f5e5c86372a5" class="">The last thing we are going to hammer home is that the concept of passing in via reference vs copy also applies to functions.</p><p id="79819bad-8b0c-4e85-a884-5d5350971c80" class="">Let&#x27;s say you had a function <code>doStuff</code>, which took in an argument <code>data</code>, and within the function you modified the value of data to be something else, like so 👇</p><pre id="3226f4ea-fbb9-4ede-a2b8-951060b75efc" class="code code-wrap"><code>function doStuff(data) {
data = &#x27;something else&#x27;;
}</code></pre><p id="4d48acaf-024c-4e25-9ce3-5661d871fd62" class="">All this function does is take in an argument, and changes that data for whatever reason.</p><p id="04669d54-c8ae-44dc-ac55-6af02735e938" class="">Now if you were to run that function and pass it the <code>name1</code> variable which was set to &quot;wes&quot; way up in the code, if you were to take a look at that and log the data like so 👇</p><pre id="5fed49aa-1658-4fea-81da-f73fd34d4358" class="code code-wrap"><code>function doStuff(data) {
data = &#x27;something else&#x27;;
console.log(data);
}

doStuff(name1);</code></pre><p id="0f4e191c-874e-413e-8acf-ce59eedbe7f3" class="">If you refresh the page and type in <code>name1</code> in the console, it should still return &quot;wes&quot;.</p><p id="918c8193-21a9-4e47-9e93-97fdbdbea5cd" class="">What that means is when you passed in the <code>name1</code> variable to <code>doStuff</code>, you were only passing in the value of &quot;wes&quot;, it doesn&#x27;t actually reference to the external variable (which is good!).</p><p id="47323a29-6a48-44e2-9b21-13219a804ac2" class="">Now, let&#x27;s do that again with an object 👇</p><pre id="4057bf2b-f484-4c1f-b48e-8e7dc67d395b" class="code code-wrap"><code>function doStuff2(data) {
data.tomatoes = 1000000000l;
console.log(data);
}

doStuff(inventory);</code></pre><p id="2535a49a-462a-4f34-ad3f-749fa601f36d" class="">If you refresh the page and look in the console, you will see the value of <code>data</code> logged as shown above.</p><p id="826f00f3-5d64-45c9-a937-bdee46cf2406" class="">However, if you type in <code>inventory</code>, which is the object that lives outside of the <code>doStuff2</code> function, you will see that it also contains the <code>tomato</code> property.</p><p id="34b350ba-5c3c-4fa0-b6b8-a9ce34ba9d47" class="">That means that if you pass in an object to a function, and you modify that object, the external object will also be updated.</p><p id="e522019b-d69f-46ee-b558-0da36d54fa33" class="">That is not the case for booleans, numbers and strings, but it is the case for objects and arrays.</p><p id="4a9a40a4-39ab-4b25-9481-06087b29e723" class="">That means that if you modify an object or an array that is passed into a function inside of the function, know that you may be accidentally modifying data that lives outside of it.</p><p id="f04394e2-2471-4478-a785-4c0ab376fe59" class="">That is a huge source of bugs, because when you pass in data as a reference, you may be unknowingly modifying data that lives outside of that function.</p><p id="6e49d27d-f6b7-4eee-a1a0-253af905af24" class="">If that is the case, you make sure you pass it in as a copy.</p><p id="87f75da3-0170-4268-8da7-7a56eff3b467" class="">It may be the case that you want to modify external data, but sometimes you don&#x27;t and it leads to bugs.</p><p id="d99f8607-705e-480c-a236-b9f545ce9990" class="">Find an issue with this post? Think you could clarify, update or add something?</p><p id="fece1fdd-a65e-4cf5-8627-9a752f63662e" class="">All my posts are available to edit on Github. Any fix, little or small, is appreciated!</p><p id="b4b78b6b-5919-4983-bc8c-86382e1a07a5" class="">Edit on Github</p></details></li></ul><ul id="1a6625aa-a9bc-4834-addc-6ffc0a529790" class="toggle"><li><details open=""><summary>44 - Maps</summary><p id="e3dc981d-51e8-4f78-a7bf-8de2dcda90b9" class=""><a href="https://wesbos.com/javascript/08-data-types/maps">https://wesbos.com/javascript/08-data-types/maps</a></p><p id="5b72c978-e5e7-4ddc-9925-dd553de623a3" class="">
</p><h1 id="8f291786-c846-4a4d-b0be-e0aaf9477dbc" class="">Maps</h1><figure id="a03e9f32-0bbd-4c50-8205-ee33fe215d63" class="image"><a href="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/bjs%202.png"><img style="width:700px" src="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/bjs%202.png"/></a></figure><p id="be4da09b-2a2e-4f79-ae75-540fcfeb14a5" class="">Enjoy these notes? Want to Slam Dunk JavaScript?</p><p id="6c4f89be-5fca-4783-b2c9-8bb3a14a56a7" class="">These are notes based on my <a href="https://beginnerjavascript.com/">Beginner JavaScript</a> Video Course. It&#x27;s a fun, exercise heavy approach to learning Modern JavaScript from scratch.</p><p id="fcdd4c78-9ed5-4a97-9183-f651f97eeb84" class="">Use the code <strong>BEGINNERJS</strong> for an extra $10 off.</p><p id="d456cbdd-6b35-492f-931e-3ec5e34c3f49" class=""><a href="https://beginnerjavascript.com/">BeginnerJavaScript.com</a></p><p id="1deddd55-47dd-4d42-b6b6-906f18c0af43" class="">JavaScript, Data Types, Maps</p><p id="a6fee477-6adb-48be-9749-8fb89af83edc" class="">In the <code>/playgrounds</code> folder, open up <code>maps.html</code>.</p><p id="dad5ab62-c281-4b8c-b4a5-ebc2c82dc2ce" class="">We are going to learn about this thing called a <strong>map</strong>. It is very similar to an object, however there are a couple of key differences.</p><p id="d12a8043-cdad-43b3-95b3-87564277b9d8" class="">We will cover:</p><ul id="fcef1d67-84e5-421c-8786-6b93a31ef600" class="bulleted-list"><li style="list-style-type:disc">how does it work</li></ul><ul id="853f3d8e-f44d-4cf7-a3ab-fc6862befe08" class="bulleted-list"><li style="list-style-type:disc">what does it do</li></ul><ul id="f38ea073-b0d5-49d8-b39c-653f993559ce" class="bulleted-list"><li style="list-style-type:disc">why you would want to use one over an object</li></ul><ul id="bc3510ea-dcdb-414c-804f-7aab723f46ea" class="bulleted-list"><li style="list-style-type:disc">how to decide whether to use a map or an object</li></ul><p id="2dbc6f5f-fe24-486f-b533-cd0e62917e2a" class="">The way you create a map is using the <code>new</code> keyword followed by <code>Map()</code> with a capital M.</p><pre id="00ceb4aa-1ee0-4941-9b90-ccbc740571ba" class="code code-wrap"><code>const myMap = new Map();</code></pre><p id="d52ff6fa-ff95-4125-90ad-63887bb92a4f" class="">In order to add items to a map, there are the following APIs:</p><ul id="5c5aa21a-9fe1-4b26-8fcc-31b3dcad187d" class="bulleted-list"><li style="list-style-type:disc">set <code>.set()</code></li></ul><ul id="00daeff1-d1a9-4464-ad13-ab09c8feb388" class="bulleted-list"><li style="list-style-type:disc">has <code>.has()</code></li></ul><ul id="b57f7ea8-31d7-4ee1-88e9-06d798bd1ca0" class="bulleted-list"><li style="list-style-type:disc">delete <code>.delete()</code></li></ul><p id="0a1d11ca-cc9e-4b0c-8dd9-8578cf09ba1f" class="">We will go through all of them.</p><h2 id="830754cf-f9bb-44b5-8cb4-68ef4b0b7386" class="">Set</h2><p id="0e5020ce-f520-4c82-9c82-41533dc7840d" class="">Firstly, you take <code>myMap</code> and you <code>set()</code> it, to which you pass 2 arguments:</p><ol type="1" id="240b5a3b-86e8-4a23-a04f-742182624e03" class="numbered-list" start="1"><li>the key of the map will be, so let&#x27;s call it <code>name</code></li></ol><ol type="1" id="ecd49f7b-ea6f-46f9-aebb-4c51954adc37" class="numbered-list" start="2"><li>the value you want to set</li></ol><pre id="cd2db988-1e1c-45e3-94d3-2ca4009f4908" class="code code-wrap"><code>myMap.set(&#x27;name&#x27;, &#x27;wes&#x27;);
console.log(myMap);</code></pre><figure id="b86a5ffb-ef40-4a6d-9b40-d965dba76fb7" class="image"><a href="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/489.png"><img style="width:700px" src="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/489.png"/></a></figure><p id="ce047e19-c706-4ba4-a02b-a44202dbe5bf" class="">As you can see in the console, we have our map and it gives us our entries, entries are the actual values in the map.</p><p id="ac796d9a-e4eb-497d-b2d4-6fc4501f1fb0" class="">Now if you were to use the object notation that we are used to, something like <code>myMap.age = 100;</code>, you will notice that it&#x27;s not actually added in the same spot.</p><figure id="864d4812-34f0-486b-bb8c-5d5a70fd8c33" class="image"><a href="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/491.png"><img style="width:700px" src="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/491.png"/></a></figure><p id="e4b94d81-b16b-4878-88e5-6624eb66d0fa" class="">It is in the map, but it is a property on the map, not an actual entry in our map.</p><p id="851a0aaf-bc86-4cc8-b84c-8db2ae5130a8" class="">So why is this useful?</p><p id="20b2cd75-3ba5-43c4-9505-e977a5b41b2e" class="">Well, there are a couple of nice things about this API, apart from the fact that you have a <code>.set()</code>, <code>.has()</code> and <code>.delete()</code> method.</p><p id="11cdaa5d-21b3-4c61-b679-01d297db48f4" class="">One big benefit of a map is the keys can be any type other than just using a string or an allowed variable name.</p><p id="591e4abe-8817-4c53-a1e8-c03de34e7f47" class="">So instead of passing name as the key when we called <code>.set()</code> on <code>myMap</code>, we could pass a number like <code>myMap.set(100, &#x27;This is a number&#x27;);</code></p><figure id="04ab4560-fd96-421a-a91d-c6fb20080407" class="image"><a href="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/492.png"><img style="width:700px" src="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/492.png"/></a></figure><p id="b320efcb-cd0c-4836-99ab-63c3d2026140" class="">As you can see, the entry has a key of 100.</p><p id="97405300-56a5-46e9-a159-a4d5f306ed36" class="">Previously you have only had the ability to add different types in the value portion of an object.</p><p id="6f1bc822-8c55-458c-a589-b2d6c460e301" class="">A map allows you to put any value into the key and into the value (any type of value).</p><p id="3e2575db-0333-409d-b4cf-fd0a02bd8942" class="">Now why is that useful?</p><p id="170c0d80-38c0-4487-955a-1542f931acaf" class="">In JavaScript, we have these things called dictionaries. A dictionary is just a way to store additional metadata about something else.</p><p id="15369b20-f465-4d52-94b2-34199c654ddc" class="">What is a dictionary in real life?</p><p id="fec0f645-d710-4313-9f08-a61090f6ceb2" class="">Well, if you have word, that word does not contain all the information about how to pronounce it, what it means, whether it&#x27;s a verb or a noun, etc. All of that information about that word is not stored in the word, it&#x27;s stored somewhere else, which is a dictionary and if we want to look that information up, we use the dictionary.</p><p id="e817f1b5-7a2b-45fa-9692-8d88776f0fb6" class="">Let&#x27;s create a variable <code>person1</code> like so 👇</p><pre id="d5a5f5e0-ebbd-4c41-845c-cc782645e1da" class="code code-wrap"><code>const person1 = {
  name: &#x27;wes&#x27;,
  age: 200
}</code></pre><p id="d990019d-eb3f-435b-a52c-497917125b7e" class="">What you can do is use the reference to that object as a key in your map to store additional information inside of your map.</p><p id="47487ae4-61b9-464b-abfa-6067bdd0cf8c" class="">In <code>maps.html</code>, use the reference to the <code>person1</code> object as a key in the map, and let&#x27;s say as the value we will store a string about how cool the person is (this could really be anything, does not have to be a string).</p><p id="de020d14-5b53-4152-8351-c431434d0681" class="">Add the following at the end of the script tag but before you log <code>myMap</code> 👇</p><pre id="60ba4e88-11c5-44fc-bc7c-aae28d820d5f" class="code code-wrap"><code>myMap.set(person1, &#x27;Really cool&#x27;);
console.log(myMap);</code></pre><p id="7cd015ab-a133-4d8e-ab06-b3c6e51b3cdf" class="">Now if you open up our map, you will see that the key is actually an object and the value is really cool.</p><p id="d4e1d1d3-03eb-4a6d-9863-b0d475631fea" class="">That is useful because let&#x27;s say at a later point in time we wanted to look that up in our dictionary, we could add the following code to grab the value:</p><pre id="5e2fdce3-227e-4dde-9fe7-b6bc65e3b4e0" class="code code-wrap"><code>myMap.get(person1);</code></pre><p id="d274edf4-dba7-480f-a28c-1acf22ddfa43" class="">What you have done there is instead of putting a unique string, or an ID or something else, you simply use the reference to the object as the key in the map to store the additional information.</p><p id="2b8fbd08-05e2-4d23-8c24-749475f3d404" class=""><em>Note: all values in a map can be any type, just like the key.</em></p><p id="4479b952-02e2-4043-9847-f22b67e2a65f" class="">Another example you can do is let&#x27;s say someone has a score that they want to add additional information to.</p><pre id="5c6f5a33-8290-4267-a300-993d62e0fbb2" class="code code-wrap"><code>const score = 100;</code></pre><p id="918845bd-2d03-41a1-b1b4-845385812eb0" class="">On the map, you want to set additional information about what prizes they will win at that score.</p><p id="1481aa35-2c42-4814-81a0-868692f379d2" class="">Create a new map for this.</p><pre id="05bd9076-30af-4e1e-8df0-cea3a22844c9" class="code code-wrap"><code>const score = 100;
const prizes = new Map();

prizes.set(100, &#x27;Bear&#x27;);
prizes.set(200, &#x27;Duck&#x27;);
prizes.set(300, &#x27;Car&#x27;);</code></pre><p id="1e054156-2479-4020-8594-fa36418fe234" class="">Now if this was an object, you would have had to use a string of the number in order to look it up. However in this case, we can just use the number to look at what the corresponding prize is.</p><p id="d0e11ec0-273a-414e-a8fd-8c45469d0338" class="">Add a log after the last set on our map 👇</p><pre id="2a31c5c4-71c9-47fd-b29e-623e60737672" class="code code-wrap"><code>console.log(`you win a ${prizes.get(score)}`);</code></pre><p id="38da3211-8de5-442a-8340-be7e28bf3d10" class="">Now if you refresh the page, you will see the following in the console 👇</p><p id="8f36b661-01f0-4a10-a336-cdead4e63f59" class="">this should &#x27;you win a Bear&#x27;</p><p id="12f8d00a-135d-496d-9113-cd3543943371" class="">In a lot of the real world exercises we will build, we will pause and go over whether or not it makes sense to use an object or a map for our situation, so you can get used to when to reach for one versus the other.</p><p id="d9445bb6-209e-416a-a387-81fbd047166a" class="">So far we have covered how to set and get values of a map.</p><p id="bdf549a0-a918-497b-bbb0-d6659ad699d9" class="">You can also get the size of a map using <code>.size</code>.</p><p id="44973f25-eb41-445e-9305-73fa2c026bcc" class="">If you type <code>myMap.size</code> in the console, you it should return 3. This is very similar to getting the length of something.</p><p id="1cbbdb12-c9ee-4181-92d4-dbefb9641b5a" class="">The other thing about a map is that order <strong>is</strong> guaranteed.</p><p id="4294c9e9-3f80-4983-80ce-05218a840064" class="">Unlike an object, with a map, the order in which you put things into your map is the order at which they will stay.</p><p id="373fc3fd-83a9-4d21-ae40-96d98b3b4407" class="">That is very important if you need to maintain the order.</p><p id="ab62df8d-7868-46e7-b496-d1cf879b49a6" class="">Let&#x27;s do an example to demonstrate displaying the prizes using objects vs maps.</p><p id="ee2e9b98-bd54-4f97-9342-ff725eb2e150" class="">Within the body tag, but before the script tag, add the following code 👇</p><pre id="e535c9e1-3e51-49c7-8d78-34ec3d93ba1a" class="code code-wrap"><code>&lt;ul class=&quot;prizes&quot;&gt;&lt;/ul&gt;</code></pre><p id="715109bd-1e2f-465e-b5f3-9a710cb01a2d" class="">Now let&#x27;s say you wanted to loop over the prizes in the map and display what you get for which point value, it&#x27;s important that they go into that order.</p><p id="5aeb50db-0609-4341-a40d-65f2bf8ecd58" class="">With an object, they could be jumbled. It would be weird to display the prizes in non-ascending or descending order.</p><p id="8dbd96b0-fbf8-4e92-94fa-f05ebfe6f81c" class="">But when you use a map, it&#x27;s guaranteed to maintain order.</p><p id="473f59d5-8f0b-4c70-b05a-cfad467c45fe" class="">Now what you can do is select the <code>ul</code>, loop over all the entires in the map (there is a couple of different ways you can do that which we will cover in the looping and iterating lesson), and you are going to get an entry and log it to start.</p><pre id="c8b6006a-efe1-4c0f-84f8-0f8934c78e4d" class="code code-wrap"><code>//s elect that ul
const ul = document.querySelector(&#x27;.prizes&#x27;);

prizes.forEach(entry =&gt; {
console.log(entry);
})</code></pre><p id="2f636851-ea85-4a8d-923e-0b8a7d2e6e46" class="">If you refresh the page and look at the console, you will see Bear, Duck and Car, in that order.</p><p id="c0f1ec43-827a-4862-8e96-3aec672751aa" class="">However, that only gives you the value. If you want to return the key and value, you can use the <code>for of</code> loop.</p><pre id="196e2fb0-c9a4-4376-87c2-614013f36bd1" class="code code-wrap"><code>const ul = document.querySelector(&#x27;.prizes&#x27;);

for(const prize of prizes){
console.log(prize);
}
</code></pre><p id="4d090351-5b1e-4c5a-8ec1-3b10dbf5d1fd" class="">This is getting a bit ahead of ourselves with the looping but just know that you are looping over all the entires in the map, one by one, and for each one you are going to create a temporary variable <code>prize</code> and then log it.</p><p id="f813a746-90da-4375-89ff-bfe022b894fa" class="">Now as you see, you get an array and that array&#x27;s first item will be the key and the second item will be the values.</p><p id="ebaa1366-ecda-482d-b3e3-6cd4e8c1cad8" class="">Modify the log like so 👇</p><pre id="da087dc1-b478-4199-88a8-d48816d378e9" class="code code-wrap"><code>console.log(prize[0], prize[1]);</code></pre><p id="71ef59a7-b69a-4860-9cab-ac5c1f59e2cd" class="">You can go further and <strong>destructure</strong> the array.</p><p id="7e291c80-ef26-4577-81e4-c8bce2e3786f" class="">This allows you to create variables of the items by their index, instead of referencing each via index each time.</p><p id="7901fd8c-8ff9-49a6-ac00-21967585b853" class="">Modify the code like so 👇</p><pre id="9a84904b-0a8b-4e34-955e-7f945f4f8ec8" class="code code-wrap"><code>for (const [points, prize] of prizes) {
console.log(points,prize);
}</code></pre><p id="0ba8d24e-8377-4cea-bf27-a48572a8988d" class="">If you refresh the HTML page and look at the console you will notice it works the exact same. The only difference is now we have 2 variables, one for <code>points</code> and one for <code>prize</code>, rather than accessing the values using the array and their index.</p><p id="dd13b250-f4e9-448c-9c4e-ce0ee7fbe1e9" class=""><em>Note: you could have rename points and prize to anything you wanted.. For example, </em><code><em>for(const [key, value] of prizes)</em></code><em> would have worked just as well.</em></p><p id="7f20f5be-a371-4262-a1b5-e98a340cf218" class="">Modify the code again to display the score 👇</p><pre id="596e0663-5b65-485b-9457-7d349c70d4a1" class="code code-wrap"><code>for (const [points, prize] of prizes) {
const li = `&lt;li&gt;${points} - ${prize}&lt;/li&gt;`;
ul.insertAdjacentHTML(&#x27;beforeend&#x27;, li);
}</code></pre><p id="18926810-ecf9-4d1b-bccf-1295635c9e0c" class="">Now when you refresh the page, you should see the following 👇</p><p id="299793fb-ee1a-481d-a147-625a55a2891c" class="">When do you use a map over an object?</p><p id="263025ae-fedf-485e-936c-19ec159733aa" class="">You should use a map if you do need to maintain the order of your items.</p><p id="af3eb3cc-5ce1-43fe-8b84-a9ded902d88e" class="">One downside to a map is there is no literal, meaning that you always have to create a new map that way and then set the items in it.</p><p id="b7e4c040-6eb3-43cd-a43b-19d1514d4049" class="">You can pass items into your map with an array or arrays, but it&#x27;s kind of weird.</p><p id="c48ec435-28e4-41e7-b71f-fe27e1d6926b" class="">Let&#x27;s do an example.</p><p id="cbe92e12-1b39-412e-9a87-facfd88ccfa5" class="">You pass in an array of arrays. So you have an array which contains many arrays separated by commas like so</p><pre id="5eb8a32b-141e-4af8-83bc-c771b133332d" class="code code-wrap"><code>new Map([ [1,2], [3,4] ]);</code></pre><p id="53f154a9-cdb5-4c07-b797-e2a4aa9cf607" class="">If you type that in the console you will see the following 👇</p><p id="b758ad5f-6412-418f-89f5-efe20a1e474c" class="">As you can see there, we have created a map.</p><p id="3ac81885-5794-429f-b577-f4184c6ef8d0" class="">That&#x27;s a bad example, let&#x27;s do something else.</p><pre id="097b939d-e6c7-4bd1-a823-2dbfccc07a27" class="code code-wrap"><code>new Map([ [&#x27;name&#x27;, &#x27;wes&#x27;], [&#x27;age&#x27;, &#x27;49&#x27;] ])</code></pre><p id="3fea0e5a-991f-4522-b719-b7b8b7753745" class="">You can pass an array of multiple arrays where the first item is the key and the second item is the value. However, the object literal syntax is a little bit neater of an API.</p><p id="4fd40dc6-b407-4ebf-9790-abd2e25da9cd" class="">Wes didn&#x27;t show us delete.</p><p id="86d04b6e-87cc-4bc5-a1c1-07252ed8f049" class="">In the console, if you still haven&#x27;t refreshed from our previous example, type <code>myMap.delete(&#x27;name&#x27;)</code>.</p><p id="b032ef3e-1ab4-4807-b216-7b839dc75a10" class="">If you type <code>myMap</code>, you will notice that the name <code>entry</code> is gone.</p><p id="d7b7ae3d-89d1-4c5a-94b5-2c74bdf2424f" class="">Another thing about an object is you can put functions inside of an object and we call those methods.</p><p id="0ccc8d09-7f1c-4fd4-8ed2-b6dd0706f5dd" class="">You cannot do that with a map, that is not what they are for. They are simply for storing data.</p><h3 id="e1d95e99-cd71-4980-a0de-dbb041948003" class="">JSON</h3><p id="e9160054-93e1-4bed-9f4b-5a66c43bc1a6" class="">The last thing is we have this thing called <strong>JSON</strong>. Wes hasn&#x27;t explained it to us yet but he is going to try really quickly.</p><p id="5beded12-ba8c-4856-afb3-d4e8f22200db" class="">Let&#x27;s say you have the following object 👇</p><pre id="e6ae0f50-2370-412c-bab8-e8478248b315" class="code code-wrap"><code>const person = {
  name: &#x27;wes&#x27;,
  age: 100
}</code></pre><p id="c2cc5231-f06b-4457-a6fd-e7cf49db3148" class="">If you want to send that object to somebody, you would turn it into text. Text is easily sent via servers, from one website to another.</p><p id="1b5542d3-d68f-4e1d-a4b4-aaaca3788453" class="">Anytime you want to transfer an object or an array, you have to first convert that to a portable format.</p><p id="0384668e-37c4-49af-acc1-6ab9541299ac" class="">This one way that all programming languages understand is JSON.</p><p id="415b70ed-d038-4ded-87c3-33197a52fd36" class="">You can turn an object into <strong>json</strong> using <code>JSON.stringify()</code>. It takes in 1 argument, which is the object you want to convert.</p><p id="3c5a937b-bf76-49e0-a971-4c6ec233db07" class="">It takes the object and converts it into a string, which you can send very easily, and then the person on the other end can turn it back into an object using something like 👇</p><pre id="400ab0c2-f8e5-4215-b441-285e8fdf582c" class="code code-wrap"><code>JSON.parse(`{ &quot;name&quot;: &quot;wes&quot;, &quot;age&quot;: &quot;100&quot; }`);</code></pre><p id="ce926a2b-68bb-4078-9701-3d3d1a03326a" class="">JSON stands for <strong>JavaScript Object Notation</strong>. However it has been implemented by every single language out there.</p><p id="aca1a2da-4ef9-4643-9192-3316eef80d96" class="">JSON is amazing, however, if you have a map, currently JSON does not handle maps.</p><p id="90900a64-d11a-415a-b8ae-53d4bfaff37b" class="">If you try <code>JSON.stringify(myMap)</code> you will see the following error and get an empty object because it is not aware of maps yet.</p><p id="71856039-6aed-43e5-bbd0-ef27bbbf054d" class="">There is this thing called <strong>JSON 5</strong> which is trying to improve JSON but until that is ready, if you want to send your map content you have to convert it to an object currently.</p><p id="9b4117b5-6aeb-4b3d-80de-f53c2b770d1d" class="">You can do that using <code>Object.fromEntries(myMap)</code>, which tries it&#x27;s best to convert it to a regular object.</p><p id="88148e75-c94c-474b-9ef4-1a8411ef71a9" class="">However, you will see if you use any of the benefits of a map, it falls apart when you turn it into JSON.</p><p id="dd059ede-8f4f-4dd2-85aa-cc88edd7d95e" class="">We will try to use both of them in our examples but Wes personally uses objects much more frequently, but he thinks map will start to catch on in the next couple of years.</p><p id="cabd6744-699a-42ba-aefc-f1917698faf8" class="">Find an issue with this post? Think you could clarify, update or add something?</p><p id="5a453b41-45ac-44dd-8316-7d0ef0da2da1" class="">All my posts are available to edit on Github. Any fix, little or small, is appreciated!</p><p id="0830852e-0ecc-489e-aae0-5995b2dea3b5" class="">Edit on Github</p><p id="94367b77-5183-48a8-9881-8ba26dca6762" class="">Enjoy these notes? Want to Slam Dunk JavaScript?</p><p id="08e89c7e-36ca-4b0c-8966-bd497baf9b45" class="">These are notes based on my <a href="https://beginnerjavascript.com/">Beginner JavaScript</a> Video Course. It&#x27;s a fun, exercise heavy approach to learning Modern JavaScript from scratch.</p><p id="a403e67e-be4c-4898-ac19-db45289d4dd5" class="">Use the code <strong>BEGINNERJS</strong> for an extra $10 off.</p><p id="fa8ffce5-ce82-4db9-9c4c-469c12ca0858" class=""><a href="https://beginnerjavascript.com/">BeginnerJavaScript.com</a></p><p id="d2029f6b-cce3-4f4f-b6f5-e5eb1ee0c6b4" class="">JavaScript, Data Types, ArraysEdit Post</p><p id="6839c570-e5a1-4139-9f65-58de956fb372" class="">In this video we will be learning about arrays: how to create them, how to add items how to remove items, things like that.</p><p id="aac3d580-35fc-4a2a-8c08-0f5b35c441c7" class="">In the next video we will cover looping over an array.</p><p id="3c54f410-5303-4400-acc8-b927db184e25" class="">What is an <strong>array</strong>?</p><p id="54262fd6-d46a-4225-a017-3dc5ec380f6e" class="">An array is used for holding a list of items where the order matters.</p><p id="acdaec7c-d0eb-402b-81e4-78a1c10efad9" class="">Each thing inside of the array is called an <strong>item</strong> and it&#x27;s position in the array is called an <strong>index</strong>.</p><p id="c78372fd-7675-44ee-9e64-4740dd322095" class="">The number of items inside of an array is called a <strong>length</strong>.</p><p id="02821b6e-12f5-4f1f-8166-83352f6ed4d0" class="">Each item inside of an array can be any type. It can be a string, a number, a boolean, an object, another array, a nested array, you name it.</p><p id="31497618-fd3d-4263-a88e-ed8faf004723" class="">In the <code>/playgrounds</code> directory, open up <code>arrays.html</code>.</p><p id="1166398e-cf54-49c9-8327-5f0575c1649b" class="">Add a script tag inside the body tag (if it&#x27;s not already there).</p><p id="990b6f1e-0388-4ccc-9cc5-0f78e88803b3" class="">We will use an example of a list of names to demonstrate how to create an array.</p><p id="fd596569-685f-45e6-9a91-bd6e8ab911a5" class="">Whereas curly brackets are for an object, square brackets <code>[]</code> are used for noting you are creating an array or an <em>array literal</em>*.</p><pre id="6669efa1-baca-45ae-adc0-4a774d3b6cd4" class="code code-wrap"><code>const name = [];</code></pre><p id="5d139c50-969d-40c1-b091-81eda6f1a8e7" class="">You can also create an array using the long hand, just like you can with a string, a number, an object etc, like so 👇</p><pre id="2af36a7c-22dc-4dcc-900d-7521f7d62567" class="code code-wrap"><code>const names = new Array();</code></pre><p id="e8bc4452-863b-4bc1-84b6-33e65f28fca5" class="">To create items inside of an array you can simply do this 👇</p><pre id="d64813f0-6456-46c0-9a99-f2ab85676bc8" class="code code-wrap"><code>const names = [&#x27;wes&#x27;, &#x27;kait&#x27;, &#x27;snickers&#x27;];</code></pre><p id="13a141b2-27c4-4146-8760-30bde9126539" class="">What you have done there is created an array with 3 items, each of which are separated by a comma.</p><p id="703ed736-78bb-4b20-8d38-901a09f0bcfc" class="">Go ahead and open the page up in a browser and take a look at the array in the console.</p><figure id="e54248fc-6631-4d8c-b56e-2369cf1a14ac" class="image"><a href="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/506.png"><img style="width:700px" src="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/506.png"/></a></figure><p id="3d3419f7-8f95-4e57-8110-7ef45ba0aa38" class="">This is our array.</p><p id="8459fa2c-fbdf-4f06-bd8a-854db639c07e" class="">It looks a lot like an object, but as you can see, it has no keys, which is sort of the main difference between arrays and objects.</p><p id="c535ce31-20c5-4d03-b84e-aaa969b05270" class="">An array has no keys. The keys will always be the indexes meaning 0,1,2,3,4,5..</p><p id="6a83bc2f-2389-47cf-8993-8d5db22c1498" class="">One thing to mention is that if you types into the console <code>typeof names</code>, you would get &quot;object&quot; returned.</p><figure id="b3118054-1ab9-4475-9859-3d4cddbbee64" class="image"><a href="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/507.png"><img style="width:700px" src="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/507.png"/></a></figure><p id="7e320b85-baf0-4fcb-9a5f-15bbef4687b4" class="">You might be thinking &quot;Whhaaattt??&quot; <code>typeof names</code> is an object??</p><p id="d49fbb54-eb23-423e-8e57-69af85257d67" class="">If you recall one of the earlier videos where we went over all the types, you should remember that we didn&#x27;t say that array was it&#x27;s own type.</p><p id="f4ac00db-fbeb-490f-8378-c285458935eb" class="">An array is actually just an object at the end of the day, meaning that it can hold data and have a bunch of methods living inside of it.</p><p id="b1f7edc3-22ea-41d3-9ece-8c911b23bc71" class="">If you do need to check whether something is an array, you can do that like so 👇</p><pre id="72e96c7b-172b-45b0-bf3a-04d11848b9a5" class="code code-wrap"><code>Array.isArray(names)</code></pre><p id="4a89cfd8-3388-43b9-8805-b8c3eb6635eb" class="">That will return true or false depending on whether whatever you pass it (in this case <code>names</code>, is an array or not).</p><p id="37cb2df3-11d7-4099-a62f-f65188ce6b95" class="">That is something called a <strong>static method</strong> which we will learn about later.</p><p id="d2cf79b4-9dcf-4fd8-b64e-081489070a2c" class="">So you have the <code>names</code> array, but how do you access things inside of it? You can&#x27;t access it like you do properties on an object, so something like <code>name.wes</code> would not work.</p><p id="bbc3d370-d87b-4d37-91c5-1da9d811d861" class="">If you want to access things inside of an array, you use the index.</p><pre id="6cbe2e1b-b602-40e6-8e16-65f054e95419" class="code code-wrap"><code>console.log(names[1]);</code></pre><p id="0ca203fd-dcad-4e41-a85a-b1506bba8e69" class="">Do you think that will return the first item in the array?</p><p id="58dd559a-849e-4656-8245-c10bbcdceeeb" class="">If you guess yes, you are wrong! If you refresh, you will see &quot;kait&quot;.</p><p id="baf0d6de-0190-49f3-8830-837316aed6cc" class="">Why?</p><p id="e311f5a3-fe9b-400b-9d22-91ebcdfc91fe" class="">Because arrays are what are referred to as <strong>zero based</strong>. What that means is that the counting starts at 0.</p><p id="a753bf28-e108-470e-96d6-f10287ffa2c9" class="">There are two stories Wes likes to tell everyone when he is talking about <strong>zero based</strong>.</p><p id="608029e9-9d29-4a7f-8851-9074c12cf7c2" class="">First, he went to McDonalds once and was order number zero.</p><p id="339e28cf-46bd-4f10-8f6e-122280f4caea" class="">And he went to McDonalds another time and he was number 99.</p><p id="04709b01-ae80-4859-83a9-6e13d5108beb" class="">It is just so that the number was huge on the receipt, and they had enough space on the receipt to put two numbers but their ordering system did a hundred numbers and then rolled over and started again.</p><p id="71d7dd0c-e1b8-45a1-ad29-ac2eb6f1ecea" class="">What they did is instead of going from 1 to 100, because then the order number (100) wouldn&#x27;t fit on the receipt, they started at 0 to 99 which still gave them the full hundred orders.</p><p id="ed34dafd-c9f1-4ae5-b7cb-e1ba237ec091" class="">The second story is that when Wes got married is he had a table 0, and the last table was 23. That means they had 24 tables in total, it was zero based so it started at 0. That was very confusing for people working there and he does not recommend it.</p><p id="93b0147d-8f29-4561-9458-c49086b19474" class="">In order to access the first item in an array you use the zero index like so 👇</p><pre id="838887ae-d1ee-4e0a-b8d5-dd1550761414" class="code code-wrap"><code>console.log(names[0]);</code></pre><p id="9b0ad21c-199a-4c9e-971d-fc5261b2235a" class="">That should return &quot;wes&quot; because that is the first item in our array.</p><p id="b0541d4d-1bbe-47ac-8b3b-463c16c071ac" class="">If you want to check how many items are in an array, you would use <code>.length</code>. That is NOT zero based.</p><p id="7a8842a9-a999-4a6b-88f8-61ed02480ef7" class="">If you refresh the HTML page and look at the console, you should see the following 👇</p><p id="266f2074-053c-4d4c-bf5d-c51ebe5aab87" class="">So if you want to access items within the array it is zero based, however if you are using <code>.length</code> to check how many items are in the array it is not zero based.</p><p id="653ccca3-edca-472d-934a-392b500212c5" class="">If you want to get the last item in the array, you could do <code>console.log(names[2]);</code> which would give us <code>snickers</code>, but what if you don&#x27;t know how long the array is?</p><p id="746539a0-c90c-49f5-93be-f043a2cf007b" class="">Let&#x27;s say you modified the array to look like this 👇</p><pre id="0cae5a56-9fcb-45f0-9921-dc0cef506315" class="code code-wrap"><code>const names = [&#x27;wes&#x27;, &#x27;kait&#x27;, &#x27;snickers&#x27;, &#x27;wes&#x27;, &#x27;kait&#x27;, &#x27;snickers&#x27;, &#x27;wes&#x27;, &#x27;kait&#x27;, &#x27;snickers&#x27;, &#x27;wes&#x27;, &#x27;kait&#x27;, &#x27;snickers&#x27;, &#x27;wes&#x27;, &#x27;kait&#x27;, &#x27;snickers&#x27;, &#x27;wes&#x27;, &#x27;kait&#x27;, &#x27;snickers&#x27;];</code></pre><p id="a086df90-49b2-41bb-a81c-c87b4fcb9247" class="">Now you have no idea how many items are there (don&#x27;t waste your time counting).</p><p id="2694a5ce-e9eb-4816-9e2b-9a55a53c2cd1" class="">When you need to access the last item in the array but do not know how many there are, you can use the length property like so 👇</p><pre id="200c86eb-eb40-4043-b2a0-5b411266a250" class="code code-wrap"><code>console.log(names[names.length - 1]);</code></pre><p id="241d89f2-9926-4946-ad28-18464b5145dd" class="">If you tried to do <code>console.log(names[names.length])</code>, it will return <code>undefined</code>.</p><p id="4e637259-b88c-4de1-ae9a-1598bf25a480" class="">Why?</p><p id="2232265e-5166-4c36-a4fc-92605927b2e0" class="">Because <code>names[27]</code> does not have a value, the last item is actually at <code>names[26]</code> because the length is 27.</p><h2 id="67250eb7-7701-492e-a9fc-638360cb5912" class="">Array Methods</h2><p id="18add80c-96ba-485f-9bd4-4de5ede3afe4" class="">The Array prototype is full of useful methods for adding, removing and finding things inside of the array.</p><p id="d2799c82-8a6b-4315-8457-d8b4195940eb" class="">Update the names array to only contain 3 names again.</p><pre id="9df0df7f-c9cf-4438-853f-eb041e24d781" class="code code-wrap"><code>const names = [&quot;wes&quot;, &quot;kait&quot;, &quot;snickers&quot;];</code></pre><p id="a786d254-a12b-4217-ae19-a4fd662c6785" class="">If you refresh the page and take a look at the <code>names</code> array in the console, you should see something like 👇</p><p id="9267d5c1-e741-4d44-984e-570cc9c528db" class="">Those are all methods.. <code>concat</code>, <code>copyWithin</code>, <code>push</code>, <code>pop</code>, <code>findIndex</code>.</p><p id="3c2330df-470d-475d-9d4a-6f90d18cb41a" class="">There are tons of methods available to use when working with an array.</p><p id="395b0ad8-6198-4ed6-8369-8b154ba24634" class="">We are not going to go over how every single one works, we will go over the more important ones and learning the idea of <strong>immutability</strong>, <strong>mutable</strong> and <strong>immutable</strong>, because Wes believes thats much more important.</p><p id="046cb52b-f931-459b-b772-c39a68694624" class="">Let&#x27;s talk about the scary words <strong>mutable</strong> and <strong>immutable</strong> again.</p><p id="22030326-98b0-49ca-9e3e-63bfeaaf2144" class=""><strong>Mutable</strong> methods perform mutations. You can think of this like the Teenage Mutant Ninja turtles.</p><p id="50f13ed2-9838-40e7-b532-8b178d2cb4fd" class="">Why were they mutants?</p><p id="071c4c83-595b-4a1d-a7db-efb867ab58d6" class="">Because they transformed from turtles into teenagers with really cool bandanas.</p><p id="48c37da2-dcbb-4187-82a3-c9c96af9f381" class="">When something changes the original version of it, that is what is referred to as a <strong>mutation</strong>.</p><p id="cd7925cd-905e-4da9-967d-7228f17d68be" class=""><strong>Immutable</strong> methods do not change the original thing, they simply return an new array.</p><p id="7a28a11d-dd69-4d28-bf62-2ed95c9da9e4" class="">Let&#x27;s do some examples.</p><p id="0f693499-9307-453f-bdd3-484bc864d2a7" class="">First, let&#x27;s look at a mutation method.</p><pre id="314784d2-cc22-4f0d-8689-b8cea09ae944" class="code code-wrap"><code>// Mutative Method
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];
const numbersBackwards = numbers.reverse();
console.log(numbersBackwards);</code></pre><p id="223c7605-0970-491e-91e9-482fa3df3023" class="">This gives us the array backwards.</p><p id="052e291a-57e7-42a1-96f9-862f32cd7794" class="">What if you log <code>numbers</code>?</p><p id="cd28a964-6c4c-4557-8078-eb217906eb88" class="">Will the numbers in that array still be in the right order, will they be reversed or has it been deleted?</p><p id="864ae2f7-d78f-40b6-bde2-8202013a6311" class="">The original array has actually been reversed as well.</p><p id="9841f838-4b32-4a8b-b56c-3162afe1fe97" class="">That is what is referred to as a <strong>mutation</strong>, meaning the original data has been changed from what it was originally set out to be.</p><p id="05189b8e-3c4f-4f96-91f0-21bf822d6da0" class="">You don&#x27;t even need that second variable in our example, since the code below would work just fine 👇</p><pre id="b3c55345-10d9-4052-85b8-9b5ef6788ee6" class="code code-wrap"><code>const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];
numbers.reverse();
console.log(numbers);</code></pre><p id="da305a4a-f875-4a1b-8369-1c670ea45dc7" class="">Mutability is not necessarily bad or incorrect, it&#x27;s just something important to know about JavaScript, that some methods will modify the original array, whereas some will create a new array and leave the original one intact.</p><p id="c6125c26-383f-4575-8dea-06438fdf58ed" class="">Most functional programmers or React developers tend to have a mantra of &quot;don&#x27;t actually mutate the original array, create a new version of it&quot;.</p><p id="9274e4bc-a5c1-401d-b5b9-1127fcfc5a07" class="">So what&#x27;s an immutable example of one of the methods?</p><p id="6994ee4e-253d-49de-bff1-f865bb929e2f" class="">Let&#x27;s take <code>numbers</code> and use the <code>slice()</code> method.</p><p id="1db02939-8040-4169-808f-c361482d622c" class="">The <code>slice</code> method allows us to take a portion of the array and make it into a new array.</p><p id="28cc7800-c19d-4d46-bb96-32f3f20bf9ad" class="">Let&#x27;s say you want to take the items at index 2 to index 4.</p><p id="e4881198-ccbd-4e78-b33f-ce466ae76a7d" class="">Add the following code 👇, refresh the HTML page and open the console.</p><pre id="4d522be5-f07f-4964-a6af-a530383bb776" class="code code-wrap"><code>const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];
console.log(numbers);
const pizzaSlice = numbers.slice(2, 4);
console.log(pizzaSlice);</code></pre><p id="5df839c7-92d1-4614-a45e-7242dce8e0ad" class="">What you have done is you have gone from index 2, which is the 3rd item and stopped at index 4, which is the 5th item.</p><p id="fa552627-67ca-427d-bd7a-f844ed8d66ce" class="">Slice returns to use the subset of the original array, based on the index values we pass it.</p><p id="89787c4b-185c-46fd-8577-d437cfc03827" class="">If you ever need to take a chunk out of an array, you can reach for slice.</p><p id="225bd3fe-5e4d-41a5-9738-4fa8449caaf4" class="">Now the question is, will the number 3 and 4 still be in the original numbers array?</p><p id="080f2a06-1502-4edb-bdf4-4e25c4646001" class="">Below where we log <code>pizzaSlice</code>, add <code>console.log(numbers);</code> and refresh the page.</p><p id="ce87ff98-7557-49ba-a0eb-4b2b3429b2ee" class="">As you can see, numbers is still intact, meaning the number 3 and 4 have not been removed from it.</p><p id="5ba800f3-5528-4570-8364-54da84217b84" class="">That is referred to as <strong>immutable</strong> methods, meaning they do not change the original data. Mutation methods do change the original data.</p><p id="0f32be95-8d8b-4507-96a2-e86968ae02db" class="">This is the cause of a lot of bugs. Just a few weeks ago, Wes forgot that <code>reverse()</code> was a mutable method.</p><p id="fd84c65a-d5d2-42b5-8d98-2ad593d42779" class="">So what do you do if you want to use a mutable method but you don&#x27;t want to actually mutate the original array?</p><p id="cb2291cb-91b9-47fd-b2e9-e057654a5b26" class="">You take a copy of the array!</p><p id="84acd74b-5fd8-49dc-8b0f-bd683ba22a21" class="">Let&#x27;s demonstrate this with a code example.</p><p id="b5d31859-20e5-49ac-ba6e-56567b94f511" class="">You can copy an array using the square brackets and the spread operator, like so 👇</p><pre id="679ad898-0838-4cc7-af4d-cb723e81cb22" class="code code-wrap"><code>const numbersReversed = [...numbers];
console.log(numbersReversed);
console.log(numbers);</code></pre><p id="937ecd76-23d5-4a2f-835b-9f88c06408a3" class="">Go ahead and call <code>reverse()</code> on numbers reversed as shown below.</p><pre id="27045f4a-2bc9-4beb-a47d-d78bb1f4943d" class="code code-wrap"><code>const numbersReversed = [...numbers];
numbersReversed.reverse();</code></pre><p id="4367b139-5875-4135-9737-7c3ea62abb14" class="">You can also just call the method immediately on the array that was created like so 👇</p><pre id="71246045-e6b5-471e-a103-18418dc43f98" class="code code-wrap"><code>const numbersReversed = [...numbers].reverse();</code></pre><p id="04ab5c4e-936a-436e-945a-a24bd11008e6" class="">To recap:</p><p id="f0c0eef4-8413-455a-b1f6-20962feb072f" class="">Anytime you want to call a mutable method without mutating the original thing, you should first take a copy of it and then call the method.</p><p id="72569b12-156d-4377-9205-9b22f6c1c42c" class="">Most of the methods that we will learn about in arrays are immutable, but the few that aren&#x27;t can get cha.</p><p id="46b6646e-7a7e-4853-a725-a23cf22dbd2a" class="">Comment out all the numbers code we added, because we will continue with our <code>names</code> example that&#x27;s towards the top of the script tag.</p><p id="59e0988d-fd96-426d-8628-00a553136764" class="">One thing you will want to do with an array is add items to it. For that, use the <code>push()</code> method.</p><pre id="e8c7e768-7d31-4c6c-88f3-4e6176e97e73" class="code code-wrap"><code>names.push(&#x27;lux&#x27;);
console.log(names);</code></pre><p id="d873258c-b3b7-47fe-930d-28c28b70bb56" class="">This does mutate the original array.</p><p id="ed3aa61b-4cf1-4cfc-bfe1-bc1309c2e24f" class="">If you didn&#x27;t want to mutate the original array you could do something like this 👇</p><pre id="8c2f9306-ab29-4732-8308-4d54ed6302da" class="code code-wrap"><code>const names2 = [...names, &#x27;lux&#x27;];</code></pre><p id="da1ab637-ede8-4eec-9910-4bcc31553539" class="">What that does is it copies all the items from the <code>names</code> array and then add an additional item, which is &quot;lux&quot;.</p><p id="e3bb36cf-a775-4832-b3d9-36666447bc24" class="">If you want to add an item to the front of an array, you wouldn&#x27;t use push, because that adds the item to the back of the array.</p><p id="902d0feb-9e2e-46a8-abf2-549396ab6ca3" class="">You would use <code>unshift()</code>.</p><p id="0bda2a19-ce02-48bd-bb35-9251f4d6100b" class="">For example 👇</p><pre id="4b571f93-a418-41cb-b231-abf7b1da6487" class="code code-wrap"><code>names.unshift(&#x27;poppy&#x27;);
console.log(names);</code></pre><p id="73b61cec-c951-423e-bbee-82dc5c4cac8b" class="">The immutable way to do that would be 👇</p><pre id="35964dfb-88a2-47a1-9997-fcbb6fd1605b" class="code code-wrap"><code>const names3 = [&#x27;poppy&#x27;, ...names];</code></pre><p id="84921127-255a-4584-9d78-eefda6bd4c97" class="">The next two methods you will mix up for the rest of your life: <code>splice()</code> and <code>slice()</code>.</p><p id="dc543ce7-56d7-4c08-a69b-69e66e5596e0" class="">We have already covered <code>slice()</code>, which allows you to take a portion out of the original array.</p><p id="94762417-1ac7-4fd7-b1c2-4d276f9bf121" class="">But there also is <code>splice()</code>.</p><p id="b5214a47-78cd-4965-80a0-a5a3b2d262aa" class="">Both are used for grabbing a subset of the array but <code>slice()</code> is immutable and <code>splice()</code> is mutable.</p><p id="7363827a-24a0-4972-a2de-0c5fa09933c1" class="">Let&#x27;s take a look at both methods on MDN.</p><blockquote id="db0a0a22-0fe9-48f1-b168-aa6c8e66fa88" class=""><p id="c3cb5d66-634b-4d00-9cde-7d3e685a4ef7" class="">The <code>slice()</code> method returns a shallow copy of a portion of an array into a new array object selected from begin to end (end not included) where begin and end represent the index of items in that array. The original array will not be modified.</p></blockquote><p id="ab80a955-303d-4c9b-ae3e-71dafa7a4101" class="">What they mean by end not included means that in our examples where we did <code>slice(2,4)</code>, it took the items start at index 2, but not at index 4. The end is not inclusive.</p><p id="6682df5a-96c3-4404-af7d-0079b3f7555e" class=""><code>Splice</code> on the other hand will actually take the item out of the original array.</p><blockquote id="980858fa-2e08-4f6c-9818-b362e2709cf3" class=""><p id="26a5d7e4-483f-42e6-8041-55356a6a3f2c" class="">The <code>splice()</code> method changes the contents of an array by removing or replacing existing elements and/or adding new elements in place.</p></blockquote><p id="429545c8-1a1c-40a8-b0e1-3b2d646e5167" class="">The other gotcha is that there is no start and end in <code>splice</code>.</p><p id="3d9543f5-8c06-4f65-ae3b-74026c3cf4ff" class=""><code>Splice</code> has a start and then how many you should go for. For example if you want to start at one and delete 5, you would use splice.</p><p id="6c4a3275-bf3e-469f-8e01-786e42af583f" class="">Let&#x27;s take a look at the numbers example 👇</p><pre id="23920620-c1bc-410c-8fb9-bdcab59074cb" class="code code-wrap"><code>console.log(numbers);
numbers.splice(3, 2);
console.log(numbers);</code></pre><p id="78d47c28-6de0-443a-99dc-9b3879e1d7c8" class="">we started at index 3 which was the #4. Then we went for two items, for #4, #5 and took those out of the array.</p><p id="18d2b078-c9f3-4f7f-a617-c8946cfba53e" class="">That is mutable, whereas <code>slice</code> will just return a new array.</p><p id="73bd2e82-a26f-4a44-b77c-f3a1ba0b608f" class="">More often than not you will want to reach for <code>slice</code> because of that.</p><p id="dcaf2899-81b4-4475-a4c0-9a6b35d6cc0a" class="">A trick to remember that is that you probably want a slice of pizza, so think of pizza!</p><p id="3e6b51be-be54-454f-8b74-b09460117d09" class="">Now let&#x27;s talk about adding items to the middle of an array.</p><p id="92259207-d7df-4876-8e9e-88aca995522c" class="">It is best to use the spread operator.</p><p id="fe492175-c6e9-4556-9db4-a67ff53a9cca" class="">Let&#x27;s say you have an array of <code>bikes</code>, and you want to add 2 items in the middle.</p><p id="66608ce8-77c6-4c64-99d2-fbee6f89db91" class="">How do you do that?</p><p id="116575ea-a09f-4b03-83ec-090a3c0712f3" class="">There is no method to insert an item at a specific index and have the rest push over.</p><p id="8c368663-6dce-4610-959b-39887b550b7c" class="">Create a new array, then use the spread operator in combination with slice like so 👇</p><pre id="e012c4a4-c678-4652-9388-51ad9b64c8cf" class="code code-wrap"><code>const bikes = [&quot;bianchi&quot;, &quot;miele&quot;, &quot;panasonic&quot;, &quot;miyata&quot;];

const newBikes = [
...bikes.slice(0, 2),
&quot;benotto&quot;,
...bikes.slice(2)
];

console.log(newBikes);</code></pre><p id="eb66af97-7700-4033-93d4-ed3645ed7d34" class="">You took the first 2 and spread them into it, and then you add the new item, take everything else after that and spread it into there.</p><p id="6e7deca3-5aa2-47cd-a1f3-27824d17e012" class="">How do you take everything after an index using splice? You don&#x27;t pass it an end, like you did here: <code>...bikes.slice(2);</code></p><p id="cf3f8505-0abc-49a1-b47c-a85d29cb0c9e" class="">What if you want to remove an item, like panasonic, from the array?</p><p id="23e4347e-bcb6-45ee-b560-43b2a3a3ed17" class="">Create a new array and use slice like so 👇</p><pre id="d57d0293-87ca-4401-bc02-2187cd96edd2" class="code code-wrap"><code>const newBikes2 = [
...newBikes.slice(0, 3),
...newBikes.slice(4)
];

console.log(newBikes2);</code></pre><p id="cfc0a747-7d33-4551-ab2a-957d2f9aacc3" class="">What the code above is doing is it is taking everything up to panasonic (index 0 - 3), and then you grab everything after panasonic using <code>...newBikes.slice(4);</code></p><p id="98ccb92f-c7d9-4676-868b-0b1d76c8ec70" class="">Panasonic is no longer in our new array.</p><p id="2dcaf2b0-3e53-42fd-a117-686813df1e32" class="">This is a very common thing to do, especially in frameworks like React and Angular.</p><p id="2c107ba6-c93b-4d3f-bb2c-ec899d7a679d" class="">You basically find where that thing is in the array, and then you use it&#x27;s index to remove it.</p><p id="aff4ff73-5637-41d1-a528-573a42c5f99c" class="">Let&#x27;s do an example like that where you have a bunch of comments, and each item in the comments is an object, like so 👇</p><pre id="3c07ac77-9ade-40b1-a106-5b245b4c38f5" class="code code-wrap"><code>const comments = [
{ text: &quot;Cool Beans&quot;, id: 123 },
{ text: &quot;Love this&quot;, id: 133 },
{ text: &quot;Neato&quot;, id: 233 },
{ text: &quot;good bikes&quot;, id: 333 },
{ text: &quot;so good&quot;, id: 433 }
];</code></pre><p id="4126d8f5-40ad-4ba0-a980-381ded0280a5" class="">You may have a function called <code>deleteComment</code> which takes in an <code>id</code> and the <code>comments</code> array.</p><p id="55e64156-ecce-4923-9d1b-34889c3fe853" class="">Inside of the function, you first need to find the index of the item in the array, then you need to make a new array without that item in it, and then return that new array.</p><p id="db80e8af-6866-4f5f-9816-e036f9ff693c" class="">One thing we have not covered yet is how do you find the index of something, based on the item you are searching for?</p><p id="e0c7669d-0945-4470-845d-55ab6e548f00" class="">You use a method called <code>findIndex()</code>.</p><p id="185eb4e1-38f4-4757-8a80-0edc9564e642" class="">You might think it would work like this 👇</p><pre id="c40c73b5-6467-4a80-8a75-c6f43d10049e" class="code code-wrap"><code>const kaitIndex = names.findIndex(&#x27;kait&#x27;);
console.log(kaitIndex);</code></pre><p id="07ec72c8-5607-49be-a31a-01d5e42e40a2" class="">However, if you try that, you will get the following error 👇</p><p id="fda0be5b-f5e8-4a5b-8522-6f80f3b4e38f" class="">It&#x27;s not as easy as that because our structures are going to be a bit more complex than just strings.</p><p id="76aff2a6-6651-4566-b92f-b299704ce7ef" class="">In this case, you want to find an object based on it&#x27;s id.</p><p id="4b78e1e6-bb1f-4396-9ed8-509320894872" class="">If that is the case, you will do something very similar to a loop.</p><p id="a49eb8fd-05c1-4262-bb51-05f83b175392" class=""><code>findIndex()</code> will loop over every single item and then when it finds the item that you want, it will return true and that will give us the index.</p><p id="5c23f5c7-cc32-4de6-a9c3-2d7931a8366e" class="">For example 👇</p><pre id="6bd7261a-cad4-450e-b2ad-cb498a58ecb8" class="code code-wrap"><code>const kaitIndex = names.findIndex(name =&gt; {
if (name === &#x27;kait&#x27;) {
return true;
} else {
return false;
}
})

console.log(kaitIndex);
console.log(names[kaitIndex]);</code></pre><p id="3e35077b-6e2e-40aa-8cae-bab05615124a" class="">You should see the index 2 and the value of Kait in the console when you refresh the page.</p><p id="b0a033f4-bc9e-4d79-9e78-a7fcce785507" class="">That method is a bit long, so there is a few shorter way to do it.</p><p id="7c605db6-1720-4959-a5e5-29a66013be9d" class="">One way is that you can remove the else because if it&#x27;s true, it will return and the else will never run.</p><pre id="579bb171-4534-496b-988f-8fa7dc856d8e" class="code code-wrap"><code>if (name === &#x27;kait&#x27;) {
return true;
}

return false;</code></pre><p id="0593d396-0725-4612-be69-3d789f19de50" class="">The if statement also returns true or false itself so there is no real need for an if statement.</p><p id="903edd7b-3dc6-4713-9b45-0cd8ce269537" class="">Thus, the other way you can do it is just by return the condition, which will be true of false like this 👇</p><pre id="bb987e24-43f3-41d3-a5e7-4cdb2e46a586" class="code code-wrap"><code>const kaitindex = names.findIndex(name =&gt; {
return name === &#x27;kait&#x27;;
})</code></pre><p id="5994515e-3d17-4599-8c82-68c2a6e4175a" class="">If you refresh the page, you will see that it still works.</p><p id="606f435d-2c03-4484-a1f9-f7a09ae02bab" class="">You can even go one step further and use an implicit return.</p><p id="08739dcd-9f25-4cce-8b48-335fb3cbfd1e" class="">Get rid of the curly brackets, put it all on one line, and get rid of the semi-colon and the keyword return like so 👇</p><pre id="f9e84774-8a27-4cca-8838-57942e88060a" class="code code-wrap"><code>const kaitIndex = names.findIndex(name =&gt; name === &#x27;kait&#x27;);
console.log(kaitIndex);</code></pre><p id="b8a3aca1-8fa1-4e2b-8e6f-c9e0a69e9ec7" class="">Now that you have that, make another array as shown below.</p><pre id="69570934-fc39-40cc-b638-8abf36898aec" class="code code-wrap"><code>const newNamesWithOutKait = [
// get everything up to the kait index
names.slice(0, kaitIndex),
// everything after
names.slice(kaitIndex + 1)
];

console.log(newNamesWithOutKait);</code></pre><p id="b7cd5b75-3f41-4638-9fab-fdbe7e7c5a14" class="">What we are doing there is you go from the start and then grab everything up to the <code>kaitIndex</code>, then you get everything after the <code>kaitIndex</code>.</p><p id="389ea900-7f23-4e23-b7b6-5ccc2bd38b2e" class="">Whoops! You might notice that it looks weird. We goofed up a bit here.</p><p id="3e35549d-2e93-419f-9b8b-6de27079e32f" class="">What we did accidentally is we created an array of 2 arrays.</p><p id="ee1492f0-ed8f-4a8a-9a41-6e71d6f596e4" class="">You don&#x27;t want 2 arrays, you want to take the items out of them and spread them into the new one like so 👇</p><pre id="fa623f4d-cfb4-4a85-a86f-875cd32aba1f" class="code code-wrap"><code>const newNamesWithOutKait = [
// get everything up to the kait index
...names.slice(0, kaitIndex),
// everything after
...names.slice(kaitIndex + 1)
];

console.log(newNamesWithOutKait);</code></pre><p id="cbc0e983-1daa-4e53-a8ea-f1d65d8673e1" class="">There is a new method in JavaScript called <code>.flat()</code>.</p><p id="242412c0-c7f5-41c1-b35c-cd66587aa1a5" class="">If you call it directly on <code>newNamesWithOutKait</code> it wouldn&#x27;t work because it&#x27;s immutable.</p><p id="f6f305aa-7080-4a4c-a3de-9ef7dc93920d" class="">We would have to return it like so 👇</p><pre id="87204261-b3a4-499c-84c3-f2783ed6ad5d" class="code code-wrap"><code>const newNames999 = newNamesWithOutKait.flat();
console.log(newNames999);</code></pre><p id="158c494c-26dc-4052-9723-e83b3bfa9046" class="">You can see it flattened the 2 arrays into one for us.</p><p id="7dda2db6-8445-41b3-a832-40e3a53a2b9e" class="">You could also do this 👇</p><pre id="7e07ef87-be85-4fa3-b46c-5c72e6478a88" class="code code-wrap"><code>const newNamesWithOutKait = [
// get everything up to the kait index
names.slice(0, kaitIndex),
// everything after
names.slice(kaitIndex + 1)
].flat();</code></pre><p id="15cee404-e877-43de-8826-21d0384c7f66" class="">It is a nice solution.</p><p id="b31d189d-2a36-4a78-b626-208ecdb47c27" class="">We will be using the callback API similar to what we used in <code>findIndex</code> in a lot of the methods.</p><p id="28508a64-f43b-4154-84b0-deb3cb591bc9" class="">Now we will go back to our <code>deleteComment</code> example and create the function.</p><p id="d7f950fa-cafa-4cbe-b373-4bdaf90ea7d6" class="">First, find the index. That is a bit different because this time you are looking for an object where it&#x27;s ID property matches.</p><pre id="3afd9da0-a378-4bc2-96e5-12655c32e659" class="code code-wrap"><code>const commentIndex = comments.findIndex(comment =&gt; comment.id === id);</code></pre><p id="2a790cf0-8d21-4cad-b7db-ac9db7270fe2" class="">Next, return a new array using slice. Get everything before the comment and then everything after the comment.</p><pre id="08273f0e-e701-49fd-8b8f-153e733ffab6" class="code code-wrap"><code>return [
...comments.slice(0, commentIndex),
...comments.slice(commentIndex + 1)
];</code></pre><p id="e8ea37fd-1995-4e6c-90aa-43772a3b4330" class="">Here is the entire method 👇</p><pre id="82cfaf60-3803-4e9f-a8da-486125ed0818" class="code code-wrap"><code>function deleteComment(id, comments) {
// first find the index of the item in the array
const commentIndex = comments.findIndex(comment =&gt; comment.id === id);
// make a new array without that item in it
return [
...comments.slice(0, commentIndex),
...comments.slice(commentIndex + 1)
];
// return our new array
}</code></pre><p id="911daf18-c709-41a9-ac3c-a6bf249dd91d" class="">Now if you go and refresh the page and type comments into the console, you can see the comments.</p><p id="72731fb0-f206-44d4-95b0-45e6716916e9" class="">In the console type in <code>deleteComment(233, comments)</code> and that will return the following 👇</p><p id="3287b0b2-57ae-4cf1-9a35-966593eed551" class="">The original comments are still there, we just made a new array called deleteComments with the item removed.</p><p id="bd0556e0-2757-4465-8d39-f10b615807e7" class="">Find an issue with this post? Think you could clarify, update or add something?</p><p id="7027353b-efdb-4a45-8418-9adb8df70f68" class="">All my posts are available to edit on Github. Any fix, little or small, is appreciated!</p><p id="90a211e0-f3ce-4ce5-823e-e89a603659a2" class="">Edit on Github</p></details></li></ul><ul id="5ae625b0-5c65-4afd-b59f-2cdd264f1506" class="toggle"><li><details open=""><summary>45 - Arrays</summary><p id="71ef701b-f279-4c30-9e2c-501c836d558e" class=""><a href="https://wesbos.com/javascript/08-data-types/arrays">https://wesbos.com/javascript/08-data-types/arrays</a></p><p id="9a5f364c-1728-455f-8988-067387768704" class="">
</p><figure id="0dc280ec-b223-47ce-a158-3fcbf785947d" class="image"><a href="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/bjs%203.png"><img style="width:700px" src="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/bjs%203.png"/></a></figure><p id="e32ac36a-586f-445f-94a3-0ab4b824fab4" class="">Enjoy these notes? Want to Slam Dunk JavaScript?</p><p id="a5ec4ad7-c052-481d-b635-ca3a6d8d9373" class="">These are notes based on my <a href="https://beginnerjavascript.com/">Beginner JavaScript</a> Video Course. It&#x27;s a fun, exercise heavy approach to learning Modern JavaScript from scratch.</p><p id="25d871ab-2670-49d1-b14e-f3ebf9687291" class="">Use the code <strong>BEGINNERJS</strong> for an extra $10 off.</p><p id="a8b299b4-916a-4270-aec3-031db953e407" class=""><a href="https://beginnerjavascript.com/">BeginnerJavaScript.com</a></p><p id="dd184abc-03ae-42c8-a5fa-f2c6a794afdb" class="">JavaScript, Data Types, ArraysEdit Post</p><p id="f22036c0-892b-4eef-adc1-2710ef8def46" class="">In this video we will be learning about arrays: how to create them, how to add items how to remove items, things like that.</p><p id="6e2abf36-a3fb-4ee6-9c70-b6f1e8f9d69d" class="">In the next video we will cover looping over an array.</p><p id="6cfc3eee-60bc-4f3b-ba8f-538580dbe7cc" class="">What is an <strong>array</strong>?</p><p id="ce925c7c-ef11-45ab-881b-0fd0564872fe" class="">An array is used for holding a list of items where the order matters.</p><p id="624b4bab-a9fb-4247-b8cb-a470655241ee" class="">Each thing inside of the array is called an <strong>item</strong> and it&#x27;s position in the array is called an <strong>index</strong>.</p><p id="0ed8f9b2-cb61-4598-8d73-cd35413fbeb0" class="">The number of items inside of an array is called a <strong>length</strong>.</p><p id="bcb812fa-421b-4218-be0b-ddc55cbd8ce3" class="">Each item inside of an array can be any type. It can be a string, a number, a boolean, an object, another array, a nested array, you name it.</p><p id="40d460b3-ac51-4e66-b181-ff6843842311" class="">In the <code>/playgrounds</code> directory, open up <code>arrays.html</code>.</p><p id="b7557620-3a48-4016-a7e9-624d3b3dd487" class="">Add a script tag inside the body tag (if it&#x27;s not already there).</p><p id="21e4b844-e5c2-44c5-bb79-ef6911fa73c7" class="">We will use an example of a list of names to demonstrate how to create an array.</p><p id="5a03f226-29de-4480-a7dc-f158b2a0354f" class="">Whereas curly brackets are for an object, square brackets <code>[]</code> are used for noting you are creating an array or an <em>array literal</em>*.</p><pre id="36da0a44-d9a0-45d8-8270-5634981b5925" class="code code-wrap"><code>const name = [];</code></pre><p id="237e6dfd-8605-4331-9f99-6324c368ee5e" class="">You can also create an array using the long hand, just like you can with a string, a number, an object etc, like so 👇</p><pre id="052ce2bd-915e-473f-b0d0-b6db16702fd6" class="code code-wrap"><code>const names = new Array();</code></pre><p id="573deeb1-dabd-4607-b21b-086f6f95fb77" class="">To create items inside of an array you can simply do this 👇</p><pre id="a497d5d8-3257-4517-9264-226ee2a81952" class="code code-wrap"><code>const names = [&#x27;wes&#x27;, &#x27;kait&#x27;, &#x27;snickers&#x27;];</code></pre><p id="f894d58a-54cb-4944-95ba-30d273ba9cac" class="">What you have done there is created an array with 3 items, each of which are separated by a comma.</p><p id="924c8e0f-37eb-4a6f-81c0-508f84a64912" class="">Go ahead and open the page up in a browser and take a look at the array in the console.</p><figure id="d93ab256-a442-470d-a036-a244f6795006" class="image"><a href="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/506%201.png"><img style="width:700px" src="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/506%201.png"/></a></figure><p id="0a8ecc49-eb95-43f2-bd1d-91f9f44bd4e3" class="">This is our array.</p><p id="28def131-de9f-4428-afa6-080f6fa3938c" class="">It looks a lot like an object, but as you can see, it has no keys, which is sort of the main difference between arrays and objects.</p><p id="8cfed2a7-a056-42a2-aaf8-92f5e696fc35" class="">An array has no keys. The keys will always be the indexes meaning 0,1,2,3,4,5..</p><p id="26a18a0e-6874-47e5-9fdb-79cae64a5371" class="">One thing to mention is that if you types into the console <code>typeof names</code>, you would get &quot;object&quot; returned.</p><figure id="b383b0aa-6341-4447-9cf9-48dfb89062f6" class="image"><a href="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/507%201.png"><img style="width:700px" src="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/507%201.png"/></a></figure><p id="8f19918d-507f-4144-80ed-d5a00b8dabea" class="">You might be thinking &quot;Whhaaattt??&quot; <code>typeof names</code> is an object??</p><p id="9a2fe0a8-7ecd-430a-8cce-c0a517c0ef45" class="">If you recall one of the earlier videos where we went over all the types, you should remember that we didn&#x27;t say that array was it&#x27;s own type.</p><p id="3b4be91b-634d-45d3-a63a-14f7cff1320e" class="">An array is actually just an object at the end of the day, meaning that it can hold data and have a bunch of methods living inside of it.</p><p id="813c6d53-91ff-44f7-8ef1-11ac65382428" class="">If you do need to check whether something is an array, you can do that like so 👇</p><pre id="11d9b01a-9d1a-410d-9d63-add632673b86" class="code code-wrap"><code>Array.isArray(names)</code></pre><p id="16c214e5-0178-481c-84bc-eae450216d4f" class="">That will return true or false depending on whether whatever you pass it (in this case <code>names</code>, is an array or not).</p><p id="e48efea8-2cc5-4fba-bde5-fc21134bd43e" class="">That is something called a <strong>static method</strong> which we will learn about later.</p><p id="48cca49c-4b35-46e0-a194-fc131225e334" class="">So you have the <code>names</code> array, but how do you access things inside of it? You can&#x27;t access it like you do properties on an object, so something like <code>name.wes</code> would not work.</p><p id="ccf8881b-32ee-4384-bb2d-3437a7c0d8c7" class="">If you want to access things inside of an array, you use the index.</p><pre id="8d05727a-9b68-4b81-95e5-943273bc787b" class="code code-wrap"><code>console.log(names[1]);</code></pre><p id="c090d7d5-32c1-4852-aa8d-1ee450f69723" class="">Do you think that will return the first item in the array?</p><p id="5e8eb0d9-ff99-4ba8-8eec-40d2880d5eaa" class="">If you guess yes, you are wrong! If you refresh, you will see &quot;kait&quot;.</p><p id="e3a7ebe0-03bb-49ab-881e-5a028b4d382e" class="">Why?</p><p id="ddd3f050-04d6-40a6-9df0-6c41d4df79c9" class="">Because arrays are what are referred to as <strong>zero based</strong>. What that means is that the counting starts at 0.</p><p id="5a659bc7-5caa-404e-ad70-b441fc2444b1" class="">There are two stories Wes likes to tell everyone when he is talking about <strong>zero based</strong>.</p><p id="9753abf1-329a-4f69-a2d2-ae617e342f96" class="">First, he went to McDonalds once and was order number zero.</p><p id="0e7d27aa-cda7-456c-9db6-ab63c5122d72" class="">And he went to McDonalds another time and he was number 99.</p><p id="c1f3c9c7-7a40-482c-8246-8f64c433b9ac" class="">It is just so that the number was huge on the receipt, and they had enough space on the receipt to put two numbers but their ordering system did a hundred numbers and then rolled over and started again.</p><p id="0985916e-10b9-405a-b02a-f35abad9749f" class="">What they did is instead of going from 1 to 100, because then the order number (100) wouldn&#x27;t fit on the receipt, they started at 0 to 99 which still gave them the full hundred orders.</p><p id="3d41b3ef-dc40-4b4e-8538-89ed08b81414" class="">The second story is that when Wes got married is he had a table 0, and the last table was 23. That means they had 24 tables in total, it was zero based so it started at 0. That was very confusing for people working there and he does not recommend it.</p><p id="c6f18795-d829-43c9-9d92-73fd09ee7110" class="">In order to access the first item in an array you use the zero index like so 👇</p><pre id="06e4ac7c-732d-4cdd-aa43-9b578168ae25" class="code code-wrap"><code>console.log(names[0]);</code></pre><p id="25cf0813-ebc0-4334-9dd6-ea1a4996d2a7" class="">That should return &quot;wes&quot; because that is the first item in our array.</p><p id="0fa57d70-7313-4b7e-9a9e-76989fcbfe4c" class="">If you want to check how many items are in an array, you would use <code>.length</code>. That is NOT zero based.</p><p id="a7326537-6a37-4ca8-91c4-0d890f90b7a1" class="">If you refresh the HTML page and look at the console, you should see the following 👇</p><p id="4d0839d4-a1fa-4ac6-83cc-b5a6b3d9f664" class="">So if you want to access items within the array it is zero based, however if you are using <code>.length</code> to check how many items are in the array it is not zero based.</p><p id="d2d6c31a-0be7-45c0-980d-48ef8e603bd0" class="">If you want to get the last item in the array, you could do <code>console.log(names[2]);</code> which would give us <code>snickers</code>, but what if you don&#x27;t know how long the array is?</p><p id="36626847-f0af-442b-971c-98373915932e" class="">Let&#x27;s say you modified the array to look like this 👇</p><pre id="f0f6202e-c105-4989-a2df-151ea888d53b" class="code code-wrap"><code>const names = [&#x27;wes&#x27;, &#x27;kait&#x27;, &#x27;snickers&#x27;, &#x27;wes&#x27;, &#x27;kait&#x27;, &#x27;snickers&#x27;, &#x27;wes&#x27;, &#x27;kait&#x27;, &#x27;snickers&#x27;, &#x27;wes&#x27;, &#x27;kait&#x27;, &#x27;snickers&#x27;, &#x27;wes&#x27;, &#x27;kait&#x27;, &#x27;snickers&#x27;, &#x27;wes&#x27;, &#x27;kait&#x27;, &#x27;snickers&#x27;];</code></pre><p id="20de47f8-2234-44d0-addc-bf6a51f85ae6" class="">Now you have no idea how many items are there (don&#x27;t waste your time counting).</p><p id="615ae92f-06e3-487d-aa33-c92c2b36c003" class="">When you need to access the last item in the array but do not know how many there are, you can use the length property like so 👇</p><pre id="2244cd57-cef0-4e7d-ae3c-fda9aa597728" class="code code-wrap"><code>console.log(names[names.length - 1]);</code></pre><p id="ada3d5ce-1f67-4a5e-8791-b27d74f8fec5" class="">If you tried to do <code>console.log(names[names.length])</code>, it will return <code>undefined</code>.</p><p id="9ad97c45-28da-4576-af6c-256eab08d3bb" class="">Why?</p><p id="90ebb514-6b10-4092-8108-291ca3ccf32a" class="">Because <code>names[27]</code> does not have a value, the last item is actually at <code>names[26]</code> because the length is 27.</p><h2 id="33aad189-76dc-4d12-8889-7861c2e7ee8b" class="">Array Methods</h2><p id="858d1583-f7c1-435c-abb2-ee5cf1859417" class="">The Array prototype is full of useful methods for adding, removing and finding things inside of the array.</p><p id="53e10ca2-4db5-472b-b2bf-3bfeb0c4cef2" class="">Update the names array to only contain 3 names again.</p><pre id="7737ce5f-d184-4079-b5a1-31263f0a0c0c" class="code code-wrap"><code>const names = [&quot;wes&quot;, &quot;kait&quot;, &quot;snickers&quot;];</code></pre><p id="1b7ae3d1-3b4b-4100-89c1-4795184169a1" class="">If you refresh the page and take a look at the <code>names</code> array in the console, you should see something like 👇</p><p id="02093794-0c85-46f4-a9b1-90c51b2e0ac1" class="">Those are all methods.. <code>concat</code>, <code>copyWithin</code>, <code>push</code>, <code>pop</code>, <code>findIndex</code>.</p><p id="c03bfba8-aca1-4d9b-b6e8-c1165553ccbd" class="">There are tons of methods available to use when working with an array.</p><p id="d92c8959-22c0-4eea-9496-3c5946544575" class="">We are not going to go over how every single one works, we will go over the more important ones and learning the idea of <strong>immutability</strong>, <strong>mutable</strong> and <strong>immutable</strong>, because Wes believes thats much more important.</p><p id="415c50fb-7316-4985-b0a1-9a63f533d746" class="">Let&#x27;s talk about the scary words <strong>mutable</strong> and <strong>immutable</strong> again.</p><p id="b77a653d-4407-4ede-88a6-b64fa58ce15a" class=""><strong>Mutable</strong> methods perform mutations. You can think of this like the Teenage Mutant Ninja turtles.</p><p id="8bf3ef0c-8261-4161-8000-75ec937d27cf" class="">Why were they mutants?</p><p id="f5a07c46-4c37-4797-b9bc-f084a244ab77" class="">Because they transformed from turtles into teenagers with really cool bandanas.</p><p id="5c25ca1e-0f25-4266-9d26-9e44fbd06f08" class="">When something changes the original version of it, that is what is referred to as a <strong>mutation</strong>.</p><p id="9ad566bd-6c27-474a-87fc-d73835ee1011" class=""><strong>Immutable</strong> methods do not change the original thing, they simply return an new array.</p><p id="1021cf5b-e428-4ffb-9ccc-ef5ab72e911f" class="">Let&#x27;s do some examples.</p><p id="10dbe2f0-7126-4915-bbb7-b01ef0f95300" class="">First, let&#x27;s look at a mutation method.</p><pre id="6200c7db-cb9c-46b5-bc7c-d94902d2a01f" class="code code-wrap"><code>// Mutative Method
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];
const numbersBackwards = numbers.reverse();
console.log(numbersBackwards);</code></pre><p id="59c72c70-7624-4762-8b5c-ab8ab2915698" class="">This gives us the array backwards.</p><p id="f4eb8e8b-8fba-4d1c-9ad5-486f23bade00" class="">What if you log <code>numbers</code>?</p><p id="c4d43824-cb24-4176-bb03-52919ae0b708" class="">Will the numbers in that array still be in the right order, will they be reversed or has it been deleted?</p><p id="8ab524bd-bff0-43f2-87c2-6032cbbe723e" class="">The original array has actually been reversed as well.</p><p id="2c60bfe8-41de-43b3-85a3-d428ffab7a78" class="">That is what is referred to as a <strong>mutation</strong>, meaning the original data has been changed from what it was originally set out to be.</p><p id="f80d8e61-f5fa-4e5b-b403-8d68191180ef" class="">You don&#x27;t even need that second variable in our example, since the code below would work just fine 👇</p><pre id="80982114-09f2-42fd-9bb2-9117434f6a71" class="code code-wrap"><code>const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];
numbers.reverse();
console.log(numbers);</code></pre><p id="214c1b16-442b-484e-b215-9a742889f519" class="">Mutability is not necessarily bad or incorrect, it&#x27;s just something important to know about JavaScript, that some methods will modify the original array, whereas some will create a new array and leave the original one intact.</p><p id="33fb5012-5646-4fc0-8d28-09f66979210f" class="">Most functional programmers or React developers tend to have a mantra of &quot;don&#x27;t actually mutate the original array, create a new version of it&quot;.</p><p id="57480d45-58ab-48de-9fec-6890812cdd57" class="">So what&#x27;s an immutable example of one of the methods?</p><p id="a1ea3951-e962-4d23-ba6c-3d0f04b00338" class="">Let&#x27;s take <code>numbers</code> and use the <code>slice()</code> method.</p><p id="e7f0a285-e743-4940-9eb9-6084b88006a2" class="">The <code>slice</code> method allows us to take a portion of the array and make it into a new array.</p><p id="77ea48f9-1368-47cb-80f0-907304093132" class="">Let&#x27;s say you want to take the items at index 2 to index 4.</p><p id="c95825c2-ddbf-4516-8b56-f05dab4602cf" class="">Add the following code 👇, refresh the HTML page and open the console.</p><pre id="38c62fed-50b0-4cd5-91d4-4653da6e9f80" class="code code-wrap"><code>const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];
console.log(numbers);
const pizzaSlice = numbers.slice(2, 4);
console.log(pizzaSlice);</code></pre><p id="24399e2a-8aa6-4959-bd2d-d95ed1178a30" class="">What you have done is you have gone from index 2, which is the 3rd item and stopped at index 4, which is the 5th item.</p><p id="94621304-13bd-48c6-9c4b-5c10de462ca2" class="">Slice returns to use the subset of the original array, based on the index values we pass it.</p><p id="c4557e95-b341-4be1-87d9-bb28f1388cc0" class="">If you ever need to take a chunk out of an array, you can reach for slice.</p><p id="7c585ec4-4fab-4744-bf49-acfecabc3ccf" class="">Now the question is, will the number 3 and 4 still be in the original numbers array?</p><p id="4bd6a77c-4592-4059-829a-5f792fcb022d" class="">Below where we log <code>pizzaSlice</code>, add <code>console.log(numbers);</code> and refresh the page.</p><p id="ecfcc209-d32c-4095-ad26-c33836db3639" class="">As you can see, numbers is still intact, meaning the number 3 and 4 have not been removed from it.</p><p id="23c17509-8321-4ea9-8da3-276bc40796d0" class="">That is referred to as <strong>immutable</strong> methods, meaning they do not change the original data. Mutation methods do change the original data.</p><p id="6d35f3c4-1264-478e-886a-88fbe637c64a" class="">This is the cause of a lot of bugs. Just a few weeks ago, Wes forgot that <code>reverse()</code> was a mutable method.</p><p id="c5d93370-6d80-481e-ae3a-b31ab0f20996" class="">So what do you do if you want to use a mutable method but you don&#x27;t want to actually mutate the original array?</p><p id="e02c0018-af13-4a36-b659-6d277d3f0995" class="">You take a copy of the array!</p><p id="2d590cb0-a637-4b8e-9576-371f329dd096" class="">Let&#x27;s demonstrate this with a code example.</p><p id="0bd82949-c5a3-458e-bcb0-d1e4184cecdf" class="">You can copy an array using the square brackets and the spread operator, like so 👇</p><pre id="3348dcc6-3c7b-4bbf-9f34-63f21e0d381e" class="code code-wrap"><code>const numbersReversed = [...numbers];
console.log(numbersReversed);
console.log(numbers);</code></pre><p id="cfc7c104-eb2b-4d8f-959f-7765e9e2093d" class="">Go ahead and call <code>reverse()</code> on numbers reversed as shown below.</p><pre id="adbd4bd9-7e4f-4b94-886d-437dc223ccff" class="code code-wrap"><code>const numbersReversed = [...numbers];
numbersReversed.reverse();</code></pre><p id="64451c2a-eec5-4307-ad65-f12689f4a7e4" class="">You can also just call the method immediately on the array that was created like so 👇</p><pre id="bda4bea8-aeba-4b04-a377-cb884488b429" class="code code-wrap"><code>const numbersReversed = [...numbers].reverse();</code></pre><p id="530f97a3-2607-4325-931e-31030aa48b4a" class="">To recap:</p><p id="6b3ff0f3-a327-4900-aa57-96d632b4eb48" class="">Anytime you want to call a mutable method without mutating the original thing, you should first take a copy of it and then call the method.</p><p id="bd4a55e2-4e18-4fa0-9c69-a8b54625a836" class="">Most of the methods that we will learn about in arrays are immutable, but the few that aren&#x27;t can get cha.</p><p id="06521fd9-5f3e-4cd2-a5af-ceeb8d840509" class="">Comment out all the numbers code we added, because we will continue with our <code>names</code> example that&#x27;s towards the top of the script tag.</p><p id="6db117f9-33b3-4442-b17d-28acbc39adf0" class="">One thing you will want to do with an array is add items to it. For that, use the <code>push()</code> method.</p><pre id="7b88f0b8-5309-4aa1-b5d5-2979d85c5e95" class="code code-wrap"><code>names.push(&#x27;lux&#x27;);
console.log(names);</code></pre><p id="6fa5735b-542f-45f1-bc36-a566abe85782" class="">This does mutate the original array.</p><p id="1b3392b6-9604-4b11-88ca-c959a73070cf" class="">If you didn&#x27;t want to mutate the original array you could do something like this 👇</p><pre id="80b7e381-a082-4a1b-8091-dda9d6c3c448" class="code code-wrap"><code>const names2 = [...names, &#x27;lux&#x27;];</code></pre><p id="210d66a0-1ecc-4d3e-89e8-500efc593ad3" class="">What that does is it copies all the items from the <code>names</code> array and then add an additional item, which is &quot;lux&quot;.</p><p id="d846fe5f-5f96-490b-b359-402db0a43868" class="">If you want to add an item to the front of an array, you wouldn&#x27;t use push, because that adds the item to the back of the array.</p><p id="de56d966-9138-4c3e-b950-af56931ba7f1" class="">You would use <code>unshift()</code>.</p><p id="ea6ef4f6-a363-435d-9e49-b4b19bc6d596" class="">For example 👇</p><pre id="05930473-dcfe-4ab0-a572-2ca7f69d7f37" class="code code-wrap"><code>names.unshift(&#x27;poppy&#x27;);
console.log(names);</code></pre><p id="44fe7ed5-b602-4944-827b-5ef3c99fd03e" class="">The immutable way to do that would be 👇</p><pre id="4baa38c7-2dce-4706-a987-0212264725bb" class="code code-wrap"><code>const names3 = [&#x27;poppy&#x27;, ...names];</code></pre><p id="434d29ac-016c-46f9-8cac-e62cb38a35f1" class="">The next two methods you will mix up for the rest of your life: <code>splice()</code> and <code>slice()</code>.</p><p id="5f792878-547a-4883-bee9-56c84c267043" class="">We have already covered <code>slice()</code>, which allows you to take a portion out of the original array.</p><p id="2c07bc63-838b-460d-9329-260e4480e871" class="">But there also is <code>splice()</code>.</p><p id="c71f945f-d21d-48de-b923-73d86e0367f2" class="">Both are used for grabbing a subset of the array but <code>slice()</code> is immutable and <code>splice()</code> is mutable.</p><p id="3d66755b-faa3-495b-a5c3-1e8c4088edef" class="">Let&#x27;s take a look at both methods on MDN.</p><blockquote id="fa5ca6df-e34d-437b-b2eb-f6981ea147e8" class=""><p id="2c40463a-4081-4ca8-87e3-ff4f52504d47" class="">The <code>slice()</code> method returns a shallow copy of a portion of an array into a new array object selected from begin to end (end not included) where begin and end represent the index of items in that array. The original array will not be modified.</p></blockquote><p id="dc44b3b9-7ca0-4911-aae3-3c41b718a650" class="">What they mean by end not included means that in our examples where we did <code>slice(2,4)</code>, it took the items start at index 2, but not at index 4. The end is not inclusive.</p><p id="7fe2f63d-5699-4a97-b481-66f90f7b12cb" class=""><code>Splice</code> on the other hand will actually take the item out of the original array.</p><blockquote id="bcf86ff5-0af6-4db7-9358-20f818260d55" class=""><p id="1c5dc3a0-7088-41e7-98c4-6c7f2ecbb053" class="">The <code>splice()</code> method changes the contents of an array by removing or replacing existing elements and/or adding new elements in place.</p></blockquote><p id="106b04a7-804d-4924-80e6-8a95c4155446" class="">The other gotcha is that there is no start and end in <code>splice</code>.</p><p id="a2fb0342-afc3-480b-85ac-4760ee11ef36" class=""><code>Splice</code> has a start and then how many you should go for. For example if you want to start at one and delete 5, you would use splice.</p><p id="f64a18e6-97f1-477c-8ff4-bb3c42beed04" class="">Let&#x27;s take a look at the numbers example 👇</p><pre id="99f32cdf-aa0e-4c54-abd2-6fde9b631cd7" class="code code-wrap"><code>console.log(numbers);
numbers.splice(3, 2);
console.log(numbers);</code></pre><p id="1843e03c-8347-4206-872d-5a22f543d36c" class="">we started at index 3 which was the #4. Then we went for two items, for #4, #5 and took those out of the array.</p><p id="c7266086-53bf-4628-a24d-0ed324847adf" class="">That is mutable, whereas <code>slice</code> will just return a new array.</p><p id="9a701a70-9bc2-4427-9b94-c3d45febb2da" class="">More often than not you will want to reach for <code>slice</code> because of that.</p><p id="16e4855c-33f1-49bc-902b-59471645fac1" class="">A trick to remember that is that you probably want a slice of pizza, so think of pizza!</p><p id="4cd5be11-09fa-40fb-930e-ec34a0379f2e" class="">Now let&#x27;s talk about adding items to the middle of an array.</p><p id="d72e49dd-8a3c-470a-a30e-6a37ed90b01e" class="">It is best to use the spread operator.</p><p id="5da0a507-730a-41a4-943a-b89e51fcf105" class="">Let&#x27;s say you have an array of <code>bikes</code>, and you want to add 2 items in the middle.</p><p id="7bee3112-9709-4745-8172-9971c5554cbd" class="">How do you do that?</p><p id="0fb7b38f-d4c6-4c26-8d7c-707ef92279fc" class="">There is no method to insert an item at a specific index and have the rest push over.</p><p id="5269b6f5-53a0-453e-84b0-b29ea4fd4ee0" class="">Create a new array, then use the spread operator in combination with slice like so 👇</p><pre id="954b6a29-b975-472d-b4fa-d4267d9e948e" class="code code-wrap"><code>const bikes = [&quot;bianchi&quot;, &quot;miele&quot;, &quot;panasonic&quot;, &quot;miyata&quot;];

const newBikes = [
...bikes.slice(0, 2),
&quot;benotto&quot;,
...bikes.slice(2)
];

console.log(newBikes);</code></pre><p id="e8b77619-9e2c-4998-8d37-f5e4e69437d1" class="">You took the first 2 and spread them into it, and then you add the new item, take everything else after that and spread it into there.</p><p id="4502c388-2716-4c4d-8894-039c111cef18" class="">How do you take everything after an index using splice? You don&#x27;t pass it an end, like you did here: <code>...bikes.slice(2);</code></p><p id="208a02db-29f8-4ede-94af-be805cd932eb" class="">What if you want to remove an item, like panasonic, from the array?</p><p id="6ca46937-7d8f-4b0c-a0d8-1e7ad719b54d" class="">Create a new array and use slice like so 👇</p><pre id="e6622448-ea7b-4e93-9e9e-226e89e20872" class="code code-wrap"><code>const newBikes2 = [
...newBikes.slice(0, 3),
...newBikes.slice(4)
];

console.log(newBikes2);</code></pre><p id="71fc14a1-7f8c-4a74-80f2-01936571c264" class="">What the code above is doing is it is taking everything up to panasonic (index 0 - 3), and then you grab everything after panasonic using <code>...newBikes.slice(4);</code></p><p id="f62fbcd5-8eb5-4830-831d-1234673db1e8" class="">Panasonic is no longer in our new array.</p><p id="4f254849-01cc-4468-8faa-6c7e092a7fcc" class="">This is a very common thing to do, especially in frameworks like React and Angular.</p><p id="f1677136-819e-4bd9-9ffb-8fddaa3ea8dd" class="">You basically find where that thing is in the array, and then you use it&#x27;s index to remove it.</p><p id="b96c9069-b4ca-412d-982b-4380ae69362d" class="">Let&#x27;s do an example like that where you have a bunch of comments, and each item in the comments is an object, like so 👇</p><pre id="582dd2cf-e0f9-411d-84dc-71e1f68770a9" class="code code-wrap"><code>const comments = [
{ text: &quot;Cool Beans&quot;, id: 123 },
{ text: &quot;Love this&quot;, id: 133 },
{ text: &quot;Neato&quot;, id: 233 },
{ text: &quot;good bikes&quot;, id: 333 },
{ text: &quot;so good&quot;, id: 433 }
];</code></pre><p id="8613fb2e-e4b0-49e8-b0ae-4bb802d2e1ea" class="">You may have a function called <code>deleteComment</code> which takes in an <code>id</code> and the <code>comments</code> array.</p><p id="d4a1e89d-e5b5-47bf-b0ec-5b6a72c30e10" class="">Inside of the function, you first need to find the index of the item in the array, then you need to make a new array without that item in it, and then return that new array.</p><p id="95bc9777-3fe7-4738-a7a3-167b2425392a" class="">One thing we have not covered yet is how do you find the index of something, based on the item you are searching for?</p><p id="f2c42101-ce98-4170-931c-12ba4cd3d04c" class="">You use a method called <code>findIndex()</code>.</p><p id="d1284edc-369a-456b-9a54-d6a9d98317ef" class="">You might think it would work like this 👇</p><pre id="ba492a1e-ea76-489b-a0c3-d951b5d8e0d9" class="code code-wrap"><code>const kaitIndex = names.findIndex(&#x27;kait&#x27;);
console.log(kaitIndex);</code></pre><p id="58488a4c-8f52-408f-958b-3b444dfb0d1a" class="">However, if you try that, you will get the following error 👇</p><p id="f801dd2c-d10e-4d0d-8702-02150ec90e0f" class="">It&#x27;s not as easy as that because our structures are going to be a bit more complex than just strings.</p><p id="92b87241-7b4d-4b63-95f2-e773a75169ca" class="">In this case, you want to find an object based on it&#x27;s id.</p><p id="4f6956e3-1e1a-4a83-9569-52b199e61ba1" class="">If that is the case, you will do something very similar to a loop.</p><p id="2463ec6c-1d7d-40e4-a366-a7dc8c6a6a78" class=""><code>findIndex()</code> will loop over every single item and then when it finds the item that you want, it will return true and that will give us the index.</p><p id="ae2a8215-97db-411e-bfd5-33ddc1d3d081" class="">For example 👇</p><pre id="3973da76-3969-46df-bca0-8a00f393b47a" class="code code-wrap"><code>const kaitIndex = names.findIndex(name =&gt; {
if (name === &#x27;kait&#x27;) {
return true;
} else {
return false;
}
})

console.log(kaitIndex);
console.log(names[kaitIndex]);</code></pre><p id="55bf129e-d3d7-4131-bc7c-0476b1e673f9" class="">You should see the index 2 and the value of Kait in the console when you refresh the page.</p><p id="f124a288-c143-4855-b0b2-6df964035b2e" class="">That method is a bit long, so there is a few shorter way to do it.</p><p id="de82982b-ad85-4258-b93d-80eecf56effb" class="">One way is that you can remove the else because if it&#x27;s true, it will return and the else will never run.</p><pre id="bfd00353-507f-4585-9a20-7daa505fda05" class="code code-wrap"><code>if (name === &#x27;kait&#x27;) {
return true;
}

return false;</code></pre><p id="aa645d78-bd26-4f70-b7eb-a28f0154310b" class="">The if statement also returns true or false itself so there is no real need for an if statement.</p><p id="75368430-f41a-48c2-92cd-f5d299d98d8a" class="">Thus, the other way you can do it is just by return the condition, which will be true of false like this 👇</p><pre id="e611b658-131f-4f7a-b15f-85857c8c8c99" class="code code-wrap"><code>const kaitindex = names.findIndex(name =&gt; {
return name === &#x27;kait&#x27;;
})</code></pre><p id="209e56f4-16da-4ead-9a70-4389e396affd" class="">If you refresh the page, you will see that it still works.</p><p id="bc0c1e08-7cf1-4a66-b7ee-6ca5efaaf39c" class="">You can even go one step further and use an implicit return.</p><p id="01791a67-d42c-4b99-810a-3b28ffe394e3" class="">Get rid of the curly brackets, put it all on one line, and get rid of the semi-colon and the keyword return like so 👇</p><pre id="645e302f-cc7f-4c3d-a1e0-c486f29b8200" class="code code-wrap"><code>const kaitIndex = names.findIndex(name =&gt; name === &#x27;kait&#x27;);
console.log(kaitIndex);</code></pre><p id="9fe275e0-a04f-4553-ade3-ca609fb16860" class="">Now that you have that, make another array as shown below.</p><pre id="e2a6ee15-5d0a-4891-8943-b145c8e450ef" class="code code-wrap"><code>const newNamesWithOutKait = [
// get everything up to the kait index
names.slice(0, kaitIndex),
// everything after
names.slice(kaitIndex + 1)
];

console.log(newNamesWithOutKait);</code></pre><p id="bc147e91-c129-46d7-b815-389006948bd4" class="">What we are doing there is you go from the start and then grab everything up to the <code>kaitIndex</code>, then you get everything after the <code>kaitIndex</code>.</p><p id="7a0e0e1d-c385-4614-8c1c-c9cfd487a010" class="">Whoops! You might notice that it looks weird. We goofed up a bit here.</p><p id="406bc64f-0d62-42f8-9b5a-389949398f7f" class="">What we did accidentally is we created an array of 2 arrays.</p><p id="d0f94c79-d60d-46c9-977d-dccea7d96217" class="">You don&#x27;t want 2 arrays, you want to take the items out of them and spread them into the new one like so 👇</p><pre id="a9647560-07b7-4727-9b19-628105deb06c" class="code code-wrap"><code>const newNamesWithOutKait = [
// get everything up to the kait index
...names.slice(0, kaitIndex),
// everything after
...names.slice(kaitIndex + 1)
];

console.log(newNamesWithOutKait);</code></pre><p id="ff092288-7fba-491f-a5f1-f3c28f620f4c" class="">There is a new method in JavaScript called <code>.flat()</code>.</p><p id="1d995d5d-554a-47ac-ad1a-90cf661d1126" class="">If you call it directly on <code>newNamesWithOutKait</code> it wouldn&#x27;t work because it&#x27;s immutable.</p><p id="a262c3c9-7b96-4eb0-9845-3e371ec968e7" class="">We would have to return it like so 👇</p><pre id="a3214a91-4e3e-4f88-8d56-88d1af7c835e" class="code code-wrap"><code>const newNames999 = newNamesWithOutKait.flat();
console.log(newNames999);</code></pre><p id="3a6791a4-2bf2-4437-929a-8f29af1863eb" class="">You can see it flattened the 2 arrays into one for us.</p><p id="845fbacc-5a57-43cf-b840-54ffe42cfb47" class="">You could also do this 👇</p><pre id="e52b4596-4b64-4ffb-98e0-d88dbb8941ad" class="code code-wrap"><code>const newNamesWithOutKait = [
// get everything up to the kait index
names.slice(0, kaitIndex),
// everything after
names.slice(kaitIndex + 1)
].flat();</code></pre><p id="fd5c91cb-e608-479f-a8d3-728ee226f48c" class="">It is a nice solution.</p><p id="45f1cc74-cf89-401d-97bc-90250a7a5888" class="">We will be using the callback API similar to what we used in <code>findIndex</code> in a lot of the methods.</p><p id="24ea1929-0071-4e6d-9585-2d89d2daeab1" class="">Now we will go back to our <code>deleteComment</code> example and create the function.</p><p id="abc7f8b8-9cfb-48cf-8133-ac316c4b5e32" class="">First, find the index. That is a bit different because this time you are looking for an object where it&#x27;s ID property matches.</p><pre id="9a79d30d-d881-4d34-9258-40cb147b884c" class="code code-wrap"><code>const commentIndex = comments.findIndex(comment =&gt; comment.id === id);</code></pre><p id="9b97eb60-ebac-41c8-bf81-7af57beffdd2" class="">Next, return a new array using slice. Get everything before the comment and then everything after the comment.</p><pre id="5a79d974-b56c-4029-a4ca-d83486b16d75" class="code code-wrap"><code>return [
...comments.slice(0, commentIndex),
...comments.slice(commentIndex + 1)
];</code></pre><p id="abd21c38-5c09-4b5d-8e22-598615788f5b" class="">Here is the entire method 👇</p><pre id="adb672e3-7534-4e2b-aa86-beb3995e60ed" class="code code-wrap"><code>function deleteComment(id, comments) {
// first find the index of the item in the array
const commentIndex = comments.findIndex(comment =&gt; comment.id === id);
// make a new array without that item in it
return [
...comments.slice(0, commentIndex),
...comments.slice(commentIndex + 1)
];
// return our new array
}</code></pre><p id="79d54706-10e3-46e1-baa6-d5531a69022e" class="">Now if you go and refresh the page and type comments into the console, you can see the comments.</p><p id="ff811e03-fbb2-4df0-bfd2-5abdce4748f0" class="">In the console type in <code>deleteComment(233, comments)</code> and that will return the following 👇</p><p id="63caaaf5-c9c2-40e8-a5ec-b8b4cf43631f" class="">The original comments are still there, we just made a new array called deleteComments with the item removed.</p><p id="5bf16eb7-3006-4e3b-a26b-6b6612cd80b1" class="">Find an issue with this post? Think you could clarify, update or add something?</p><p id="181707f5-1f7e-4f00-af68-07041b992910" class="">All my posts are available to edit on Github. Any fix, little or small, is appreciated!</p><p id="15f27930-e79c-4f7d-995d-8aef7162d2be" class="">Edit on Github</p></details></li></ul><ul id="987aa8d2-4be1-4278-9770-d7217e6085e6" class="toggle"><li><details open=""><summary>46 - Array Cardio - Static Methods</summary><p id="23ee4a82-be7f-4f5d-b523-582896a65183" class=""><a href="https://wesbos.com/javascript/08-data-types/46-array-cardio-static-methods">https://wesbos.com/javascript/08-data-types/46-array-cardio-static-methods</a></p><p id="cf8c31d0-6076-4e7a-b670-018238028a35" class="">
</p><figure id="0a8b579a-3b58-4411-8386-9691572d8bb3" class="image"><a href="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/bjs%204.png"><img style="width:700px" src="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/bjs%204.png"/></a></figure><p id="7dc3654c-0e87-4a37-a91a-c3825275206c" class="">Enjoy these notes? Want to Slam Dunk JavaScript?</p><p id="06da6b4c-6073-44a0-a6e2-5074c39d53db" class="">These are notes based on my <a href="https://beginnerjavascript.com/">Beginner JavaScript</a> Video Course. It&#x27;s a fun, exercise heavy approach to learning Modern JavaScript from scratch.</p><p id="33b96890-82ef-4a78-8000-7da377b57faa" class="">Use the code <strong>BEGINNERJS</strong> for an extra $10 off.</p><p id="b85ed976-5c0f-4b3c-b9b2-e5a0b9f8e285" class=""><a href="https://beginnerjavascript.com/">BeginnerJavaScript.com</a></p><p id="52db21e7-4aaf-45cd-9806-060aa8013a27" class="">JavaScript, Data Types, CardioEdit Post</p><p id="708eae1a-47f4-425e-a206-5b72660f3e20" class="">This is method cardio!</p><p id="42979a53-f778-4185-b16c-e6ee9c1f6a39" class="">This is something that Wes likes to do where we do a bunch of little examples.</p><p id="0bd680f6-81b4-4f7d-8fea-19f172f14d10" class="">Instead of Wes sitting there and trying to explain all the different array methods to us, we are just going to do lots of examples.</p><p id="b17516b5-0880-43bf-bd20-a8cad620f3d8" class="">You can take a stab at trying each one on your own, then come back and watch Wes do it, and he will talk through how it works.</p><p id="be287563-6091-4378-ae65-ebd26b202d61" class="">Let&#x27;s look up the MDN docs for arrays.</p><p id="773fc26f-de1f-4f09-96b0-0613922ba40c" class="">When you open it, you will see all the array methods in the documentation, along the sidebar.</p><figure id="33721bc8-97be-45cc-ba51-0f0550cac5fe" class="image"><a href="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/530.png"><img style="width:700px" src="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/530.png"/></a></figure><p id="26cf4302-aa5e-48d0-9eeb-77828f35558f" class="">Instead of Wes going through each one, we are going to work with the data Wes has provided and use the methods to add, remove and sort items.</p><p id="09b7397e-4ae2-4ad6-a302-bfeff2a8150c" class="">Wes has another course called JavaScript30 (it&#x27;s totally free), and in that course there are 2 lessons that focus on Array Cardio. If after this video you want more practice, you can visit those videos.</p><p id="b5180fef-6bd6-4e98-9b31-fa60601efa0f" class="">Wes has broken this up into different sections.</p><p id="99e04ffc-d080-4f94-8e33-f7599e040423" class="">We have:</p><ul id="7621d05f-7042-43eb-9e3a-347179df4a36" class="bulleted-list"><li style="list-style-type:disc">static methods</li></ul><ul id="b0b7215e-8925-40f1-bbe3-8de115451bad" class="bulleted-list"><li style="list-style-type:disc">instance methods</li></ul><ul id="6b39c6d0-da8f-4438-a909-c606b40fa0e7" class="bulleted-list"><li style="list-style-type:disc">callback methods</li></ul><ul id="2a6848c9-364f-4d38-a63d-c88858d2784d" class="bulleted-list"><li style="list-style-type:disc">looping methods</li></ul><p id="b0e12e65-6690-410c-abe4-fad5ef32216e" class="">We are going to start off with the static methods.</p><p id="49e7d9a3-2915-445b-9e48-561dc124f5cd" class="">Open up <code>array-methods-START.html</code>, which will give you a starting version with data and commented out instructions.</p><figure id="b10e08c0-ab72-45d3-b302-da226e5bf3a4" class="image"><a href="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/532.png"><img style="width:382px" src="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/532.png"/></a></figure><p id="750894a4-6709-48c4-b9b1-08c8033ab2ed" class="">If you look at the sidebar of the array documentation, you will see there are three methods:</p><ul id="364dc15a-528e-44a3-9578-9753fc8d6f48" class="bulleted-list"><li style="list-style-type:disc"><code>Array.from()</code></li></ul><ul id="d90a4dea-2171-4d8a-bcf8-031c157ec5c8" class="bulleted-list"><li style="list-style-type:disc"><code>Array.isArray()</code></li></ul><ul id="abfccfff-9b28-451a-9d3f-afd0b9464e4f" class="bulleted-list"><li style="list-style-type:disc"><code>Array.of()</code></li></ul><p id="54b5ea72-5200-4f8a-9e0b-ac1b67e70772" class="">All the rest of the methods have <code>Array.prototype</code> and then the method instead of calling the method directly on <code>Array</code>. What is the deal with that?</p><p id="2f156da7-1870-4b8c-b19c-ca38e2758b98" class="">That is because those 3 methods are <strong>static methods</strong>, while the rest are referred to as <strong>instance or prototypal methods</strong>.</p><p id="00aac0c0-4240-47ed-9d6c-fb2b09c28862" class="">Refresh the HTML page, open the console and create the following array in the console.</p><pre id="7198c9d9-cc63-483e-8fd4-3871e4b8d608" class="code code-wrap"><code>const numbers = [1, 2, 3, 4, 5];</code></pre><p id="10944fe6-3cdb-45ca-b5e3-05e8010c577b" class="">Using this array, we can pop numbers out, push numbers in, etc.</p><p id="a2355fe6-7e62-4abb-aaa2-bb34529258c2" class="">Whenever you create an array, you get what is referred to as the array prototype.</p><p id="1cb8f456-6629-4e24-b520-a354736dcc77" class="">These are the methods that are on every single array that are available for us to work with on that array.</p><p id="12668e82-ed16-4ebb-bf59-7f0e735a3827" class="">Now there are also this thing called <strong>static methods</strong> which aren&#x27;t available on every single array, but they sort of live on the capital A <code>Array</code>.</p><p id="417a4b53-f353-4ef9-ba6b-b77b2de941ee" class="">Those are often what Wes refers to as <strong>utility methods</strong>. They are handy methods for creating or working with arrays.</p><p id="290ef66c-3af8-4d70-80e0-299c8ed0b63e" class="">We will also look at some object static methods as well.</p><p id="fc763c94-60d8-4ef7-af26-b2a6a8f893b7" class="">The way static methods work are they are NOT a method like <code>numbers.push(5)</code> <em>(you call </em><code><em>push()</em></code><em> on the </em><code><em>numbers</em></code><em> array that you created earlier)</em>.</p><p id="a70fc004-fb12-4f0b-bbb1-7cf9cf37cb40" class="">Static methods are called with something like <code>Array.from()</code> and they are access like that.</p><p id="2866c6d5-786e-4d15-91d5-dfd668c26e07" class="">Let&#x27;s go through it.</p><p id="5eafa648-c802-40dd-bbb5-5d9f44a8a165" class=""><code>Array.of()</code> is used for creating an array from it&#x27;s arguments.</p><p id="309fb499-7f4b-4ec5-8b11-b736c0d003b6" class="">For example you could pass it the arguments of &#x27;wes&#x27; and &#x27;kait&#x27; and it would create an array with those 2 items, like so 👇</p><pre id="b1f876c6-8469-4b15-9add-b839e301f778" class="code code-wrap"><code>Array.of(&#x27;wes&#x27;, &#x27;kait&#x27;);</code></pre><p id="8d88fee4-45be-4c91-ba16-6c7ef05d7fe6" class="">Wes has never used that in his career, ever, mainly because it&#x27;s shorter and simpler to create an array using an array literal.</p><p id="773811d9-f6a8-468e-bfa3-02ea0441d124" class="">There are a couple of little edge cases for it. One kinda cool this is you can spread into a function.</p><p id="55358f84-d91a-48d6-9726-226ab395be75" class="">We have already covered how when you have something, you can spread it into an array, like so 👇</p><pre id="1648e4d6-77fb-4377-8651-1f24e54e47b2" class="code code-wrap"><code>[...&#x27;wes&#x27;];
Array.of(...&#x27;wes&#x27;);</code></pre><p id="3889305a-1e72-4d98-aab9-530caf19a213" class="">What the <code>...</code> does in the example above is it takes an <strong>iterable</strong>, meaning something that has a length, <em>(&quot;wes&quot; is something that has a length because strings have a length)</em>, and you can spread each of the items of that iterable into the surrounding array.</p><p id="70b030df-821e-42bc-9461-2016526689dd" class="">So in the example above, you have spread every letter that makes up &quot;wes&quot; and put it as an item of the array.</p><p id="a3945919-46ad-43d2-8280-4a4351da6534" class="">The same things works if you are spreading into a function.</p><p id="a9ee5386-b556-4d45-baff-2d0d5e1a2b63" class="">For example, if you have a function that takes an unlimited amount of arguments, or you have something where you want to spread each item as argument 1, argument 2 etc. you can spread into a function call.</p><p id="681c26ef-1ffd-4009-b525-9c049a8d6464" class="">There is <code>Array.from()</code> which is something that Wes uses fairly often.</p><p id="44f64b15-d4eb-4e46-99df-f66b7bdcb1e0" class=""><code>Array.from()</code> will take an <strong>iterable</strong> (something with a length), and most often Wes will give it an object with a length property like so 👇</p><pre id="03b60a13-dfb0-4c02-ac1c-6f6494b5455d" class="code code-wrap"><code>Array.from({ length: 10 })</code></pre><p id="198d1b9f-fcdf-44ac-bb04-ab2b96eaec35" class="">What that will do is it returns an array from that iterable with that many empty slots. So in the example above, you are saying you want 10 spots, and that returns to us an array with 10 empty spots.</p><p id="500eb09c-10d2-4543-87c4-68d12ba3f082" class="">That is really handy because Wes often wants to make an array of numbers 1 through 10 and loop over them and display each items or something like that.</p><p id="6716c3df-6189-4142-8962-6cce3b7a5651" class="">Sometimes Wes just wants to loop from 1 to 10 or 5 to 8 and using <code>Array.from()</code> will do that.</p><p id="db7fc782-60f3-4148-9920-0b51adb006df" class=""><code>Array.from()</code> also takes in a secondary argument which is referred to as a map argument. The map argument will tell you what you can return to put into those slots.</p><p id="20d2629e-43e4-4dca-8f9c-6ce288dc38c8" class="">Let&#x27;s do an example.</p><p id="4c05dce1-2b09-4b5a-9fec-80f98f5f9e46" class="">Create a variable <code>range</code>, which will be equal to an array with 10 slots, like so 👇</p><pre id="a7270221-7038-4fb8-ab3a-32c7b62a6bdc" class="code code-wrap"><code>const range = Array.from({ length: 10 });</code></pre><p id="26bd2ac6-96d6-481b-ab31-5fde8968d170" class="">A second argument from that is a function from which you can return anything.</p><p id="14dede2f-f020-41ae-8d8e-06067bb3f1c4" class="">Add the following 👇</p><pre id="ef2aebe1-880d-4a86-a7e4-be9ae92574ff" class="code code-wrap"><code>const range = Array.from({ length: 10 }, function() {
return &#x27;wes&#x27;;
});</code></pre><p id="83b2f717-95dc-4a17-a477-3ae5cda996c1" class="">If you refresh the page, and open the console you should see that all 10 items have a value of &quot;wes&quot;.</p><p id="0b9daa22-d223-48e0-89f3-be60452bf9a0" class="">This callback function will give you the actual item that is in the slot as an argument, as well as the index.</p><p id="96776631-a46e-4127-8b63-e7f30f7da348" class="">For example 👇</p><pre id="7671063f-a67f-4d09-984a-1ed7d6d1c6cf" class="code code-wrap"><code>const range = Array.from({ length: 10 }, function(item, index) {
return index;
});</code></pre><p id="0338eece-995a-4fd6-8f5a-397739d1affd" class="">What that code above does is it gives you an array where each number is the index that you have.</p><p id="9c1a11ae-25e5-4096-ac74-a61c1b45df2d" class="">Use this to make a little function that takes in 2 arguments, <code>start</code> and <code>end</code>, like so 👇</p><pre id="d9eddec5-295c-435b-98bc-2d2aeb7e7d18" class="code code-wrap"><code>createRange(start, end);</code></pre><p id="a56d0510-02da-4f64-867f-7186b353abdb" class="">Move the <code>const range</code> variable inside of that function like so 👇</p><pre id="833fa73e-a791-41b1-b2f8-768c574e44c6" class="code code-wrap"><code>function createRange(start, end) {
const range = Array.from({ length: 10 }, function(item, index) {
return index;
});
}</code></pre><p id="cce2a1df-c402-494c-85cb-7edaab528c67" class="">However, you want to change the length value. Instead of 10, do the end minus the start like so 👇</p><pre id="8a3a2ab1-2e81-48d9-8197-221d5301c71b" class="code code-wrap"><code>function createRange(start, end) {
const range = Array.from({ length: end - start },
function(item, index) {
return index;
});
}</code></pre><p id="972e818d-5241-43b3-99e9-b331628e72b0" class="">Let&#x27;s test that out by refreshing the HTML page and opening the console.</p><p id="17e3e19a-f342-4736-a8bd-c6d295043dfa" class="">Add the following in the console 👇</p><pre id="728baab7-3ec9-44ed-8d61-56bf47df1cea" class="code code-wrap"><code>createRange(3, 7)</code></pre><p id="83c57c3a-6f8c-4ad6-89cc-ddeb0bf6563d" class="">You should see the following 👇</p><p id="d7dc9d59-df13-474e-a5b2-56d31efab428" class="">Oops! You forgot to return the range.</p><p id="aab5415d-31a8-43dc-9ca7-6fcb68dec51d" class="">Add a return to the function like so 👇</p><pre id="17320fc7-550b-459c-92a8-70879495eecc" class="code code-wrap"><code>function createRange(start, end) {
const range = Array.from({ length: end - start },

function(item, index) {
return index;
});

return range;
}</code></pre><p id="14e9c46c-5525-47ad-b918-bcab8d6a9eda" class="">You started at 3 and went to 7, which gave us 4 spots.</p><p id="40bee777-75e1-4bb8-99f2-1ce77762c436" class="">Then what you can do is return the index + the start number by modifying the code to instead of returning <code>index</code>, to return <code>index + start</code> like so 👇</p><pre id="14778a0e-1599-4c4a-af8c-344d68d2fa01" class="code code-wrap"><code>function createRange(start, end) {
const range = Array.from({ length: end - start },

function (item, index) {
return index + start;
});

return range;
}</code></pre><p id="352772b7-3891-48e8-b89e-e264e3827280" class="">If you wanted this to be inclusive of 7, you could add 1 to where you set the length of array.</p><p id="8fc8cb52-7e61-4e54-b348-1d58a266bba5" class="">You change <code>Array.from({ length: end - start})</code> to <code>Array.from({ length: end - start + 1 })</code></p><p id="8a30505b-da54-45f8-be79-c5436f808ff6" class="">That is a handy range function which Wes has probably written a dozen times in his career.</p><p id="8cbd248b-6757-4a9a-a349-467966f4c5a6" class="">So that is what Array.from() does, it creates an array given an iterable which is most likely aways going to be an object with a length on it.</p><p id="9860a8b9-c524-48ef-8240-8591d36727d6" class="">Create a range using that function.</p><p id="350733fa-f9f4-4279-bc00-90743c043dbf" class="">Add the following line underneath the range function 👇</p><pre id="2a4c0b2e-b996-4999-9694-11e68d20a80b" class="code code-wrap"><code>const myRange = createRange(3, 7);</code></pre><p id="4afe1d6d-6a0d-4325-9183-2c1534f7246d" class="">Refresh the HTML page and open the console.</p><p id="cc0346d4-708f-48d1-85ec-9cec38c83137" class="">Let&#x27;s try to the following <code>createRange(3,734223423)</code>.</p><p id="d6b77171-5f27-4d44-b832-97b6c1807056" class="">If you try that, you should get an error like so 👇</p><p id="6b22f130-483b-4e96-b818-2c0c458ddc46" class="">There is a limit to how big your arrays can be. They are very, very, very large.</p><p id="d40abadb-886c-4f5b-9bc6-cde3fffe33e2" class="">There are some additional data types in the language for having big, big arrays, and you will most likely only run into those when you&#x27;re dealing with 3D graphics and you have to work at a per pixel level.</p><p id="1aa56158-e4a7-4e5f-979f-e8c5b16ea676" class="">Let&#x27;s refresh the page, open the console and try with a smaller number as shown below.</p><pre id="a7e22505-fa7b-4889-b4e9-dbf92c7b4170" class="code code-wrap"><code>createRange(3, 7342);</code></pre><p id="2924252e-ba1b-4bb6-ae5b-5d60e44314e6" class="">You can see that runs nice and quickly.</p><p id="1ab430c3-6947-441f-8d9d-8d7b42f793b3" class="">We have looked at <code>Array.isArray()</code> before but let&#x27;s do it quickly.</p><pre id="56bf9188-b986-476c-a343-d30cdcfafbd3" class="code code-wrap"><code>console.log(Array.isArray(myRange));</code></pre><p id="58e4e974-9bbe-4636-8291-99c31a5d71dd" class="">You should see &quot;true&quot; logged.</p><p id="f21dbf19-87ec-4aee-b158-5e8e948e3429" class="">That is a pretty common thing you will need to do because if you try to use <code>typeof</code> with an array, it will return &quot;object&quot; because an array isn&#x27;t a real type.</p><p id="9aae4fce-1846-474f-b839-3356698131f5" class="">The only way to check whether an array is an array is by using <code>Array.isArray()</code></p><p id="c04ac135-1240-4806-8bd3-7a3555319415" class="">Some people sort of cheat it and instead of using <code>Array.isArray</code> they will check fo the existence of things that are array-ish such as for the existence of a length property. That isn&#x27;t good because you could have an object with a length property as well and that check wouldn&#x27;t work.</p><h2 id="7ae6f69c-4ffc-4759-bcc0-81e4b010e87d" class="">Object Static Methods</h2><p id="a190c058-0ee4-497c-afe1-89a9f310a1b8" class="">Next up we have these static methods:</p><ul id="5d1754a4-878c-4f72-81e5-75cdf6503ee5" class="bulleted-list"><li style="list-style-type:disc"><code>Object.entries()</code></li></ul><ul id="fe2345f1-178c-4866-828c-82030f0418fc" class="bulleted-list"><li style="list-style-type:disc"><code>Object.keys</code></li></ul><ul id="a9c2faff-3958-4c91-bb1f-d9ffff4b4e70" class="bulleted-list"><li style="list-style-type:disc"><code>Object.values()</code></li></ul><p id="7d427f6a-330f-433f-acf9-6b45e59e5cbe" class="">Those methods are on the object instead of on the array. However they return arrays, which is why we are covering them here.</p><p id="a621ddbf-50f0-4d6e-a7da-518de2cd0e4e" class="">This exercise requires us to take the <code>meats</code> object and make 3 arrays with <code>.entries()</code>, <code>.keys()</code>, <code>.values()</code>.</p><p id="1004c4a3-3447-4d7e-9402-0d7df29d265c" class="">Here is our meats object 👇</p><pre id="b97b0333-e741-4413-858b-40ea1a1f3264" class="code code-wrap"><code>const meats = {
  beyond: 10,
  beef: 5,
  pork: 7,
};</code></pre><p id="79ddba65-09cb-4c53-9ef7-2ccf3092c95d" class="">If you want to turn this object into an array of keys, or an array of the values, or both, that is where we use these static helper methods.</p><p id="7bfdee28-1b8c-44ef-9102-cc746485d998" class="">You use <code>Object.entries()</code> when you want to put both the keys and values into an array like so:</p><pre id="028ef053-7d46-4955-b138-f62359250709" class="code code-wrap"><code>console.log(Object.entries(meats));</code></pre><p id="4abfa282-224b-4c8f-8d69-224537cb727e" class="">Add the following code below the line where you are logging the entries array.</p><pre id="7821ee74-79bc-497a-a18e-18c68684b646" class="code code-wrap"><code>console.log(Object.entries(meats));
console.log(Object.keys(meats));
console.log(Object.values(meats));</code></pre><p id="4d8bcc77-0b71-4b6c-b0a3-00490759398e" class="">As you can see, <code>keys()</code> is going to give us an array of all the object keys, <code>values()</code> will give us an array of all the values and <code>entries()</code> is going to give us an array where each item is then a nested second array inside of it where the first item in the nested array is the key and the second item is the value.</p><p id="39212888-0ad3-48e3-8af4-634e5420d4b5" class="">These are pretty common things to do.</p><p id="cf07da55-686e-42ef-888c-e74c13e82eae" class="">One pretty common way to work with those is using the <code>forEach</code>.</p><p id="04a7875d-593e-4435-987e-8b62c2c49113" class="">This is getting a little bit ahead of ourselves because we haven&#x27;t learned about looping all that much, but Wes will show us how to do it anyway.</p><p id="d8928bcf-07a4-45fc-9dc5-87834f16687e" class="">Add the following code 👇</p><pre id="08cebc51-58ef-4433-b7a2-c3930b8ba128" class="code code-wrap"><code>Object.values(meats).forEach(qty =&gt; {
console.log(qty);
});</code></pre><p id="1ae8ed85-9d48-4d8e-b657-ae125ef5878e" class="">If you refresh the HTML page and look at the console you should see the following 👇</p><p id="9730a14e-60a8-46d3-94ec-504bf8f46c7e" class="">That is a pretty common thing to do it you want to like loop over and add up how much inventory you have or you want to add up all the numbers, lets look at how you can use <code>reduce()</code> to do that.</p><p id="998113c8-3df2-4cd7-98c1-e3482cc0cdb9" class="">The same thing is if you were to do <code>keys</code>, instead of getting the quantity we would be grabbing the values and putting them into an array and then looping over them.</p><pre id="7a0c1b57-fd0d-43fe-8872-8857bbf5e875" class="code code-wrap"><code>Object.keys(meats).forEach(qty =&gt; {
console.log(qty);
});</code></pre><p id="2604fc14-bf3c-455d-ae40-695050d209b9" class="">Now entries 👇</p><pre id="9b6a62e2-2dff-4668-a0ea-ee0d4e632640" class="code code-wrap"><code>Object.entries(meats).forEach(entry =&gt; {
console.log(entry);
});</code></pre><p id="950ae702-3506-48c1-8efe-b834181ac446" class="">For each one, you get an array with 2 items.</p><p id="b03254ab-13ce-44b8-a54b-1cfd65a2fc52" class="">The first item is always going to be the <strong>key</strong>, and the second item will always be the <strong>value</strong>.</p><p id="d587be80-0f83-4ecb-8e10-02eb21546678" class="">If you wanted to split those up into their own vairables you could do the following 👇</p><pre id="bf0d10e7-8c4c-45f4-b65b-2721ab842266" class="code code-wrap"><code>const key = entry[0];
const value = entry[1];
console.log(key, value);</code></pre><p id="26550875-46be-4bb7-929c-90d24acb6eee" class="">Something that we have talked about that is very useful in this scenario is <strong>destructuring</strong>.</p><p id="0acb4780-8195-40e1-ad00-a2fce7fd30d8" class="">Instead of using the square brackets and indexes on the entry array to grab each item, you can do this 👇</p><pre id="6f339329-ee36-417e-92ad-035956e93fcf" class="code code-wrap"><code>const [key, value] = entry;</code></pre><p id="0566aa31-f68c-4e49-81f4-dc1f80fbfec2" class="">What that code is doing is it is taking the first item in the entry array and assigning it to the variable key and it&#x27;s taking the second item and assigning it to the variable value.</p><p id="74e331d8-eb97-474f-b578-5b5e06857ad1" class="">That is the exact same thing as 👇</p><pre id="484bbb3c-50af-4243-928d-39941ff36af9" class="code code-wrap"><code>const key = entry[0];
const value = entry[1];</code></pre><p id="7a4b63e5-404c-4e05-b02d-e8470fd1f8b6" class="">You could take it even one step further and destructure the entry variable inside of the function definition rather than in the function body.</p><p id="ae22f241-23a6-4e6b-9dc1-a4b8792472c6" class="">First modify this line of code 👇</p><pre id="621be319-e127-40fc-8cc0-78b1ccad8501" class="code code-wrap"><code>Object.entries(meats).forEach(entry =&gt; {</code></pre><p id="dd0b1bd2-6db0-491f-a5d9-648999a91a03" class="">Wrap <code>entry</code> in paranthesis like so 👇</p><pre id="3158a02b-b46c-447f-bfa0-3d92a1fe0d21" class="code code-wrap"><code>Object.entries(meats).forEach((entry) =&gt; {</code></pre><p id="d2ebd734-71b7-42a6-93fb-8dbf7a2da429" class="">If you refresh the page, everything should still work, you did nothing by adding those parenthesis.</p><p id="ae946d47-c940-48a8-b560-30b4f7870732" class="">Instead of just passing one variable called <code>entry</code>, you are going to destructure that <code>entry</code> array into <code>key</code> and <code>value</code> directly.</p><p id="60bd6dae-6548-4229-8e58-8d9360161360" class="">Within the function body you do not need to do any destructuring, we can just log the key and value variables directly.</p><pre id="8e7fb41f-a3b2-4c0d-8528-b5207fd640a8" class="code code-wrap"><code>Object.entries(meats).forEach(([key, value]) =&gt; {
// const key = entry[0];
// const value = entry[1];
// const [key, value] = entry;
console.log(key, value);
});</code></pre><p id="7abf6527-559c-4fe3-a7a6-96f54e3847c8" class=""><code>key</code> and <code>value</code> are not special names, you could name them anything you want, for example this would still work 👇</p><pre id="f1e632fe-92e7-4c4a-86b3-485bf3469d8f" class="code code-wrap"><code>Object.entries(meats).forEach(([meat, qty]) =&gt; {
// const key = entry[0];
// const value = entry[1];
// const [key, value] = entry;
console.log(meat, qty);
});</code></pre><p id="e70e81ec-f745-4dfc-8752-0cb02c6782df" class="">There is nothing wrong with any of these approaches, they all work.</p><p id="130d1876-fcbf-4e1e-bc77-a23361aa2770" class="">Wes find that for some beginners destructuring can be a bit confusing so feel free to use the other approaches for now if they are more clear to you.</p><p id="dd6a5392-0fd2-473c-af44-63935f3201fd" class="">Find an issue with this post? Think you could clarify, update or add something?</p><p id="5d38ec92-4cdc-4ad6-b408-369ef3632738" class="">All my posts are available to edit on Github. Any fix, little or small, is appreciated!</p><p id="79c7a575-de00-4bc2-a2e0-e762d3c2dbbe" class="">Edit on Github</p></details></li></ul><ul id="62ef79be-97f7-411d-91fd-8a901e7b83f2" class="toggle"><li><details open=""><summary>47 - Array Cardio - Instance Methods</summary><p id="b79dea63-6293-499d-b338-4cfc281c7d11" class=""><a href="https://wesbos.com/javascript/08-data-types/47-array-cardio-instance-methods">https://wesbos.com/javascript/08-data-types/47-array-cardio-instance-methods</a></p><p id="d08c450e-91b6-437d-a709-fc241cd920e9" class="">
</p><figure id="67a3526d-f0ee-4be4-9f26-c66d3d3fc166" class="image"><a href="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/bjs%205.png"><img style="width:700px" src="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/bjs%205.png"/></a></figure><p id="2ad3107e-1266-4079-9fea-362b4bd28e9c" class="">Enjoy these notes? Want to Slam Dunk JavaScript?</p><p id="cd60318d-6108-4e93-a559-7ca2cb6d6ef0" class="">These are notes based on my <a href="https://beginnerjavascript.com/">Beginner JavaScript</a> Video Course. It&#x27;s a fun, exercise heavy approach to learning Modern JavaScript from scratch.</p><p id="10d48260-4120-44f2-9a5c-6a757f226816" class="">Use the code <strong>BEGINNERJS</strong> for an extra $10 off.</p><p id="ee33e0dd-4929-44ce-9d22-cd104b8ff5bb" class=""><a href="https://beginnerjavascript.com/">BeginnerJavaScript.com</a></p><p id="552a56ab-7fba-4430-bf56-b31ace9773fb" class="">JavaScript, Data Types, CardioEdit Post</p><p id="a379cf2d-06be-42cf-8f08-989023feae20" class="">Instance methods are methods that live on each array.</p><p id="7c490fb0-755f-4109-a700-cf3152d88634" class="">For this exercise we will be working out of the same <code>array-methods-START.html</code> file.</p><h2 id="0de625dc-10f9-4ff0-88e6-67d5a9509f86" class="">join method</h2><p id="c0646b77-40f9-4632-81e9-b905766ea08b" class="">The first exercise is to display all bun types with the letters <code>or</code>, using <code>join()</code>.</p><p id="d6b7d381-3797-4db6-ab79-189f26fb2569" class="">What is <code>join()</code>?</p><p id="9afcb979-c77e-46ac-8fef-8b950acac25a" class="">Open up the HTML page in a browser and open the console. Type in <code>buns</code> to see what we are working with and then call <code>buns.join()</code>.</p><p id="72f65ba7-1fbe-4272-9f3e-c6926aa1864c" class="">You should see the following returned 👇</p><figure id="a085d353-8366-43e2-9f0a-0cbfee1d31df" class="image"><a href="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/552.png"><img style="width:700px" src="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/552.png"/></a></figure><p id="611a2d06-d09d-4e6a-95b9-634421f80959" class=""><code>join()</code> turns the array into a string, joining each item with a comma. It takes an argument, which is what you want to join it on.</p><p id="4dc0d6a0-3823-456f-8f4c-21c1fe70ea03" class="">Add the following to the exercise file 👇</p><pre id="d9f59668-1b7d-4ada-9619-aa2bccfe16f5" class="code code-wrap"><code>console.log(buns.join(&#x27; or &#x27;));</code></pre><p id="0d709607-e416-4c93-82fe-c29dc5758d7a" class="">Now instead of being joined with commas in the string, you are joining the items using the word &quot;or&quot;.</p><figure id="a881b041-82b7-4a18-813a-df1b4f05280f" class="image"><a href="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/553.png"><img style="width:700px" src="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/553.png"/></a></figure><h2 id="7e3c713c-ca03-4f35-ac98-b52c5bb9949b" class="">split method</h2><p id="3ae62fc5-ff7c-4d24-bc20-bc0d08a870b7" class="">In the next example, you have a string with a bunch of items <strong>delimited</strong> by a comma, <code>&quot;hot dogs,hamburgers,sausages,corn&quot;</code>, and you need to use <code>split()</code> to turn it into a string.</p><p id="2f9c2d31-b91d-4b90-baf6-791a5300275e" class="">Split will take the string and split it up into an array.</p><p id="737f6ff6-73ce-4107-955a-c91c57816574" class="">Add the following code 👇</p><pre id="baa9cc5f-76e5-41c1-8cad-983d4ebfdfa2" class="code code-wrap"><code>const foodString = &quot;hot dogs, hamburgers, sausages, corn&quot;;</code></pre><p id="d74ec7bb-0b65-462f-a1a6-d3c35eee7913" class="">If you want to turn this string into an array, it&#x27;s actually not an array method, it&#x27;s a string method.</p><p id="c91a0ca1-ac86-447a-9cba-61b2caf1a78c" class=""><code>split</code> takes in an argument, which is the character on which to split the string on.</p><p id="6f9bc8b5-0e83-499b-b987-2052e0e4bc22" class="">In this example, you want to split the string on the comma. <code>split(&#x27;,&#x27;)</code> will get rid of those commas for us, which is what we want.</p><pre id="cf5b95e0-8921-4d12-acac-011c55481e2c" class="code code-wrap"><code>console.log(foodString.split(&#x27;,&#x27;));</code></pre><figure id="0ab8ea56-fec7-49a5-85f5-412c8c22ea6d" class="image"><a href="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/554.png"><img style="width:700px" src="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/554.png"/></a></figure><p id="02f98497-2e2c-412f-bfd9-1f93f28ea13c" class=""><code>split</code> is a pretty common method that is used.</p><p id="0453eab9-656c-46ec-bf6c-506819ca2108" class="">You can call <code>split()</code> and pass it nothing. That will just take every letter in the string into it&#x27;s own item. That is very similar to <strong>spreading</strong> which we did earlier.</p><p id="45cd2266-af74-43c4-8866-75f29f25d437" class="">One little &quot;gotcha&quot; about <code>split</code> is that you can do something like this no problem 👇</p><figure id="f8710150-daaa-432c-aeb0-fc8b7191324a" class="image"><a href="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/555.png"><img style="width:700px" src="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/555.png"/></a></figure><p id="c3cec6b3-8e5a-4e72-87e8-7253a4d06dc0" class="">However, if you have emojis in there, like 👇</p><pre id="7a92fff0-dd80-4e1d-a9b9-c8601a553630" class="code code-wrap"><code>&#x27;wes bos👪&#x27;.split(&#x27;&#x27;)</code></pre><p id="9dd77b68-7739-41e1-b393-9ba61d980372" class="">That emoji is actually made up of several different emojis and what is referred to as a <strong>zero width joiner</strong>.</p><p id="446fae7e-c27c-4821-8d00-8f2f24a5b01e" class="">So that will come and bite you if you ever try to split something with an emoji, just something to keep in mind. If you do run into issues doing that, there are libraries you can use to help.</p><figure id="4585490b-1c64-4cc6-952f-2cdf198aed57" class="image"><a href="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/557.png"><img style="width:700px" src="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/557.png"/></a></figure><h2 id="025690e6-483a-499d-8e9e-67d16bf91bf7" class="">pop method</h2><p id="5b8b4065-1853-4919-8202-dcb57536f8cb" class="">The next exercise is to take the last item off <code>toppings</code> using <code>pop()</code>.</p><p id="79a3e0a1-c450-45ab-a694-532ff12d0ccb" class="">We haven&#x27;t learned what pop does just yet.</p><p id="3c7385ff-14e8-4c78-9880-88a7bc8e1fa1" class="">Let&#x27;s look at the <code>toppings</code> array in the console.</p><p id="0a4a3b2c-bd75-4aa5-99c2-ac359b421a5e" class="">If you call <code>toppings.pop()</code>, it will return to us the last item in the array, which is &quot;Cheese&quot;.</p><p id="143ac95a-9e8a-49cc-8464-50dc31b8b32b" class="">If you take a look at <code>toppings</code> again, you will see that &quot;Cheese&quot; is no longer part of the array.</p><p id="050f0fa3-ac26-4ef3-9c30-2be6fd960d4d" class="">This is a handy method if you need to grab one off the end of the array and then work with it, and it will just take that item out of the array.</p><p id="36d90e83-2c20-41c1-8007-49a4669dee79" class="">Based on that, is this an immutable or mutable method?</p><p id="d070408c-f8e3-45b3-97a9-50b61ca43792" class="">It is a <strong>mutable</strong> method because it mutates the original array. It takes it off the original array.</p><p id="43cc20b1-449b-42af-a099-31847a23b84f" class="">Go ahead and do that in the code, like so 👇</p><pre id="cf6ae032-cd14-4626-8bae-5fb289fbf1fb" class="code code-wrap"><code>const lastItem = toppings.pop();
console.log(lastItem);</code></pre><p id="4dc573c2-2938-4a98-8799-e7aa546e3137" class="">The next step is to put it back with <code>push()</code>.</p><p id="4c2e7f39-1f3a-4f10-a5e1-fb2096070f9b" class="">Log what is returned from the push to a variable called <code>t2</code> and then look at it in the console. Add this code 👇</p><pre id="a1f4f059-1cad-475b-82ae-240a5818192f" class="code code-wrap"><code>// take the last item off toppings with pop()
const lastItem = toppings.pop();
console.log(lastItem);
// add it back with push()
const t2 = toppings.push(lastItem);
console.log(t2);</code></pre><p id="603edcd8-720c-464a-98e0-c21a9506fd99" class="">You should see 11 in the console. What does that mean? Well when you push an item into an array, it will return to you the new length of the array, in case you need it.</p><p id="4a41b2dc-17c6-4fb9-96c6-0067b726ee18" class="">You don&#x27;t have to put it into a variable if you don&#x27;t need it, so in our case we will remove the declaration of <code>t2</code> and instead just use <code>toppings.push(lastItem)</code> and remove the <code>console.log(t2);</code>.</p><p id="9461cb3d-11a6-4be5-b4f1-c5b73e9f43e2" class="">Instead log <code>toppings</code> to see if cheese has been added back.</p><p id="d2c47595-215f-4147-b040-3393f4dd1646" class="">It has been added back!</p><h2 id="afaa4df7-79d4-4d26-ba8e-de728b2dc793" class="">shift and unshift methods</h2><p id="c1811d7f-2eca-4ecd-89a1-ff25288b9680" class="">The next instance method exercise will be using <code>shift()</code> to take the first item off toppings. This is pretty similar.</p><pre id="bc782425-d557-4d4e-97d2-588445e63208" class="code code-wrap"><code>// take the first item off toppings with shift()
const firstItem = toppings.shift();
console.log(firstItem);</code></pre><p id="19c20a5d-5a01-4a9f-a249-c26a8c4c3868" class="">That should give us mushrooms.</p><p id="b23f745e-df9a-4f94-aad6-96b2d05d0004" class="">Next you need to add it back using unshift like so:</p><pre id="a203546b-48e0-4d28-9df6-ea16fb735792" class="code code-wrap"><code>// add it back in with unshift()
toppings.unshift(firstItem);</code></pre><p id="11e6f8a9-60c9-4980-b6a7-53d8dbe6e39e" class="">The next part of the exercise is to do the last 4 but immutable (with spreads and new variables). We know how to do that.</p><p id="54514a70-5a2c-48b8-be16-3d8c793dcf78" class="">So we need to:</p><ol type="1" id="3de5c8e0-930a-48f8-bd8a-515b39a6877d" class="numbered-list" start="1"><li>Take the last item off toppings with <code>pop()</code></li></ol><ol type="1" id="523e14cf-9d38-4da4-92fd-328673df531e" class="numbered-list" start="2"><li>add it back with <code>push()</code></li></ol><ol type="1" id="19285837-7007-4c61-b1a6-3476097bbec8" class="numbered-list" start="3"><li>Take the first item off toppings with <code>shift()</code></li></ol><ol type="1" id="4fbe38bb-d627-4754-828f-e530c0f85415" class="numbered-list" start="4"><li>add it back with <code>unshift()</code></li></ol><p id="8e4e066b-a48c-4161-b96e-93bbbc0ad2ad" class="">Start with #1, how do we take the last item off without mutating the original one?</p><p id="29fe9480-9b7b-4632-bd08-93e7c839b381" class="">Let&#x27;s use <code>slice</code>.</p><p id="5e69b45d-16e5-48bb-aeca-71c951558e6b" class="">Start at 0 and go till the end except one, so <code>length - 1</code></p><pre id="80eeab59-e1ee-4727-81b4-e2bf9ffc957e" class="code code-wrap"><code>const newToppings = toppings.slice(0, toppings.length - 1);</code></pre><p id="f6b59506-adeb-475b-9953-38e26d9e3644" class="">Cheese is now off, which is what we want.</p><p id="2efe1066-8aad-44c9-b714-4acbf6dcb889" class="">The next exercise is to put it back.</p><p id="a7050351-39bd-4c25-bea3-db86a32bf6d2" class="">Change <code>newToppings</code> from a <code>const</code> to a <code>let</code> and then spread the <code>newToppings</code> array into itself and also add that last item back on. You could reference that last item using <code>toppings.length - 1</code>.</p><p id="97806b7b-b134-4369-931b-d480099235f7" class="">We took Cheese out, but we didn&#x27;t store it anywhere, so if we need to reference it, we need to reference it from the original <code>toppings</code> array.</p><pre id="381cc906-ea0d-426f-96b2-8b046ba93a4b" class="code code-wrap"><code>let newToppings = toppings.slice(0, toppings.length - 1);
newToppings = [...newToppings, toppings[toppings.length -1]];
console.log(newToppings);</code></pre><p id="b00c7aff-9ebc-47e5-83fb-30777b0f752a" class="">We should see &quot;cheese&quot; at the end like so 👇</p><p id="91a58294-e87a-4b85-8df8-9ba7e139b492" class="">Next, we want to add it to the front.</p><p id="b23dbc5c-6c61-4930-8ecf-e50af14d2f8c" class="">We would do exactly the same thing that we did just now to add it to the back, except you start at 1 and go for the <code>length</code>, and then when you add it back in, you put it first and then spread after that.</p><p id="9a7303c5-ca2c-400f-b25d-b8d633dafb00" class="">THe next step is to make a copy of the toppings array with <code>slice()</code>.</p><p id="93c1698e-f2f7-4370-b0f9-6190ba100c52" class="">How do you make a copy of an array? You can use <code>slice()</code>.</p><p id="3416be77-4da7-48eb-97a8-3953e0f36420" class="">Add the code below 👇</p><pre id="0c334339-d7af-4b26-b734-f5912e55448a" class="code code-wrap"><code>const toppingsCopy = toppings.slice(0);
console.log(toppingsCopy);</code></pre><p id="490995c0-2dc4-4c58-b9ba-afb44dfedfd2" class="">Do we need to pass a second argument to <code>slice()</code>?</p><p id="1ce11118-fde0-4a3d-b0e9-315828f558d3" class="">Let&#x27;s look it up.</p><p id="eaa3ef8f-dd7e-42d3-89df-51ec0cf781a1" class="">It says that <code>end</code> is optional. If it is ommited, slice extracts through the end of the sequence, so we don&#x27;t need it!</p><p id="c8e99a3a-bf64-4bd9-a5bb-85c9332f3652" class="">As you can see below, that worked.</p><p id="920738e4-cf4f-41bb-a887-04ce12f17c5a" class="">The way we can tell if that is a copy is if we change the original <code>toppings</code> and then log both, like so 👇</p><pre id="f9229a77-2602-476a-8d73-42137fcfd300" class="code code-wrap"><code>const toppingsCopy = toppings.slice(0);
toppings[0] = &#x27;Mushy Boi&#x27;;
console.log(toppings);
console.log(toppingsCopy);</code></pre><p id="bbc81777-0fcd-4619-ad1e-fb151897a7ed" class="">As you can see below, only <code>toppings</code> has the &quot;mushy boi&quot; object, which tells us that <code>toppingsCopy</code> is a true copy.</p><p id="eacb8a28-ef81-4eb1-acf9-f785273120fe" class="">The next exercise is to make a copy of the <code>toppings</code> array with a spread.</p><pre id="0ade50d9-4d80-42b6-a664-ecc744a075ac" class="code code-wrap"><code>const toppingsCopy2 = [...toppings];</code></pre><p id="d951942a-bf12-402a-b719-de761d3ebc47" class="">Wes likes using spreads a lot. It&#x27;s a bit weird at first because the ... syntax might be a bit funky to you but Wes believes that once you understand what&#x27;s actually going on there and how spreads work, then you are in good shape.</p><p id="b616b1d1-a3bc-4e32-91a6-34eabd1b4707" class="">The next exercise is to take out items 3 to 5 of the new toppings array with <code>splice()</code>.</p><pre id="9bee6a1a-d7ed-43d1-a047-868398564085" class="code code-wrap"><code>toppingsCopy.splice(3,3);
console.log(toppingsCopy);</code></pre><p id="be4fe850-3bda-4f40-855a-1cdc7392d8c7" class="">As you can see, there are now only 8 items rather than 11 in the array.</p><p id="fe573921-e22f-46ee-8192-2966866f12e1" class="">Next we need to find the index of avocado with <code>indexOf</code>.</p><p id="105420d7-6bcc-405b-853e-7952d74b13ed" class="">Previously we had looked for an item using find. But if they are simply just strings or numbers, or references to an object: if you know exactly what you&#x27;re looking for, <code>indexOf</code> will do what you need it to do.</p><pre id="b5996670-fdf8-4919-9359-8813135c5aa7" class="code code-wrap"><code>const avoIndex = toppings.indexOf(&#x27;Avocado&#x27;);
console.log(avoIndex);</code></pre><p id="b9f6a723-2af8-4dbf-9173-773f623bc992" class="">If you refresh the page you should see &quot;5&quot; logged in the console. That tells us that the avocado item is in the 5th index.</p><p id="f6d7417a-df5c-48cc-9678-72340d679286" class="">One thing about <code>indexOf</code> that you should know is that it works with any type. Let&#x27;s do an example to demonstrate.</p><pre id="196b7315-c10d-450c-b626-3b8f1406ff5a" class="code code-wrap"><code>const wes = { name: &quot;wes&quot; };
const people = [{ name: &quot;scott&quot; }, wes];
console.log(people.indexOf(wes));</code></pre><p id="d21dec71-adfe-4480-a1a9-cf06518a0b9d" class="">If you refresh the page and look at the console you should see the number 1 logged, which tells us the <code>wes</code> object is at index of 1 because it is giving reference to the <code>wes</code> object.</p><pre id="e9c93df3-aaa5-458c-b452-507d4a61e17a" class="code code-wrap"><code>people.indexOf({ name: &#x27;scott&#x27; });</code></pre><p id="5072f2be-bb02-492b-ace7-70e601a7b6e7" class="">Let&#x27;s say instead of passing a reference to an object you pass in an object directly as shown in the code above 👆.</p><p id="9d688cb0-483f-44f8-9224-5579952bf4e4" class="">Note that the object we are passing is identical to the first object in the people&#x27;s array.</p><p id="6352fb6c-af31-416b-a9cf-629794160aa6" class="">However, if you try that, you will see -1 in the console.</p><ul id="f77026a6-bd20-4849-834d-10068fb2fb88" class="bulleted-list"><li style="list-style-type:disc">1 is what is returned when it didn&#x27;t find anything (the reason it doesn&#x27;t give you 0 is because 0 is the first item in the array).</li></ul><p id="723b3b8c-66a7-4e5d-b0df-5ae273e14786" class="">So why it work when we passed it <code>wes</code> but it didn&#x27;t work when we passed it <code>{name:&#x27;scott&#x27;}</code>, which is an object exactly the same as the item in the first slot?</p><p id="cd77b249-7026-42c9-8ecf-78a153d8040f" class="">That is because although the objects look exactly the same, they are not exactly the same thing.</p><p id="06fab701-df72-4d68-8723-7d78552e1059" class="">So if you were to say <code>{name : &#x27;wes&#x27; } === wes</code>, it would return false.</p><p id="5979167e-777f-493e-8aec-ab678bd6e2f2" class="">Why?</p><p id="e82a12c9-0dca-4ce5-9bc6-71cafd3189c9" class="">Because objects don&#x27;t do a deep check to see if all the properties match up, they just check if the reference to it is actually the same object.</p><p id="1b982c18-37d0-43ba-abee-72f061c395fd" class="">When we called <code>indexOf(wes)</code>, it was checking whether the <code>people</code> variable contained a reference to the object <code>wes</code>, which it did. When we checked it for an object that just looks the same, it gave us false. That is the whole reference vs value thing again.</p><p id="9aca650a-ac6a-4a61-81df-d2916aa5580c" class="">If you did need to find scott in that example you would just use <code>find()</code> with a callback.</p><p id="68adca46-a6bc-4e11-ba66-ec73743f2848" class="">The is also <code>lastIndexOf()</code>.</p><p id="71fb4734-59a1-43dd-9b92-e99be28d9613" class=""><code>indexOf()</code> will find you the first instance of the argument you pass, whereas <code>lastIndexOf</code> will find you the last instance of it.</p><p id="d2271b41-1a70-464c-900b-c48e3ff481be" class="">Next we need to check if hot sauce is in the toppings array using <code>includes()</code>.</p><p id="c8ff4e65-72a9-49ba-bd93-adefabd70aff" class=""><code>includes()</code> is useful.</p><p id="338e9d20-5692-41b3-9937-7d47bc57677f" class="">Let&#x27;s say you have an array of numbers.</p><p id="835e2c16-5bce-4af5-93fe-2b9db53e7582" class="">You can call <code>includes()</code> to check if the array contains that number, like so</p><pre id="9faae110-7755-466e-a0a7-e18d7df4e313" class="code code-wrap"><code>[1, 2, 3, 4].includes(4)</code></pre><p id="913879d8-c0f0-43d4-8f9e-bb4d83dcd9d4" class="">If you passed <code>includes</code> an object, it would check if the reference to that object exists in the array.</p><p id="f72194b8-e272-47f5-ab05-6eab65200ca6" class="">1</p><pre id="409fcd9f-b945-43cf-a356-603fcfcb0af5" class="code code-wrap"><code>const isInToppings = toppings.includes(&#x27;Hot Sauce&#x27;);
console.log(isInToppings);</code></pre><p id="922bfafe-ae77-4abd-9d1a-c126744bd658" class="">Note that includes is case sensitive, so if you were checking for all different versions of the case, what you would want to do is first lowercase the entire array with <code>.map()</code> which we will look at in the next couple of videos.</p><p id="93e6cbb6-7307-4584-80d4-c7a6c058c6ad" class="">Next you are supposed to add &quot;Hot Sauce&quot; if it is not already included in the toppings array.</p><pre id="a72ba925-c0b8-40c8-8850-10a77d8529a4" class="code code-wrap"><code>// add it if it&#x27;s not
if (!isInToppings) {
toppings.push(&quot;Hot Sauce&quot;);
}
console.log(toppings);</code></pre><p id="b4c26653-20fc-4644-94d7-03ce9ed80e5a" class="">Finally you need to fip the toppings around using <code>reverse()</code>.</p><p id="17e34c15-750c-45db-92a2-b0ad91761345" class="">There are 2 ways to reverse, you can just call <code>toppings.reverse()</code> which you know is a <strong>mutable</strong> method, meaning it will reverse the toppings array for us.</p><pre id="9413f299-111e-44be-9bde-099e18166fc7" class="code code-wrap"><code>// flip those toppings around with reverse()
toppings.reverse();
console.log(toppings);</code></pre><p id="a498b370-30a8-47c9-8ddd-fe8ab08cbb45" class="">If you want to do it <strong>immutably</strong> without modifying the original toppings array, you can create a new array, spread toppings into it, and then call <code>reverse()</code> directly on it like so 👇</p><pre id="bfeb2490-29dc-4bed-b485-96e535de27ee" class="code code-wrap"><code>const toppingsReversed = [...toppings].reverse();</code></pre><p id="66795e23-b567-413e-a4bf-41363ecd293c" class="">Using the second approach leaves <code>toppings</code> untouched because it just reverses our new array, which is a copy of <code>toppings</code>.</p><p id="ab1d3933-4b17-43fa-afe7-a492c096a01e" class="">Those are the main methods Wes thinks will be helpful.</p><p id="5fe062a7-1609-430a-ac9c-941e0d3229a2" class="">There are a couple of others that are used often, you can take a look at the MDN list, but almost all of those are callback methods or filtering methods.</p><p id="2b26f928-ad81-4470-bf6b-90130013abc6" class="">We will talk about callback methods in the next video.</p><p id="a4783d3d-e4a7-49eb-9a05-b693e6a6c06d" class="">Find an issue with this post? Think you could clarify, update or add something?</p><p id="0a59aea2-c6b6-4850-a009-0cdd532c4983" class="">All my posts are available to edit on Github. Any fix, little or small, is appreciated!</p><p id="48c53cca-3d10-4121-94c1-da4fe8d8e80a" class="">Edit on Github</p></details></li></ul><ul id="c16ba846-2077-470c-a77a-e783a1835fe4" class="toggle"><li><details open=""><summary>48 - Array Cardio - Callback Methods and Function Generation</summary><p id="296e8fa1-18c6-4eb4-88ab-d7d3f97fe636" class=""><a href="https://wesbos.com/javascript/08-data-types/48-array-cardio-callback-methods-and-function-generation">https://wesbos.com/javascript/08-data-types/48-array-cardio-callback-methods-and-function-generation</a></p><p id="b704afd6-7506-4ea5-9eac-6b4397f617d7" class="">
</p><figure id="9fd7785f-f1d1-404a-ad3e-1df7fa25413b" class="image"><a href="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/bjs%206.png"><img style="width:700px" src="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/bjs%206.png"/></a></figure><p id="5491f0f9-4ba4-45c0-a18e-9c14673e5fdf" class="">Enjoy these notes? Want to Slam Dunk JavaScript?</p><p id="a45d3ded-6eab-455c-b1ac-5044beb24488" class="">These are notes based on my <a href="https://beginnerjavascript.com/">Beginner JavaScript</a> Video Course. It&#x27;s a fun, exercise heavy approach to learning Modern JavaScript from scratch.</p><p id="d0d6346d-616a-47aa-ab2d-df67fe9ed86f" class="">Use the code <strong>BEGINNERJS</strong> for an extra $10 off.</p><p id="e5318062-ea01-4539-9ca2-303348113f49" class=""><a href="https://beginnerjavascript.com/">BeginnerJavaScript.com</a></p><p id="2470061c-9afa-4955-af09-d16c0ff17633" class="">JavaScript, Data Types, CardioEdit Post</p><pre id="bb63f930-77e1-4ca2-b565-81beffdd4616" class="code code-wrap"><code>/*
  Callback Methods
*/

// find the first rating that talks about a burger with find()
// find all ratings that are above 2 with filter()
// find all ratings that talk about a burger with filter()
// Remove the one star rating however you like!

// check if there is at least 5 of one type of meat with some()
// make sure we have at least 3 of every meat with every()
// sort the toppings alphabetically with sort()
// sort the order totals from most expensive to least with sort()
// Sort the prices with sort()</code></pre><p id="10c68ccd-0a0d-48e6-a1af-575f7e476221" class="">In this lesson we are going to cover what Wes calls <strong>&quot;callback&quot; methods</strong> methods. They aren&#x27;t actually called callback methods, Wes just made that up.</p><p id="597c39df-fbb3-4760-8ee5-fa63e17006eb" class="">The reason he is grouping all of these methods into their own section (which he is calling &quot;callback methods&quot;) is because before we even hit looping, a lot of these methods take a function as an argument and it&#x27;s often called a callback.</p><p id="74e1066e-8863-4831-a243-5c0e0d5f1031" class="">The one that we have used so far is <code>find()</code>. We are going to dig into how this work with find right now.</p><p id="ae47b50d-bc3b-4304-89cf-c15674d5d141" class="">First we need to find the first rating that talks about a burger using <code>find()</code>.</p><p id="60e9cfc1-7b3b-4e80-9b7d-65bf03f5cf0f" class="">We have this data to work with 👇</p><pre id="d984fd7b-80f3-447b-91c6-49bb20d2a522" class="code code-wrap"><code>const feedback = [
{ comment: &quot;Love the burgs&quot;, rating: 4 },
{ comment: &quot;Horrible Service&quot;, rating: 2 },
{ comment: &quot;Smoothies are great, liked the burger too&quot;, rating: 5 },
{ comment: &quot;Ambiance needs work&quot;, rating: 3 },
{ comment: &quot;I DONT LIKE BURGERS&quot;, rating: 1 },
];</code></pre><p id="240c279c-8a25-4127-a37d-cebc4eedc592" class="">We want to find the first one that has either the word &quot;burg&quot; or &quot;burger&quot; in it.</p><p id="835e78bf-8acc-4fd1-b638-dc93aa02ea2f" class="">Add the following code 👇</p><pre id="6464456b-c9bd-44cb-afad-f24f70ba1083" class="code code-wrap"><code>const burgRating = rating.find();</code></pre><p id="f021f8b7-779c-44ac-8e14-71192441748d" class="">Let&#x27;s look up <code>find()</code> on MDN.</p><blockquote id="a1da2036-51bd-4d6a-a4fe-67f49268394f" class=""><p id="5a5fdaf6-53ad-4493-8ca1-0d9323d68210" class="">T he find() method returns the value of the first element in the provided array that satisfies the provided testing function.</p></blockquote><p id="4d185cf2-fa8f-4445-aa75-08d93efb25d8" class="">As you can see, the <code>find()</code> function takes a callback as it&#x27;s argument. It takes in the nested arguments of <code>element</code>, <code>index</code> and <code>array</code>, which are optional.</p><p id="50ab603e-d4a1-4df8-ab5d-ba9b1355fdfa" class="">What does that all mean?</p><p id="3cbd722c-a343-4593-aae7-4edbe4ab8689" class="">It means that the argument of <code>find()</code> is going to be a function that either returns true or false when it has found the item that it wants.</p><p id="0d240923-bcbd-4857-93f0-2b94add37a46" class="">We have been doing something like this with an arrow function.</p><pre id="9efdfefc-a364-4d4a-bb82-ee40d49b1439" class="code code-wrap"><code>const burgRating = feedback.find(rating =&gt; rating.comment.includes(&#x27;burg&#x27;));
console.log(burg);</code></pre><p id="7bca57f6-8dd8-4092-93f9-c04d5ca43853" class="">Let&#x27;s refresh the HTML page, open the console and see how this works.</p><figure id="b28a0ac2-8ab5-4ed9-b14f-2c258ead2926" class="image"><a href="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/580.png"><img style="width:700px" src="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/580.png"/></a></figure><p id="592ffeb6-5591-4c94-aca8-f6cdd9d6f933" class="">As you can see it returned a comment &quot;Love the burgs&quot;.</p><p id="0bb2b5ed-ba26-4c59-ab47-7caad35909fd" class="">So what is this part we have highlighted in this image below?</p><figure id="9a8efbc0-b531-4417-b2d8-c8c0652382e6" class="image"><a href="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/581.png"><img style="width:700px" src="8%20-%20Data%20Types%201a54edb1ad2949018323acf1435070d4/581.png"/></a></figure><p id="e895e0a9-3ced-4e5e-a0e5-f0ede8a105e7" class="">It is a function.</p><p id="cc47f88a-beeb-48de-bc91-85d50542b8e2" class="">Create a function called <code>findBurgRating</code> which takes in 3 arguments, and we know what those are from the MDN docs we looked at a few minutes ago.</p><p id="e9056fe6-ee11-4dd8-8528-126957dd0ab1" class="">First it takes <code>element</code>. The element is just a nice way of saying each individual item. So rather than calling it element, we can name it something that is meaningful to use. Wes is choosing to call it <code>feedback</code>.</p><p id="495d9caf-1318-4829-b6f9-0b1d6fce4684" class="">The next argument is going to be the index. That is often short formed to an <code>i</code>. If you ever need to know what index something is when you are in the loop, you have access to it.</p><p id="c7fa3fc1-bb1e-4c6b-8c4d-f27dd64038b7" class="">The third argument is the array. If you ever need to reference the entire array while you are inside of the function, you can use that argument.</p><p id="585da9c6-7c6e-4fe2-bee6-ac95fb22354c" class="">Typically Wes doesn&#x27;t need to pass both index and array but if you ever do need access to where it is in the array as well as the original array, you can use that.</p><p id="7e497af4-a3f3-4ced-a89f-2cc6ff142604" class="">You might be asking, why don&#x27;t we just use reference it by the feedback array?</p><p id="af81b50a-95df-4d74-98e8-54271e0deea0" class="">That is because this function could be reused on multiple arrays, and in order to make it a function that can be reused on many arrays, we can pass in.</p><p id="06024b36-33d5-4db2-8537-56a7872bda08" class="">Right now we don&#x27;t need to pass index or the array, we just care about the feedback (the element argument).</p><pre id="d9a052cf-ea94-4b7b-b12e-ec1235b3738c" class="code code-wrap"><code>function findBurgRating(feedback) {
console.log(feedback);
}</code></pre><p id="69e0e076-bc4f-4767-8528-1bdca6e45f37" class="">Instead of doing an inline function within the <code>find</code> function, we can just simply pass the function <code>findBurgRating</code> like so 👇</p><pre id="4b515be2-5970-4eca-ba53-5734f6e88d5d" class="code code-wrap"><code>function findBurgRating(feedback) {
console.log(feedback);
}

const burgRating = feedback.find(findBurgRating);
console.log(burgRating);</code></pre><p id="dc693010-0bbe-48d8-8a63-f6903ccfca3f" class="">Notice that we do not put parenthesis on <code>findBurgRating</code>. We do <code>findBurgRating</code> instead of <code>findBurgRating()</code>. That is because we are not calling the function, we are simply passing it reference to the function and JavaScript itself is going to run that function once for each item in our feedback array.</p><p id="9b884e24-d654-444c-8689-e6ce3ea759c5" class="">Modify the parameter name in <code>findBurgRating</code> from <code>feedback</code> because it&#x27;s not singular. Rename it to <code>singleFeedback</code> like so 👇</p><pre id="2de4fc57-4a50-4ec3-8174-6d202e95a200" class="code code-wrap"><code>function findBurgRating(singleFeedback) {
console.log(singleFeedback);
}</code></pre><p id="26377ccb-4479-43ca-b4d5-179945b69e6e" class="">Now when we run this, you see that every comment is logged in our console.</p><p id="f590796d-1942-417f-a1c5-63b2649a1af1" class="">Add a <code>return true</code> to our <code>findBurgRating</code> function.</p><pre id="8ec4b6ff-ce72-40cf-8c05-5e348e9eb5cd" class="code code-wrap"><code>function findBurgRating(singleFeedback) {
console.log(singleFeedback);
return true;
}</code></pre><p id="08c28553-8d8d-429d-a9fe-d52ccb2fd981" class="">What will happen then is it will only every log the first one, and then it will stop.</p><p id="3e83b2f7-de7e-466f-8238-4a4d425efb56" class="">As soon as you return true from the callback function, it thinks you have found the thing you are looking for, and it will then return the item in the array.</p><p id="035bca0a-04f7-40d4-8cee-86fd61977f39" class="">Within the <code>findBurgRating()</code> method, add an if statement that looks whether the word burgs or burger is within that <code>singleFeedback</code> item&#x27;s comment.</p><p id="690b1e22-aefe-484e-a2d0-fa24544a7746" class="">Modify the code like so 👇</p><pre id="1d179075-2c8a-47e1-bd6d-e35d82b44caa" class="code code-wrap"><code>function findBurgRating(singleFeedback) {
if (singleFeedback.comment.includes(&#x27;burg&#x27;)) {
return true;
} else {
return false;
}
}</code></pre><p id="f5fcc6d8-4824-4196-99eb-f5d400ae9d56" class="">Now when you refresh, you should see the following logged in the console 👇</p><p id="298e0930-19c1-4e48-803c-c79e2e81fe86" class="">It looped over and found the first item to contain &quot;burg&quot; in the <code>feedback</code> array.</p><p id="2929b437-4304-4d9d-b261-61c59c3fc2d4" class="">We can refactor that code to make it a bit shorter.</p><p id="b480961a-d955-413a-ba6e-c2cbb3a4408f" class="">Because we are checking for a condition, and a condition is something that tests whether something is true or not, and <code>includes()</code> is a method that will only ever return true or false, we don&#x27;t actually have to have an if statement and return true or false ourselves. We can simply get rid of that and simply return the results of the condition, like so 👇</p><pre id="b4475643-64fe-49b3-9d16-ef1439dc65ce" class="code code-wrap"><code>function findBurgRating(singleFeedback) {
return singleFeedback.comment.includes(&quot;burg&quot;);
}</code></pre><p id="005a31ab-0710-483f-beca-fbbe4d4b7575" class="">If you refresh the page, you will see that it still works.</p><p id="618dd70b-cbb3-4114-8ce7-fb6ff8033cb9" class="">That is just one way to do this. You will often see Wes doing it inline, but anytime you find yourself writing the same code more than once, you can refactor it out into it&#x27;s own reusable function.</p><p id="59db33e5-6995-4573-8e84-06e15822fcd4" class="">The <code>findBurgRating</code> function, just like everything else, can be any type of function.</p><p id="688fed19-23d8-493b-876d-3cb968f469d6" class="">You can do it like we did in the example, or you could modify the function like so 👇</p><pre id="524b7b6f-e72d-432a-aa34-caed58c95830" class="code code-wrap"><code>const findBurgRating = function(singleFeedback) {
return singleFeedback.comment.includes(&quot;burg&quot;);
}</code></pre><p id="68038b36-67ff-4d0f-baa9-eee3935ba60e" class="">That works the exact same.</p><p id="0ac673f3-dadc-4b96-a94b-39329f6a58f3" class="">You can also make it an arrow function.</p><pre id="52cfa5cf-7d6b-4d95-9888-66928fbb79a5" class="code code-wrap"><code>const findBurgRating = (singleFeedback) =&gt; {
return singleFeedback.comment.includes(&quot;burg&quot;);
}</code></pre><p id="3764488a-2a8f-4a24-9684-dcb4b248d045" class="">That works too. We could go even one step further and make it an implicit return.</p><pre id="08781456-49a8-48f6-ba03-d9e2c10f8362" class="code code-wrap"><code>const findBurgRating = (singleFeedback) =&gt; singleFeedback.comment.includes(&quot;burg&quot;);</code></pre><p id="eb75482e-a17f-43fe-9e57-5eba737bf8fc" class="">Now that function has become a one-liner.</p><p id="cb3c6085-8331-4504-a5dc-3309a1c302fd" class="">There is one more pretty common way to do this. That is grouping all those find functions into an object.</p><p id="79730839-ab07-4334-9a09-57d0ddb06869" class="">What Wes will do is he will create an object called <code>util</code> or something, and inside of that, he will put all his helper functions for finding things that he is looking for.</p><pre id="60a841ca-c011-412d-9570-b2d938b8fc7f" class="code code-wrap"><code>const util = {
findBurgRating: function(singleFeedback) {
return singleFeedback.comment.includes(&quot;burg&quot;);
}
}</code></pre><p id="18533d7e-c91b-4a35-9d7e-8e4bd622205e" class="">What you have done above is you put the function inside of an object which turns it into a method. Now when you are looking for something, you can just pass it <code>util.findBurgRating()</code>.</p><p id="ab4a69f5-07f2-46b4-98f7-0413e85f1d67" class="">There is actually one more way, which is putting them in modules and importing and exporting them. We will look at that when we get to modules.</p><p id="e8afbb52-bf22-44fe-bebe-dfc20aa7a661" class="">One other concept is functions that return other functions. Those are referred to as <strong>high-order functions</strong>.</p><p id="18085c52-8df9-44dc-a16b-d75d422d737d" class="">Wes is going to show us how those work.</p><p id="f4d83e58-8d4c-44cb-abb7-f87c5a5db149" class="">The <code>findBurgRating</code> function is very tied to the word &quot;burg&quot;. If we wanted to make another function that looked for another word, for example the word &quot;smoothie&quot;, we would have to duplicate our <code>findBurgRating</code> method, and make a <code>findSmoothieRating</code> function and then swap out the word we are looking for like so 👇</p><pre id="daa6c0ce-768d-4970-86a3-f78e304d2920" class="code code-wrap"><code>const findBurgRating = (singleFeedback) =&gt; singleFeedback.comment.include(&quot;burg&quot;);
const findSmoothieRating = (singleFeedback) =&gt; singleFeedback.comment.includes(&quot;Smoothie&quot;);
const burgRating = feedback.find(findSmoothieRating);

console.log(burgRating);</code></pre><p id="4606ad8e-e3e8-447b-8f1f-9adfb2041dd0" class="">That might seem a bit weird.</p><p id="73086c15-dbfc-4847-87d8-34ff828a69df" class="">You may be thinking &quot;Do I have to create a new function for every single word?&quot;</p><p id="79b74a3d-5bb1-4ec5-98dc-0a7a4fd8004b" class="">The answer is no!</p><p id="a1b2a746-f9dc-4f1d-b327-4e7f557455ec" class="">We can create a function that will create these functions for us.</p><p id="f43dffe6-9091-423b-b47c-51a36aefeb6c" class="">Comment out the <code>findBurgRating</code> and <code>findSmoothieRating</code> functions and make another function called <code>findByWord</code>, which takes in one argument: <code>word</code>.</p><p id="c5aa22f5-7ae9-410d-9158-1dd9cef33e53" class="">In that function, we are going to return another function which takes in the <code>singleFeedback</code> and returns true or false based on whether the object includes the word we have passed like so 👇</p><pre id="de634146-0354-48eb-af0a-1657cd5e6ea8" class="code code-wrap"><code>function findByWord(word) {
return function(singleFeedback) {
return singleFeedback.comment.includes(word);
};
}</code></pre><p id="c24575a8-bbff-465a-b5d2-f6a5c5a684a3" class="">So this function <code>findByWord</code> you can think of as a sort of momma function which returns another function, and we have made this function machine which will turn out more functions.</p><p id="8196d1fd-e552-4769-a573-ba440b8cdcd0" class="">What we can do here is modify how we grab <code>burgRating</code> like so 👇</p><pre id="38a4cb30-1612-412c-95de-6e308e0720ae" class="code code-wrap"><code>const burgFinder = findByWord(&#x27;burg&#x27;);
const burgRating = feedback.find(burgFinder);</code></pre><p id="fa16715b-a03b-4492-be67-84279bd5346e" class=""><code>burgFinder</code> is just a function that is setup for finding the word burg and we can pass it to the <code>find</code> method.</p><p id="6481ce04-2508-441e-a2ad-3a0fe091f092" class="">Now we can do something similar with the word smoothie like so 👇</p><pre id="275c2e81-08fe-4044-a6ec-e80042b53a33" class="code code-wrap"><code>const burgFinder = findByWord(&#x27;burg&#x27;);
const burgRating = feedback.find(burgFinder);

const smoothieFinder = findByWord(&#x27;Smoothie&#x27;);
const smoothieRating = feedback.find(smoothieFinder)</code></pre><p id="479b0cac-44f8-4fd6-8ce7-9e37b6566b79" class="">What we have done is created a function, <code>findByWord</code>, which makes a function. We have made <code>findByWord</code> flexible enough that we can pass it the word we are looking for and it will find the specific word that we want.</p><p id="41b99200-41f6-4ee3-b68b-3c26583558bf" class="">We don&#x27;t even need the <code>smoothieFinder</code> and <code>burgFinder</code> variables. We can instead just pass them directly like so 👇</p><pre id="b01fec10-ecb6-4e9f-bc75-08f2f287e8c7" class="code code-wrap"><code>const burgRating = feedback.find(findByWord(&#x27;burg&#x27;));
const smoothieRating = feedback.find(findByWord(&#x27;Smoothie&#x27;))</code></pre><p id="f8f2acc7-0156-426f-98f3-3e7f35fd7826" class="">You might be saying, &quot;hold on Wes, I thought you weren&#x27;t supposed to call a function when you pass it to find. I thought you were just supposed to pass it reference to the function&quot;.</p><p id="0bf9bd7d-2d4a-4e25-96d3-9adc7ac92b24" class="">The key here is that <code>findByWord()</code> function doesn&#x27;t find the burger itself, instead it returns a function which then, in turn, will find the burg for you.</p><p id="7b4a2b88-0bd6-4b03-ba4d-aec8030bf5dd" class="">To demonstrate this, open the console and clear everything.</p><p id="b6d0786f-3687-478e-8a98-83f107a8cad1" class="">Try running <code>findByWord(&#x27;burg&#x27;)</code> and see what is returned in the console.</p><p id="61e28d01-56b4-4856-93a1-e1d42f9f3c1d" class="">As you see, when you run the <code>findByWord</code> burg function, it returns to us another function that is then setup to find the word burg in it.</p><p id="215387e7-1ead-4950-be3c-f059cbf2368c" class="">That is a bit of an advanced example, but if you do find yourself in a situation where you keep writing the same code over and over and just one thing is changing, then maybe come back to this video to refresh on how we made a function that returns another function.</p><p id="79959e53-cccc-4b73-9204-69d3e6698fb0" class="">The next exercise is finding all the ratings that are above 2 using <code>filter()</code>.</p><p id="1e5b89f3-9f5e-4631-909d-240cd90769ef" class=""><code>filter()</code> works very much like <code>find()</code> but it will return to you a new array instead of just one item.</p><p id="b29c6f25-1dbb-4d08-952d-ade80c1f7917" class="">The <code>filter</code> method will loop over every single one and either return true (I want to keep it) or false (I don&#x27;t want to keep it).</p><pre id="ae10c4a3-e619-4f19-8a4d-53ef8bde8811" class="code code-wrap"><code>const goodReviews = feedback.filter(singleFeedback =&gt; {
if (singleFeedback.rating &gt;= 2) {
return true;
} else {
return false;
}
});

console.table(goodReviews);</code></pre><p id="fe354dfa-4179-4c7b-b5cd-4a188dd932b1" class="">As you can see, this also returns an item with a rating of 2 so let&#x27;s actually change our filter from greater than or equal to 2 to just greater than 2. Now we only get 3 items returned.</p><p id="d59f1ff7-e40a-4185-9c1f-bedce6941928" class="">How can we make this function better? We have done this a few times now so you can feel free to do it yourself.</p><p id="1329cfb2-0f13-460b-a896-d614d28b6dc9" class="">This function contains a condition that returns true or false, so we can just simple return the condition instead, and use an implicit return, like so 👇</p><pre id="22795671-0b95-42d5-b939-1ae906cc7ead" class="code code-wrap"><code>const goodReviews = feedback.filter(singleFeedback =&gt; singleFeedback.rating &gt; 2);
console.table(goodReviews);</code></pre><p id="51bd05ee-bcba-4151-afa2-9d3d176abdc6" class="">That should work the same.</p><p id="38a1fcbc-4adf-45af-93c1-caa829e84b02" class="">Now could we do another function like <code>findByWord</code>?</p><p id="4022c0c9-6c3d-4d78-8616-8d6083864237" class="">Yes, we can!</p><p id="297dc47e-9cb0-4a68-90f5-e17834f29231" class="">Add the following function <code>filterByMinRating</code>.</p><p id="249ce436-acf1-4e02-b60f-b7440cd02822" class="">One thing to note with these filtering and find methods is it is a lot easier if you explicitly name them to describe what they are supposed to do because quite often they will be in another file or something, and it is nice to be able to know what they do just by the name without having to look at the function.</p><pre id="86decd3e-d9ad-4e23-8064-1d29a06970e9" class="code code-wrap"><code>function filterByMinRating(minRating) {
return function(singleFeedback) {
return singleFeedback.rating &gt; minRating;
}
}</code></pre><p id="25c03c43-a5ee-4e3d-9786-727183a3e5b0" class="">Another thing to note is that the function we are returning does not have to be named. It can be, but there is no need to.</p><p id="a2e808bd-ffba-4f37-aafb-b0874daac05b" class="">Our function above takes in a <code>minRating</code> value and then returns another function that checks whether the object passed in contains a rating greater than the <code>minRating</code> that was passed.</p><p id="da247fe4-5d1a-4055-bc55-9cfc5bfe399d" class="">Now we can go to our <code>filter</code> function and replace the filter by generating another function like so 👇</p><pre id="039cf195-6854-401c-8d0a-8ff9cdcad225" class="code code-wrap"><code>const goodReviews = feedback.filter(filterByMinRating(2));
console.log(goodReviews);</code></pre><p id="596a257a-c371-4a72-9bfe-eb37d2f0d1d6" class="">If you refresh the HTML page and open the console, you will see that it still works.</p><p id="f80349bf-2283-48f6-9492-cb9d24a06a3e" class="">Now we can change our filter to take any items with a rating over 4 like so:</p><pre id="27f1900c-e990-421c-9e9d-52b71a39675e" class="code code-wrap"><code>const goodReviews = feedback.filter(filterByMinRating(4));</code></pre><p id="0c74e0d0-e00e-4e60-9a00-9b15319c333d" class="">The next exercise asks use to find all the ratings that talk about a burger using <code>filter</code>.</p><pre id="e1ab68b2-ae3f-45f1-a9c9-f5c8bbb00ffb" class="code code-wrap"><code>const burgRatings = feedback.filter(singleFeedback =&gt; singleFeedback.comment.includes(&#x27;burg&#x27;));
console.table(burgRatings);</code></pre><p id="a9eee8ea-f3f4-4a89-bf1a-b1a63c19b58d" class="">You might be saying &quot;hold on Wes, didn&#x27;t we already do that with our <code>findByWord</code> function?&quot;. Yes, we did! What we can do is we can actually just reuse the function in our filter like so:</p><pre id="0450a39b-44b0-4491-a98b-a36b88207d7f" class="code code-wrap"><code>const burgRatings = feedback.filter(findByWord(&#x27;burg&#x27;));
console.table(burgRatings);</code></pre><p id="432487a7-6030-47c1-927f-73641a914e12" class="">If you refresh the page, you will see that it still works.</p><p id="b76057ca-ea4d-4c9b-bcec-ed69b381920c" class="">So what we have done is we have written a JavaScript function, <code>findByWord</code> that can be used both for our <code>find</code> method and our <code>filter</code> method because they both just check whether a condition is true ot not.</p><p id="6ffffff1-0996-4098-9035-c5b08e83a0b8" class="">It is fine if you don&#x27;t create re-usable functions all the time, because sometimes a small little arrow function just does the trick. However it is good to know that if you ever keep repeating yourself over and over than you should probably refactor to save yourself some typing.</p><p id="1ead3339-e36a-459d-bb5c-3e7cd03d4d47" class="">The next exercise is to remove the 1 star rating, however we like.</p><p id="ed135e4b-bf84-440c-a69c-850ba7dc9b2c" class="">Let&#x27;s take a look at the one star rating.</p><p id="aa670c84-2db1-48e0-ad36-d89d178845c3" class="">So there is a few ways we could find the one star rating. We could filter out comments that are done in all caps, or filter ratings that are equal to 1. Let&#x27;s go with the second approach.</p><pre id="a45120bb-8abc-423e-8d4d-da757ebb0b44" class="code code-wrap"><code>const legitRatings = feedback.filter(single =&gt; single.rating === 1);
console.log(legitRatings);</code></pre><p id="9a1056f6-5a75-4d7b-8941-a9000b7c3e5e" class="">Note: notice this time we didn&#x27;t name the variable that represents each instance we are looping <code>singleFeedback</code>? Wes named it <code>single</code> instead just to demonstrate that this variable name could be anything you choose (as long as it&#x27;s a valid variable name).</p><p id="59778314-0691-476e-af2f-7b2c2050f560" class="">As you can see above, that gives us the 1 star rating. However we want everything but the one star rating.</p><p id="c77911ce-84cf-40e0-8d35-bebb7e9b020b" class="">How do we get the opposite of that?</p><p id="f3eeecb9-bbdc-4f7f-bbb4-5b097bef9388" class="">We can simply put a bang infront of our condition like so 👇</p><pre id="9a2b70c2-866c-4f98-86b1-9bdd6d0507c9" class="code code-wrap"><code>const legitRatings = feedback.filter(single =&gt; single.rating !== 1);
console.log(legitRatings);</code></pre><p id="7e428db9-bad7-4fd2-ac29-2a559cff1c52" class="">That has given us everything else but the 1 star rating. We are not going to create a function for this one because we can do it in a simle one liner, so why not.</p><p id="74f892f0-e947-41f3-a70d-6e4caa8d2c3f" class="">The next exercise is to check whether there are at least 5 of one type of meat with <code>some()</code>.</p><p id="d9820efe-c6c1-4d69-91c1-b38baf765dac" class="">What does <code>some</code> do? Let&#x27;s take a look at MDN.</p><blockquote id="92956376-3533-492e-91e0-00b9ec5e5ba2" class=""><p id="4f55c20d-cde8-4d24-ae0d-551996d98d19" class="">The some() method tests whether at least one element in the array passes the test implemented by the provided function. It returns a Boolean value.</p></blockquote><p id="3e42b3c1-73ec-42ed-8743-ea72095a03f0" class="">Let&#x27;s take a look at <code>meats</code>.</p><p id="fcd9196a-6c1e-4c78-bb1f-ceecd92e7bbb" class="">As you can see, it&#x27;s an object. All of the stuff we have been learning about is arrays.</p><p id="c5be9bfd-665e-4f02-94bb-82ad524fca85" class="">How do you convert an object into an array so you can use these methods on it?</p><p id="199e5b54-8e3e-4d1d-b978-d7caefb5f879" class="">We can use <code>.entries()</code>, <code>.keys()</code>, or <code>.values()</code>. We will use <code>values()</code>.</p><pre id="5f78a61d-e672-4a05-a446-21c99d33a2b2" class="code code-wrap"><code>const isThereEnoughOfAtLeastOneMeat = Object.values(meats);</code></pre><p id="1fce62d5-c31b-419a-b28e-0768d213e972" class="">Next we will chain the <code>some</code> method onto our newly created array.</p><p id="fe778d46-a60d-463f-8e1b-d96e0689e67c" class=""><code>some</code> will loop over each item which we will call <code>meatValue</code> and check to see if it&#x27;s equal to or greater than 5 like so 👇</p><pre id="0740ee2c-11fb-4a13-baee-0f054ef665bd" class="code code-wrap"><code>const isThereEnoughOfAtLeastOneMeat = Object.values(meats).some(meatValue =&gt; meatValue &gt;= 5);</code></pre><p id="34bd9364-6a80-4091-b0f2-62fec3aefde0" class="">When we converted the <code>meats</code> object into an array of values, it returned the following 👇</p><p id="fd205a4f-33ad-468b-8a83-d6837cd7c9a8" class="">Next, we check if at least one of the values in that array is greater than or equal to 5.</p><p id="614b3801-6753-4194-883c-f64e5e318b6a" class="">Log the value of <code>isThereEnoughOfAtLeastOneMeat</code>, which should return true.</p><p id="0559e2e9-d2c4-412f-9aff-551e6a563eb6" class="">The next exercise is to make sure we have at least 3 of every meat with <code>every()</code>.</p><p id="38b00235-c55b-47b0-805b-37ca1cd1b815" class="">Let&#x27;s say you have 5 people in a family, and you want to make sure there is at least one adult who is greater than 19 years old. What you could do is loop through each person in the family and check for their ages using <code>.some()</code>.</p><p id="4eaf7f10-4c08-46c5-92eb-c11c06babb39" class=""><code>some</code> means at least one of (at least one person greater than 19).</p><p id="66cb71f2-bcdb-4bb8-b582-e6d0accca74e" class=""><code>every</code> means make sure every single thing in that array meets our criteria.</p><p id="8b2f1270-f841-4686-be28-8c38f3f41c1c" class="">Duplicate the code you added above and rename the variable to <code>isThereEnoughOfEveryMeat</code>.</p><p id="6477971b-1308-4825-8e98-11fa54f3ce5b" class="">Change the method from <code>some</code> to an <code>every</code> and change the condition to check whether the value is greater than or equal to 3, like so 👇</p><pre id="9de8b06c-da94-4834-9ff3-f1cdae38a703" class="code code-wrap"><code>const isThereEnoughOfEveryMeat = Object.values(meats).every(meatValue =&gt; meatValue &gt;= 3);
console.log(isThereEnoughOfEveryMeat);</code></pre><p id="ee2a617d-d2b1-46a6-82c7-39b383d6c29f" class="">If you refresh that in the console, you should see true.</p><p id="6b63a3fb-8a88-4d0b-b403-26ecdd55495a" class="">The next exercise says to sort the toppings alphabetically with <code>.sort()</code>. That is a different kind of callback function there.</p><p id="c1b95367-84fc-406c-b73c-939a7b361658" class="">So let&#x27;s say we have an array of numbers and we call sort on it, like so 👇</p><pre id="8d925e7d-a6a9-4faf-9cf2-ead842ea0229" class="code code-wrap"><code>[1, 2, 100].sort();</code></pre><p id="e68498a5-b009-4345-967c-b6b87e58de37" class="">We are returning the following 👇</p><p id="6f0a2ea2-c7ea-40ca-9f7e-8b46582e713a" class="">If we try adding a few more numbers to the array and then calling sort, we get the following:</p><p id="13fd7c0c-2b3e-49d6-8779-5bba0851d307" class="">What is going on there?</p><p id="3b12ffd5-f4db-4a16-bf32-b09bdad28f6a" class="">Let&#x27;s look up the docs on MDN.</p><blockquote id="5ef12889-df2e-458b-974f-c2a267c2519b" class=""><p id="88ca5437-94bb-48cd-b3c1-810a472aba39" class="">The default sort order is ascending, built upon converting the elements into strings, then comparing their sequences of UTF-16 code units values.</p></blockquote><p id="7c73bac9-aff2-471a-8002-ee1f49a48505" class="">That is a fancy way of saying that it does it alphabetically as a string.</p><p id="679eac8a-af25-4ee3-8236-4471022f7b00" class="">So what was happening when we were sorting our numbers array is it was converting them to strings and then sorting them.</p><p id="115b9d44-995f-4b49-8570-ce8ab7fa50ca" class="">Let&#x27;s do an example before we get into our exercise to demonstrate how it would work if you do want to sort numbers.</p><pre id="3816d41e-925e-44c5-83fb-f21c2eb4a134" class="code code-wrap"><code>const numbers = [1, 2, 100, 3, 200, 400, 155];
const numbersSorted = numbers.sort();

console.log(numbersSorted);</code></pre><p id="f39b4f94-58d9-42d7-ab9d-70e7fadd5944" class="">First log to see what it looks like when we call <code>.sort()</code> directly one it.</p><p id="603be024-6506-4d2f-9807-a78008da1e5a" class="">That is clearly not what we want.</p><p id="0de55b77-9a04-48f8-abd4-3af609566ac4" class="">The way sort works is it takes a compare callback function that defines the sort order. That callback function gives you the first and the second thing.</p><p id="e232a72c-3679-4bc2-a96b-5cd97e2e2c75" class="">So basically we are going to loop over the array and it will give us the first item, and the second thing, and then it&#x27;s up to us to decide the sort order (if one item should go in front of the other, etc).</p><p id="00bb705b-fadb-4f16-a9aa-196f01468a23" class="">So, what do you return?</p><p id="8f67a2f8-7d28-49a3-b99b-dcb606a21aef" class="">If you return less than 0, it will go before it. If you return 0, it will be unchanged, and if you return greater than 0 it will go ahead of it.</p><p id="54ef5088-b991-4de0-9cc4-086ae9498bf8" class="">We will create a regular function as our callback function for now.</p><pre id="ca6999ad-b3e3-444d-99af-58feda3b4863" class="code code-wrap"><code>const numbersSorted = numbers.sort(function(firstItem, secondItem) {
console.log(firstItem, secondItem);
});

console.log(numbersSorted);</code></pre><p id="bd5dbead-c0d2-4634-98f9-05833fb33262" class="">As you can see we get 2 items each time.</p><p id="0a1289c0-223a-441f-a027-d040166594f9" class="">We get <code>item1</code> which you can think of as being in the left hand and <code>item2</code> which you can think of as being in the right hand and it&#x27;s up to you, the developer, to tell JavaScript whether the items should switch places or remain the same. As JavaScript loops over those things, you keep switching them and eventually it will run through it enough times that there are no more switches, and that is how it knows its done.</p><p id="e1de623b-9ed3-4788-9d20-6c8b8a4beb4f" class="">So what we can do is we can return 0, -1, or 1. You can return any value, up or down, and that&#x27;s what we are going to do in our sort callback function.</p><ul id="b692e6a0-9c6e-413f-bf16-869536a17918" class="bulleted-list"><li style="list-style-type:disc">So if the first item is greater than the second item, we want to return 1.</li></ul><ul id="b7ccf72f-caec-409c-a502-f9a2590a3783" class="bulleted-list"><li style="list-style-type:disc">Else if, we will check whether the second item is greater than the first item. If it is, then we will return -1.</li></ul><ul id="bb49f198-7f52-4fb7-a7c6-213bd11332b5" class="bulleted-list"><li style="list-style-type:disc">If the numbers are the same, we will return 0.</li></ul><pre id="3f0367a7-d0f1-4a9b-961c-81451c649a93" class="code code-wrap"><code>const numbersSorted = numbers.sort(function(firstItem, secondItem) {
if (firstItem &gt; secondItem) {
return 1;
} else if (secondItem &gt; firstItem) {
return -1;
} else {
return 0;
}

console.log(firstItem, secondItem);
});

console.log(numbersSorted);</code></pre><p id="9cbf7031-e8f8-4cf9-acb2-672459edf884" class="">Let&#x27;s refresh the page to see how that works.</p><p id="bd80b1e0-f7b6-46cd-b986-652f014bebc3" class="">So that works, but it&#x27;s pretty verbose and we don&#x27;t have to return 1, -1 or zero. You can return any zero, negative number or positive number.</p><p id="0f3770cb-7e04-4e84-b5ff-43ebf8743904" class="">Because the items we are looping over are numbers, we can get aray with just returning the <code>secondItem - firstItem</code>.</p><pre id="609ec5cf-3bd3-4f53-8d9a-ec224c1c9d65" class="code code-wrap"><code>const numbersSorted = numbers.sort(function(firstItem, secondItem) {
return secondItem - firstItem;
});

console.log(numbersSorted);</code></pre><p id="5b977956-acc6-4b77-85e2-31060ec1ba36" class="">Oops, that returns it in the wrong order. It should be <code>firstItem - secondItem</code>.</p><p id="5a0f32ad-9d9a-4e92-a772-2d9a25da3b26" class="">How do you know? Just do it one way and if your array is backwards, switch them.</p><p id="890a4e6d-02d7-47eb-b5f3-ced17c47ab89" class="">So it&#x27;s going to return <code>1-2</code>, which would be <code>-1</code> which will move it to the beginning of the array. Then it will get <code>100 - 2</code>, and those numbers just help it learn how to sort itself.</p><p id="dcb2e2f3-8a6e-4a6c-9f15-30da3daa72ff" class="">So by default, it will sort itself on strings. So if you did have strings like 👇</p><pre id="448ae254-185d-4fd6-948b-2e4843a54b79" class="code code-wrap"><code>[&#x27;a&#x27;, &#x27;z&#x27;, &#x27;e&#x27;, &#x27;r&#x27;, &#x27;b&#x27;].sort()</code></pre><p id="84dfc980-fca4-4f6d-bb41-5b19c6c25e0f" class="">It will sort it easily, like so 👇</p><p id="3959686d-390c-4fd1-a0ec-fa786461f171" class="">But if you have numbers or nested elements, then you have to use a callback like we did.</p><p id="88d923e2-72c4-4dfd-9d5f-40fd7c034525" class="">We can convert our example from above to an arrow function also like so 👇</p><pre id="24a46741-8590-45e5-89ed-f54213767243" class="code code-wrap"><code>const numbersSorted = numbers.sort((firstItem, secondItem) =&gt; secondItem - firstItem);
console.log(numbersSorted);</code></pre><p id="fa1ce69f-b230-44e9-b6c3-0330a0878144" class="">If you refresh the HTML page, you will see it still works 👇</p><p id="416c91c4-782f-4b6d-b1a4-0a25cd76f3ad" class="">So now back to our exercise about sorting the toppings alphabetically using <code>sort()</code>.</p><p id="9d873174-807a-41ba-b7c0-4c4ec0fb4d02" class="">That is easy. We just need to do add the following code 👇</p><pre id="4240bccf-a21d-455d-b7d5-0c76c824109d" class="code code-wrap"><code>console.log(toppings.sort());</code></pre><p id="c9696788-7b0c-4c4b-9efb-267c249952b2" class="">The next exercise is sorting the order totals from most expensive to leat with <code>.sort()</code>.</p><p id="0386f62a-ada0-4310-afaa-3f92e200601b" class="">So this is just an array of numbers. We can do the same thing we did before, or we can make a function called <code>numbersSort</code> like so:</p><pre id="8409d2f8-1777-4101-8222-563cb6b97e8b" class="code code-wrap"><code>function numbersSort(a, b) {
return a - b;
}</code></pre><p id="6d86a9a7-2ca1-4caa-bcf0-dd139cd652c2" class="">Now we can call <code>sort</code> and just pass in that function like so 👇</p><pre id="de2386c4-b83c-492e-ac35-bb90ccf8cb3b" class="code code-wrap"><code>console.log(orderTotals.sort(numbersSort))</code></pre><p id="07610cf2-7701-4f99-8df2-d2b46f994a82" class="">As you can see, that worked.</p><p id="c59ba026-a8e8-4e3a-b129-7c42b764ff87" class="">Next we need to sort the prices with sort.</p><p id="d484a5d7-bb89-49e2-8fa6-41a503008a78" class="">Since <code>prices</code> is an object, how would we sort them?</p><p id="7edbf6ad-0fea-4a6f-b38d-bceba66356d1" class="">We can use <code>Object.entries()</code>. However, we need to keep the thing we are sorting along with it. How would we do that?</p><p id="27d1d89f-ec88-40eb-a45c-e8fc4ce6c548" class="">Let&#x27;s do it step by step.</p><pre id="3fc23ccc-7645-4c8d-ab35-12e943237e9e" class="code code-wrap"><code>const productsSortedByPrice = Object.entries(prices);</code></pre><p id="2c694058-f887-473a-854d-a4b87188fe41" class="">As you can see, that gives us an array where each item is an array.</p><p id="eb48f874-47ae-4f15-8517-953989800836" class="">Now, what we can do is sort over each of them. We will use a regular function for that which takes in 2 parameters, the first item and the second item which we will represent with the variables <code>a</code> and <code>b</code>.</p><p id="85b79e45-1963-4bf1-8ed2-42eb8288dfc7" class="">Wes isn&#x27;t a fan typically of using short variable names but in this case, he is fine with it.</p><pre id="e1804079-792f-4ede-b9cb-5b7148157a91" class="code code-wrap"><code>const productsSortedByPrice = Object.entries(prices).sort(function(a, b) {
debugger;
})</code></pre><p id="a186c294-00fa-4da7-bdd1-3bb293798118" class="">If you refresh HTMl page, the debugger will popup. You should see something like the following 👇</p><p id="a9e53804-c86d-4886-8b2a-9594be32e7be" class="">The important part is the local scope, meaning that what are these <code>a</code> and <code>b</code> variables equal to?</p><p id="056bd7e2-23c3-4777-9a45-47959d0498ca" class="">It tells us that <code>a</code> is equal to burger and <code>b</code> is equal to hotdog.</p><p id="323e7798-fbb0-41e3-bb58-66a22f6e8b27" class="">It says they are both arrays.</p><pre id="c6a5a9b3-66ba-46a5-87ac-ad49135ec33b" class="code code-wrap"><code>const aPrice = a[1];
const bPrice = b[1];
debugger;</code></pre><pre id="e213f94a-880e-44d2-b011-fe0a369ae1ae" class="code code-wrap"><code>const productsSortedByPrice = Object.entries(prices).sort(function(a, b) {
const aPrice = a[1];
const bPrice = b[1];
return bPrice - aPrice;
});

console.table(productsSortedByPrice);</code></pre><p id="b437e33d-02fd-493b-8d39-b399695c65f3" class="">As you can see, we return the most expensive to the least expensive.</p><p id="9656747c-44c0-4e0b-9ab2-54170eb62386" class="">If we wanted to turn that back into an object we can simply wrap it in <code>Object.fromEntries()</code>.</p><pre id="4b6408c1-12bb-4861-b930-3e7671cf15f2" class="code code-wrap"><code>Object.fromEntries(productsSortedByPrice);</code></pre><p id="165d88c8-590f-42ca-b4fc-c50dc47bfb4b" class="">What that does is it takes a nested array, like we have here, and turns it back into a regular objects.</p><p id="af0342ed-e64f-44e1-996b-ac7a60ff3683" class="">Remember earlier when we were learning about objects and how they are not order-sensitive?</p><p id="336df1ab-7bea-4ab4-9638-4f8f38531bae" class="">Wes has since found out that they have added it to the language where they are maintained in the order in which you put them in, except if they have numbers, in always goes to the top and then the other ones come after it.</p><p id="f29fbcc4-861f-4d92-a47a-82cc57577780" class="">Wes spends most of his time working with these sorts of functions.</p><p id="f2991f81-3f19-4d2c-a273-188a42d83510" class="">Find an issue with this post? Think you could clarify, update or add something?</p><p id="0a23f233-e572-48be-ae93-202acac7bd35" class="">All my posts are available to edit on Github. Any fix, little or small, is appreciated!</p><p id="e7602c69-137f-4474-8c45-4c36c9ad1d31" class="">Edit on Github</p></details></li></ul></div></article></body></html>